/**
 * JavaScript code generator for JUCE WebView2 bindings
 * Generates bindings.js, components.js, and mock JUCE backend
 */

import type { ElementConfig } from '../../types/elements'
import { toKebabCase } from './utils'

// ============================================================================
// Types
// ============================================================================

export interface JSGeneratorOptions {
  isPreviewMode: boolean // true = include mock, false = expect real JUCE
}

// ============================================================================
// Bindings Generator
// ============================================================================

/**
 * Generate bindings.js content
 * Creates JUCE event-based parameter bindings for interactive elements (knob, slider, button)
 *
 * JUCE native functions use an event-based invocation system:
 * - Functions registered with .withNativeFunction() in C++
 * - Available in window.__JUCE__.initialisationData.__juce__functions
 * - Invoked via window.__JUCE__.backend.emitEvent('__juce__invoke', ...)
 * - Results return via window.__JUCE__.backend.addEventListener('__juce__complete', ...)
 *
 * CRITICAL: This uses the proven working pattern with:
 * - Dynamic function wrappers from __juce__functions
 * - Polling initialization that waits for functions.length > 0
 * - Integer resultId (not Math.random())
 * - .catch() for fire-and-forget calls
 *
 * @param elements - Array of element configurations
 * @param options - Generation options (preview mode, etc.)
 * @returns JavaScript code as string
 */
export function generateBindingsJS(
  elements: ElementConfig[],
  _options: JSGeneratorOptions
): string {
  // Get ALL interactive elements (not just those with parameter bindings)
  // This allows preview/standalone mode to work even without parameter IDs
  const knobs = elements.filter((el) => el.type === 'knob')
  const sliders = elements.filter((el) => el.type === 'slider')
  const rangesliders = elements.filter((el) => el.type === 'rangeslider')
  const buttons = elements.filter((el) => el.type === 'button')

  // Generate setup calls for each element type with default values
  // Use parameterId if set, otherwise use element name as fallback ID
  const knobSetups = knobs
    .map((knob) => {
      const defaultValue = knob.type === 'knob' ? knob.value : 0.5
      const paramId = knob.parameterId || toKebabCase(knob.name)
      return `    setupKnobInteraction('${toKebabCase(knob.name)}', '${paramId}', ${defaultValue});`
    })
    .join('\n')

  const sliderSetups = sliders
    .map((slider) => {
      const defaultValue = slider.type === 'slider' ? slider.value : 0.5
      const paramId = slider.parameterId || toKebabCase(slider.name)
      return `    setupSliderInteraction('${toKebabCase(slider.name)}', '${paramId}', ${defaultValue});`
    })
    .join('\n')

  const rangeSliderSetups = rangesliders
    .map((rangeslider) => {
      const defaultMin = rangeslider.type === 'rangeslider' ? rangeslider.minValue : 0.25
      const defaultMax = rangeslider.type === 'rangeslider' ? rangeslider.maxValue : 0.75
      const paramId = rangeslider.parameterId || toKebabCase(rangeslider.name)
      return `    setupRangeSliderInteraction('${toKebabCase(rangeslider.name)}', '${paramId}', ${defaultMin}, ${defaultMax});`
    })
    .join('\n')

  const buttonSetups = buttons
    .map((button) => {
      const paramId = button.parameterId || toKebabCase(button.name)
      return `    setupButtonInteraction('${toKebabCase(button.name)}', '${paramId}');`
    })
    .join('\n')

  return `// AUTO-GENERATED by vst3-webview-ui-designer
// JUCE WebView2 Event-Based Parameter Bindings
// Uses proven working pattern with dynamic function wrappers and polling initialization

// ============================================================================
// JUCE Bridge - Dynamic Function Wrapper System
// ============================================================================

let bridge = null;
let nextResultId = 1;  // INTEGER, not Math.random() - critical for JUCE compatibility

/**
 * Create dynamic function wrappers for all registered JUCE native functions.
 * This pattern works reliably with JUCE WebView2.
 */
function createJUCEFunctionWrappers() {
  const functions = window.__JUCE__.initialisationData.__juce__functions || [];

  const wrappers = {};
  const pendingResults = new Map();

  // Listen for completion events from JUCE
  window.__JUCE__.backend.addEventListener('__juce__complete', (event) => {
    // Handle various event formats JUCE might send
    const resultId = event?.resultId ?? event?.detail?.resultId ?? event?.[0]?.resultId;
    const result = event?.result ?? event?.detail?.result ?? event?.[0]?.result;

    const callback = pendingResults.get(resultId);
    if (callback) {
      pendingResults.delete(resultId);
      callback(result);
    }
  });

  // Create wrapper for EACH registered function
  for (const funcName of functions) {
    wrappers[funcName] = function(...args) {
      return new Promise((resolve) => {
        const resultId = nextResultId++;
        pendingResults.set(resultId, resolve);

        window.__JUCE__.backend.emitEvent('__juce__invoke', {
          name: funcName,
          params: args,
          resultId: resultId
        });

        // Timeout after 1 second - resolve undefined on timeout
        setTimeout(() => {
          if (pendingResults.has(resultId)) {
            pendingResults.delete(resultId);
            resolve(undefined);
          }
        }, 1000);
      });
    };
  }

  console.log('[JUCEBridge] Created wrappers for:', functions);
  return wrappers;
}

/**
 * Initialize JUCE bridge with polling.
 * CRITICAL: Waits for functions.length > 0 before initializing UI.
 */
async function initializeJUCEBridge() {
  console.log('[JUCEBridge] Starting initialization...');

  for (let i = 0; i < 100; i++) {
    const juce = window.__JUCE__;

    if (juce?.backend && juce?.initialisationData) {
      const functions = juce.initialisationData.__juce__functions || [];

      // CRITICAL: Wait for functions to be registered
      if (functions.length > 0) {
        console.log('[JUCEBridge] JUCE available with functions:', functions);
        bridge = createJUCEFunctionWrappers();

        // Update status indicator
        const statusEl = document.getElementById('status');
        if (statusEl) {
          statusEl.textContent = 'Connected';
          statusEl.style.color = '#10b981';
        }

        // NOW initialize all UI elements
${knobSetups || '        // No knobs with parameter bindings'}
${sliderSetups || '        // No sliders with parameter bindings'}
${buttonSetups || '        // No buttons with parameter bindings'}

        console.log('[JUCEBridge] Initialization complete');
        return;
      }
    }

    await new Promise(r => setTimeout(r, 50));
  }

  // Timeout - running in standalone mode
  console.warn('[JUCEBridge] Initialization timeout - running in standalone mode');
  const statusEl = document.getElementById('status');
  if (statusEl) {
    statusEl.textContent = 'Standalone Mode';
    statusEl.style.color = '#f59e0b';
  }

  // Create mock bridge for standalone testing
  bridge = {
    setParameter: (paramId, value) => Promise.resolve(),
    getParameter: (paramId) => Promise.resolve(0.5),
    beginGesture: (paramId) => Promise.resolve(),
    endGesture: (paramId) => Promise.resolve()
  };

  // Initialize UI elements in standalone mode too
${knobSetups || '  // No knobs with parameter bindings'}
${sliderSetups || '  // No sliders with parameter bindings'}
${buttonSetups || '  // No buttons with parameter bindings'}

  console.log('[JUCEBridge] Standalone mode initialized');
}

// ============================================================================
// UI Interaction Setup Functions
// ============================================================================

/**
 * Setup knob interaction with parameter binding
 * @param {string} knobId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding
 * @param {number} defaultValue - Default normalized value (0-1)
 */
function setupKnobInteraction(knobId, paramId, defaultValue = 0.5) {
  const knob = document.getElementById(knobId);
  if (!knob) {
    console.error(\`Knob element not found: \${knobId}\`);
    return;
  }

  let isDragging = false;
  let startY = 0;
  let startValue = defaultValue;
  let currentValue = defaultValue;

  // Initialize visual
  updateKnobVisual(knobId, defaultValue);

  // Mousedown - start drag
  knob.addEventListener('mousedown', (e) => {
    isDragging = true;
    startY = e.clientY;
    startValue = currentValue;

    // Fire and forget with .catch() - proven pattern
    bridge.getParameter(paramId).then(v => {
      if (v !== undefined) startValue = v;
    }).catch(() => {});

    bridge.beginGesture(paramId).catch(() => {});

    e.preventDefault();
    e.stopPropagation();
  });

  // Mousemove - drag to update value
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const deltaY = startY - e.clientY;  // Inverted (up = increase)
    const sensitivity = 0.005;
    let newValue = startValue + deltaY * sensitivity;
    newValue = Math.max(0, Math.min(1, newValue));
    currentValue = newValue;

    // Fire-and-forget with .catch()
    bridge.setParameter(paramId, newValue).catch(() => {});
    updateKnobVisual(knobId, newValue);
  });

  // Mouseup - end drag
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      bridge.endGesture(paramId).catch(() => {});
    }
  });

  // Double-click - reset to default
  knob.addEventListener('dblclick', () => {
    currentValue = defaultValue;
    bridge.setParameter(paramId, defaultValue).catch(() => {});
    updateKnobVisual(knobId, defaultValue);
  });
}

/**
 * Setup slider interaction with parameter binding
 * @param {string} sliderId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding
 * @param {number} defaultValue - Default normalized value (0-1)
 */
function setupSliderInteraction(sliderId, paramId, defaultValue = 0.5) {
  const slider = document.getElementById(sliderId);
  if (!slider) {
    console.error(\`Slider element not found: \${sliderId}\`);
    return;
  }

  let isDragging = false;
  let startPos = 0;
  let startValue = defaultValue;
  let currentValue = defaultValue;
  const isVertical = slider.classList.contains('vertical');

  // Initialize visual
  updateSliderVisual(sliderId, defaultValue);

  slider.addEventListener('mousedown', (e) => {
    isDragging = true;
    startPos = isVertical ? e.clientY : e.clientX;
    startValue = currentValue;

    bridge.getParameter(paramId).then(v => {
      if (v !== undefined) startValue = v;
    }).catch(() => {});

    bridge.beginGesture(paramId).catch(() => {});
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const currentPos = isVertical ? e.clientY : e.clientX;
    const delta = isVertical ? startPos - currentPos : currentPos - startPos;
    const sensitivity = 0.005;
    let newValue = startValue + delta * sensitivity;
    newValue = Math.max(0, Math.min(1, newValue));
    currentValue = newValue;

    bridge.setParameter(paramId, newValue).catch(() => {});
    updateSliderVisual(sliderId, newValue);
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      bridge.endGesture(paramId).catch(() => {});
    }
  });

  slider.addEventListener('dblclick', () => {
    currentValue = defaultValue;
    bridge.setParameter(paramId, defaultValue).catch(() => {});
    updateSliderVisual(sliderId, defaultValue);
  });
}

/**
 * Setup range slider interaction with dual-thumb parameter binding
 * @param {string} rangeSliderId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding (stores min-max as two params)
 * @param {number} defaultMin - Default minimum normalized value (0-1)
 * @param {number} defaultMax - Default maximum normalized value (0-1)
 */
function setupRangeSliderInteraction(rangeSliderId, paramId, defaultMin = 0.25, defaultMax = 0.75) {
  const rangeSlider = document.getElementById(rangeSliderId);
  if (!rangeSlider) {
    console.error(`Range slider element not found: ${rangeSliderId}`);
    return;
  }

  let isDragging = false;
  let activeThumb = null; // 'min' or 'max'
  let startPos = 0;
  let startMinValue = defaultMin;
  let startMaxValue = defaultMax;
  let currentMinValue = defaultMin;
  let currentMaxValue = defaultMax;
  const isVertical = rangeSlider.classList.contains('vertical');

  const minThumb = rangeSlider.querySelector('.rangeslider-thumb-min');
  const maxThumb = rangeSlider.querySelector('.rangeslider-thumb-max');

  if (!minThumb || !maxThumb) {
    console.error(`Range slider thumbs not found for: ${rangeSliderId}`);
    return;
  }

  // Initialize visual
  updateRangeSliderVisual(rangeSliderId, defaultMin, defaultMax);

  const startDrag = (e, thumb) => {
    isDragging = true;
    activeThumb = thumb;
    startPos = isVertical ? e.clientY : e.clientX;
    startMinValue = currentMinValue;
    startMaxValue = currentMaxValue;

    const minParamId = `${paramId}_min`;
    const maxParamId = `${paramId}_max`;
    bridge.beginGesture(thumb === 'min' ? minParamId : maxParamId).catch(() => {});
    e.preventDefault();
  };

  minThumb.addEventListener('mousedown', (e) => startDrag(e, 'min'));
  maxThumb.addEventListener('mousedown', (e) => startDrag(e, 'max'));

  document.addEventListener('mousemove', (e) => {
    if (!isDragging || !activeThumb) return;

    const currentPos = isVertical ? e.clientY : e.clientX;
    const delta = isVertical ? startPos - currentPos : currentPos - startPos;
    const sensitivity = 0.005;

    if (activeThumb === 'min') {
      let newMin = startMinValue + delta * sensitivity;
      newMin = Math.max(0, Math.min(newMin, currentMaxValue)); // Cannot exceed max
      currentMinValue = newMin;
      
      const minParamId = `${paramId}_min`;
      bridge.setParameter(minParamId, newMin).catch(() => {});
    } else if (activeThumb === 'max') {
      let newMax = startMaxValue + delta * sensitivity;
      newMax = Math.min(1, Math.max(newMax, currentMinValue)); // Cannot go below min
      currentMaxValue = newMax;
      
      const maxParamId = `${paramId}_max`;
      bridge.setParameter(maxParamId, newMax).catch(() => {});
    }

    updateRangeSliderVisual(rangeSliderId, currentMinValue, currentMaxValue);
  });

  document.addEventListener('mouseup', () => {
    if (isDragging && activeThumb) {
      const minParamId = `${paramId}_min`;
      const maxParamId = `${paramId}_max`;
      bridge.endGesture(activeThumb === 'min' ? minParamId : maxParamId).catch(() => {});
      isDragging = false;
      activeThumb = null;
    }
  });

  // Double-click - reset to defaults
  rangeSlider.addEventListener('dblclick', () => {
    currentMinValue = defaultMin;
    currentMaxValue = defaultMax;
    const minParamId = `${paramId}_min`;
    const maxParamId = `${paramId}_max`;
    bridge.setParameter(minParamId, defaultMin).catch(() => {});
    bridge.setParameter(maxParamId, defaultMax).catch(() => {});
    updateRangeSliderVisual(rangeSliderId, defaultMin, defaultMax);
  });
}

/**
 * Setup button interaction with parameter binding
 * @param {string} buttonId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding
 */
function setupButtonInteraction(buttonId, paramId) {
  const button = document.getElementById(buttonId);
  if (!button) {
    console.error(\`Button element not found: \${buttonId}\`);
    return;
  }

  const isMomentary = button.dataset.mode === 'momentary';
  let isPressed = false;

  if (isMomentary) {
    // Momentary button - on while held
    button.addEventListener('mousedown', () => {
      isPressed = true;
      bridge.setParameter(paramId, 1.0).catch(() => {});
      button.classList.add('pressed');
    });

    document.addEventListener('mouseup', () => {
      if (isPressed) {
        isPressed = false;
        bridge.setParameter(paramId, 0.0).catch(() => {});
        button.classList.remove('pressed');
      }
    });
  } else {
    // Toggle button - click to toggle
    let toggleState = false;

    button.addEventListener('click', () => {
      toggleState = !toggleState;
      const newValue = toggleState ? 1.0 : 0.0;
      bridge.setParameter(paramId, newValue).catch(() => {});
      button.classList.toggle('pressed', toggleState);
    });
  }
}

// ============================================================================
// Visual Update Functions
// ============================================================================

/**
 * Update knob visual representation
 * @param {string} knobId - HTML element ID
 * @param {number} value - Normalized value (0-1)
 */
function updateKnobVisual(knobId, value) {
  const element = document.getElementById(knobId);
  if (!element) return;

  // Read angles from data attributes (set by HTML generator)
  const startAngle = parseFloat(element.dataset.startAngle) || -135;
  const endAngle = parseFloat(element.dataset.endAngle) || 135;

  // Get SVG dimensions from viewBox
  const svg = element.querySelector('svg');
  if (!svg) return;
  const viewBox = svg.getAttribute('viewBox');
  const [, , vbWidth] = viewBox ? viewBox.split(' ').map(Number) : [0, 0, 100];
  const diameter = vbWidth || 100;

  // Get track width from the track path stroke-width
  const trackPath = element.querySelector('.knob-arc-track');
  const trackWidth = trackPath ? parseFloat(trackPath.getAttribute('stroke-width')) || 4 : 4;

  // Calculate dimensions (same as HTML generator)
  const cx = diameter / 2;
  const cy = diameter / 2;
  const r = (diameter - trackWidth) / 2;

  // Calculate value angle
  const valueAngle = startAngle + (value * (endAngle - startAngle));

  // Update arc fill for arc-style knobs
  const arcFill = element.querySelector('.knob-arc-fill');
  if (arcFill) {
    if (value > 0.001) {
      // Use same describeArc logic as HTML generator (counterclockwise, swap start/end)
      const path = describeArcPath(cx, cy, r, startAngle, valueAngle);
      arcFill.setAttribute('d', path);
    } else {
      arcFill.setAttribute('d', '');
    }
  }

  // Update indicator position (for line/dot style knobs)
  const indicator = element.querySelector('.knob-indicator');
  if (indicator) {
    if (indicator.tagName === 'line') {
      // Line indicator - update endpoints
      const innerR = r * 0.4;
      const outerR = r * 0.9;
      const rad = (valueAngle - 90) * Math.PI / 180;
      indicator.setAttribute('x1', cx + innerR * Math.cos(rad));
      indicator.setAttribute('y1', cy + innerR * Math.sin(rad));
      indicator.setAttribute('x2', cx + outerR * Math.cos(rad));
      indicator.setAttribute('y2', cy + outerR * Math.sin(rad));
    } else if (indicator.tagName === 'circle') {
      // Dot indicator - update position
      const outerR = r * 0.9;
      const rad = (valueAngle - 90) * Math.PI / 180;
      indicator.setAttribute('cx', cx + outerR * Math.cos(rad));
      indicator.setAttribute('cy', cy + outerR * Math.sin(rad));
    }
  }

  // Update data attribute
  element.setAttribute('data-value', value);
}

/**
 * Calculate arc path (same algorithm as HTML generator)
 * Uses counterclockwise sweep, swaps start/end for proper direction
 */
function describeArcPath(cx, cy, r, startAngle, endAngle) {
  // Convert to radians, offset by -90 to make 0° = top
  const startRad = (endAngle - 90) * Math.PI / 180;
  const endRad = (startAngle - 90) * Math.PI / 180;

  // Calculate start and end points (note: swapped for counterclockwise)
  const x1 = cx + r * Math.cos(startRad);
  const y1 = cy + r * Math.sin(startRad);
  const x2 = cx + r * Math.cos(endRad);
  const y2 = cy + r * Math.sin(endRad);

  // Large arc flag: 1 if angle span > 180°
  const largeArc = Math.abs(endAngle - startAngle) > 180 ? 1 : 0;

  // Sweep flag 0 = counterclockwise (matches HTML generator)
  return \`M \${x1} \${y1} A \${r} \${r} 0 \${largeArc} 0 \${x2} \${y2}\`;
}

/**
 * Update slider visual representation
 * @param {string} sliderId - HTML element ID
 * @param {number} value - Normalized value (0-1)
 */
function updateSliderVisual(sliderId, value) {
  const element = document.getElementById(sliderId);
  if (!element) return;

  const isVertical = element.classList.contains('vertical');
  const thumb = element.querySelector('.slider-thumb');
  const fill = element.querySelector('.slider-fill');

  if (isVertical) {
    if (thumb) thumb.style.bottom = \`\${value * 100}%\`;
    if (fill) fill.style.height = \`\${value * 100}%\`;
  } else {
    if (thumb) thumb.style.left = \`\${value * 100}%\`;
    if (fill) fill.style.width = \`\${value * 100}%\`;
  }

  // Update data attribute
  element.setAttribute('data-value', value);
}

/**
 * Update range slider visual representation
 * @param {string} rangeSliderId - HTML element ID
 * @param {number} minValue - Normalized minimum value (0-1)
 * @param {number} maxValue - Normalized maximum value (0-1)
 */
function updateRangeSliderVisual(rangeSliderId, minValue, maxValue) {
  const element = document.getElementById(rangeSliderId);
  if (!element) return;

  const isVertical = element.classList.contains('vertical');
  const minThumb = element.querySelector('.rangeslider-thumb-min');
  const maxThumb = element.querySelector('.rangeslider-thumb-max');
  const fill = element.querySelector('.rangeslider-fill');

  if (isVertical) {
    if (minThumb) minThumb.style.bottom = `${minValue * 100}%`;
    if (maxThumb) maxThumb.style.bottom = `${maxValue * 100}%`;
    if (fill) {
      fill.style.bottom = `${minValue * 100}%`;
      fill.style.height = `${(maxValue - minValue) * 100}%`;
    }
  } else {
    if (minThumb) minThumb.style.left = `${minValue * 100}%`;
    if (maxThumb) maxThumb.style.left = `${maxValue * 100}%`;
    if (fill) {
      fill.style.left = `${minValue * 100}%`;
      fill.style.width = `${(maxValue - minValue) * 100}%`;
    }
  }

  // Update data attributes
  element.setAttribute('data-min-value', minValue);
  element.setAttribute('data-max-value', maxValue);
}

// ============================================================================
// Start Initialization
// ============================================================================

initializeJUCEBridge();
`
}

// ============================================================================
// Components Generator
// ============================================================================

/**
 * Generate components.js content
 * Creates UI update functions for elements
 *
 * @param elements - Array of element configurations
 * @returns JavaScript code as string
 *
 * @example
 * const componentsJS = generateComponentsJS(elements)
 * // Generates updateElementValue and updateElementPressed functions
 */
export function generateComponentsJS(_elements: ElementConfig[]): string {
  return `// ============================================================================
// UI Component Update Functions
// Generated by VST3 WebView UI Designer
// For JUCE->UI callbacks (parameter changes from C++ side)
// ============================================================================

/**
 * Store knob configuration for visual updates
 * Call this during initialization to set up knob config
 * @param {string} id - Element ID
 * @param {object} config - Knob configuration {startAngle, endAngle, ...}
 */
function initializeKnob(id, config) {
  const element = document.getElementById(id);
  if (!element) return;

  // CRITICAL: Store config for updateKnobVisual
  element._knobConfig = config;
}

/**
 * Store slider configuration for visual updates
 * @param {string} id - Element ID
 * @param {object} config - Slider configuration
 */
function initializeSlider(id, config) {
  const element = document.getElementById(id);
  if (!element) return;

  element._sliderConfig = config;
}

/**
 * Update element value display (knob, slider, meter)
 * Called by JUCE when parameter values change
 * @param {string} id - Element ID (kebab-case)
 * @param {number} value - Normalized value (0-1)
 */
function updateElementValue(id, value) {
  const element = document.getElementById(id);
  if (!element) {
    console.warn(\`Element not found: \${id}\`);
    return;
  }

  // Update data attribute for CSS/JS access
  element.setAttribute('data-value', value);

  // Type-specific updates - use ID-based functions for consistency
  if (element.classList.contains('knob')) {
    updateKnobVisualById(id, value);
  } else if (element.classList.contains('slider')) {
    updateSliderVisualById(id, value);
  } else if (element.classList.contains('meter')) {
    updateMeterVisualById(id, value);
  }
}

/**
 * Update button pressed state
 * Called by JUCE when button state changes
 * @param {string} id - Element ID (kebab-case)
 * @param {boolean} pressed - Whether button is pressed
 */
function updateElementPressed(id, pressed) {
  const element = document.getElementById(id);
  if (!element) {
    console.warn(\`Element not found: \${id}\`);
    return;
  }

  if (pressed) {
    element.classList.add('pressed');
  } else {
    element.classList.remove('pressed');
  }
}

// ============================================================================
// ID-Based Visual Update Helpers (use stored config)
// ============================================================================

function updateKnobVisualById(id, value) {
  const element = document.getElementById(id);
  if (!element) return;

  // Read angles from data attributes (set by HTML generator)
  const startAngle = parseFloat(element.dataset.startAngle) || -135;
  const endAngle = parseFloat(element.dataset.endAngle) || 135;

  // Get SVG dimensions from viewBox
  const svg = element.querySelector('svg');
  if (!svg) return;
  const viewBox = svg.getAttribute('viewBox');
  const [, , vbWidth] = viewBox ? viewBox.split(' ').map(Number) : [0, 0, 100];
  const diameter = vbWidth || 100;

  // Get track width from the track path stroke-width
  const trackPath = element.querySelector('.knob-arc-track');
  const trackWidth = trackPath ? parseFloat(trackPath.getAttribute('stroke-width')) || 4 : 4;

  // Calculate dimensions (same as HTML generator)
  const cx = diameter / 2;
  const cy = diameter / 2;
  const r = (diameter - trackWidth) / 2;

  // Calculate value angle
  const valueAngle = startAngle + (value * (endAngle - startAngle));

  // Update arc fill for arc-style knobs
  const arcFill = element.querySelector('.knob-arc-fill');
  if (arcFill) {
    if (value > 0.001) {
      // Use same describeArc logic as HTML generator (counterclockwise, swap start/end)
      const path = describeArcPathById(cx, cy, r, startAngle, valueAngle);
      arcFill.setAttribute('d', path);
    } else {
      arcFill.setAttribute('d', '');
    }
  }

  // Update indicator position (for line/dot style knobs)
  const indicator = element.querySelector('.knob-indicator');
  if (indicator) {
    if (indicator.tagName === 'line') {
      const innerR = r * 0.4;
      const outerR = r * 0.9;
      const rad = (valueAngle - 90) * Math.PI / 180;
      indicator.setAttribute('x1', cx + innerR * Math.cos(rad));
      indicator.setAttribute('y1', cy + innerR * Math.sin(rad));
      indicator.setAttribute('x2', cx + outerR * Math.cos(rad));
      indicator.setAttribute('y2', cy + outerR * Math.sin(rad));
    } else if (indicator.tagName === 'circle') {
      const outerR = r * 0.9;
      const rad = (valueAngle - 90) * Math.PI / 180;
      indicator.setAttribute('cx', cx + outerR * Math.cos(rad));
      indicator.setAttribute('cy', cy + outerR * Math.sin(rad));
    }
  }

  element.setAttribute('data-value', value);
}

function describeArcPathById(cx, cy, r, startAngle, endAngle) {
  const startRad = (endAngle - 90) * Math.PI / 180;
  const endRad = (startAngle - 90) * Math.PI / 180;
  const x1 = cx + r * Math.cos(startRad);
  const y1 = cy + r * Math.sin(startRad);
  const x2 = cx + r * Math.cos(endRad);
  const y2 = cy + r * Math.sin(endRad);
  const largeArc = Math.abs(endAngle - startAngle) > 180 ? 1 : 0;
  return \`M \${x1} \${y1} A \${r} \${r} 0 \${largeArc} 0 \${x2} \${y2}\`;
}

function updateSliderVisualById(id, value) {
  const element = document.getElementById(id);
  if (!element) return;

  const isVertical = element.classList.contains('vertical');
  const thumb = element.querySelector('.slider-thumb');
  const fill = element.querySelector('.slider-fill');

  if (isVertical) {
    if (thumb) thumb.style.bottom = \`\${value * 100}%\`;
    if (fill) fill.style.height = \`\${value * 100}%\`;
  } else {
    if (thumb) thumb.style.left = \`\${value * 100}%\`;
    if (fill) fill.style.width = \`\${value * 100}%\`;
  }

  element.setAttribute('data-value', value);
}

function updateMeterVisualById(id, value) {
  const element = document.getElementById(id);
  if (!element) return;

  const fill = element.querySelector('.meter-fill');
  const isVertical = element.classList.contains('vertical');

  if (isVertical) {
    if (fill) fill.style.height = \`\${value * 100}%\`;
  } else {
    if (fill) fill.style.width = \`\${value * 100}%\`;
  }

  element.setAttribute('data-value', value);
}
`
}

// ============================================================================
// Mock JUCE Backend Generator
// ============================================================================

/**
 * Generate mock JUCE backend for HTML preview mode
 * Allows standalone testing without JUCE runtime
 *
 * @returns JavaScript code as string
 *
 * @example
 * const mockJS = generateMockJUCE()
 * // Include in <script> tag for HTML preview
 */
export function generateMockJUCE(): string {
  return `// ============================================================================
// Mock JUCE Backend for Standalone Preview
// DO NOT include this in JUCE WebView2 plugin - only for HTML preview
// Implements the event-based native function pattern
// ============================================================================

if (typeof window.__JUCE__ === 'undefined') {
  console.log('[MockJUCE] Initializing mock JUCE backend (preview mode)');

  // Mock parameter storage
  const mockParameters = new Map();
  const eventListeners = new Map();

  window.__JUCE__ = {
    // Initialization data - includes registered functions
    initialisationData: {
      __juce__functions: ['setParameter', 'getParameter', 'beginGesture', 'endGesture']
    },

    backend: {
      /**
       * Emit event to JUCE backend (mock implementation)
       * Handles __juce__invoke events for native function calls
       */
      emitEvent: (eventName, data) => {
        if (eventName === '__juce__invoke') {
          const { name, params, resultId } = data;

          // Mock function implementations
          let result = undefined;

          switch (name) {
            case 'setParameter':
              const [paramId, value] = params;
              mockParameters.set(paramId, value);
              console.log(\`[MockJUCE] setParameter('\${paramId}', \${value})\`);
              result = true;
              break;

            case 'getParameter':
              result = mockParameters.get(params[0]) ?? 0.5;
              console.log(\`[MockJUCE] getParameter('\${params[0]}') -> \${result}\`);
              break;

            case 'beginGesture':
              console.log(\`[MockJUCE] beginGesture('\${params[0]}')\`);
              result = true;
              break;

            case 'endGesture':
              console.log(\`[MockJUCE] endGesture('\${params[0]}')\`);
              result = true;
              break;

            default:
              console.warn(\`[MockJUCE] Unknown function: \${name}\`);
          }

          // Dispatch completion event
          setTimeout(() => {
            const listeners = eventListeners.get('__juce__complete') || [];
            listeners.forEach(listener => {
              listener({ resultId, result });
            });
          }, 10);
        }
      },

      /**
       * Add event listener for JUCE events
       */
      addEventListener: (eventName, callback) => {
        if (!eventListeners.has(eventName)) {
          eventListeners.set(eventName, []);
        }
        eventListeners.get(eventName).push(callback);
      },

      /**
       * Remove event listener
       */
      removeEventListener: (eventName, callback) => {
        const listeners = eventListeners.get(eventName) || [];
        const index = listeners.indexOf(callback);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    }
  };

  // Add test controls for interactive preview
  window.addEventListener('DOMContentLoaded', () => {
    console.log('[MockJUCE] Mock JUCE backend ready');
    console.log('[MockJUCE] Available functions:', window.__JUCE__.initialisationData.__juce__functions);
  });
}
`
}
