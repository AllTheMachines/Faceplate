/**
 * JavaScript code generator for JUCE WebView2 bindings
 * Generates bindings.js, components.js, and mock JUCE backend
 */

import type { ElementConfig } from '../../types/elements'
import { toKebabCase } from './utils'

// ============================================================================
// Types
// ============================================================================

export interface JSGeneratorOptions {
  isPreviewMode: boolean // true = include mock, false = expect real JUCE
}

// ============================================================================
// Bindings Generator
// ============================================================================

/**
 * Generate bindings.js content
 * Creates JUCE event-based parameter bindings for interactive elements (knob, slider, button)
 *
 * JUCE native functions use an event-based invocation system:
 * - Functions registered with .withNativeFunction() in C++
 * - Available in window.__JUCE__.initialisationData.__juce__functions
 * - Invoked via window.__JUCE__.backend.emitEvent('__juce__invoke', ...)
 * - Results return via window.__JUCE__.backend.addEventListener('__juce__complete', ...)
 *
 * @param elements - Array of element configurations
 * @param options - Generation options (preview mode, etc.)
 * @returns JavaScript code as string
 *
 * @example
 * const bindingsJS = generateBindingsJS(elements, { isPreviewMode: false })
 * // Generates JUCEBridge module with event-based parameter bindings
 */
export function generateBindingsJS(
  elements: ElementConfig[],
  _options: JSGeneratorOptions
): string {
  // Filter elements with parameter bindings
  const knobs = elements.filter((el) => el.type === 'knob' && el.parameterId)
  const sliders = elements.filter((el) => el.type === 'slider' && el.parameterId)
  const buttons = elements.filter((el) => el.type === 'button' && el.parameterId)

  // Generate setup calls for each element type
  const knobSetups = knobs
    .map((knob) => `  setupKnobInteraction('${toKebabCase(knob.name)}', '${knob.parameterId}');`)
    .join('\n')

  const sliderSetups = sliders
    .map(
      (slider) => `  setupSliderInteraction('${toKebabCase(slider.name)}', '${slider.parameterId}');`
    )
    .join('\n')

  const buttonSetups = buttons
    .map(
      (button) =>
        `  setupButtonInteraction('${toKebabCase(button.name)}', '${button.parameterId}');`
    )
    .join('\n')

  return `// AUTO-GENERATED by vst3-webview-ui-designer
// JUCE WebView2 Event-Based Parameter Bindings

/**
 * JUCE Bridge Module - Event-based native function invocation
 *
 * JUCE native functions use an event system, not direct calls:
 * - Functions registered with .withNativeFunction() in C++
 * - Available in window.__JUCE__.initialisationData.__juce__functions
 * - Invoked via window.__JUCE__.backend.emitEvent('__juce__invoke', ...)
 * - Results return via window.__JUCE__.backend.addEventListener('__juce__complete', ...)
 */
const JUCEBridge = {
  isAvailable: false,
  functions: [],
  debugMode: false,

  /**
   * Initialize bridge - polls for JUCE availability
   */
  initialize() {
    const checkBridge = () => {
      if (window.__JUCE__?.backend && window.__JUCE__?.initialisationData) {
        this.isAvailable = true;
        this.functions = window.__JUCE__.initialisationData.__juce__functions || [];

        if (this.debugMode) {
          console.log('[JUCEBridge] Connected. Available functions:', this.functions);
        }

        return true;
      }
      return false;
    };

    // Try immediately
    if (checkBridge()) return;

    // Poll every 50ms for up to 2 seconds
    let attempts = 0;
    const interval = setInterval(() => {
      if (checkBridge() || ++attempts > 40) {
        clearInterval(interval);

        if (!this.isAvailable) {
          console.warn('[JUCEBridge] Not available - running in standalone mode');
        }
      }
    }, 50);
  },

  /**
   * Set parameter value (fire-and-forget for responsive UI)
   * @param {string} paramId - Parameter ID (matches APVTS)
   * @param {number} value - Normalized value (0-1)
   */
  setParameter(paramId, value) {
    if (!this.isAvailable) {
      if (this.debugMode) {
        console.log(\`[JUCEBridge] Mock setParameter(\${paramId}, \${value})\`);
      }
      return;
    }

    window.__JUCE__.backend.emitEvent('__juce__invoke', {
      name: 'setParameter',
      params: [paramId, value],
      resultId: Math.random()
    });
  },

  /**
   * Get parameter value (async with promise)
   * @param {string} paramId - Parameter ID
   * @returns {Promise<number>} Normalized value (0-1)
   */
  async getParameter(paramId) {
    if (!this.isAvailable) {
      if (this.debugMode) {
        console.log(\`[JUCEBridge] Mock getParameter(\${paramId}) -> 0.5\`);
      }
      return 0.5;
    }

    return new Promise((resolve) => {
      const resultId = Math.random();

      const listener = (event) => {
        if (event.promiseId === resultId) {
          window.__JUCE__.backend.removeEventListener('__juce__complete', listener);
          resolve(event.result);
        }
      };

      window.__JUCE__.backend.addEventListener('__juce__complete', listener);

      window.__JUCE__.backend.emitEvent('__juce__invoke', {
        name: 'getParameter',
        params: [paramId],
        resultId: resultId
      });

      // Timeout after 1 second
      setTimeout(() => {
        window.__JUCE__.backend.removeEventListener('__juce__complete', listener);
        resolve(0.5);
      }, 1000);
    });
  },

  /**
   * Begin automation gesture (for DAW automation recording)
   * @param {string} paramId - Parameter ID
   */
  beginGesture(paramId) {
    if (!this.isAvailable) return;

    window.__JUCE__.backend.emitEvent('__juce__invoke', {
      name: 'beginGesture',
      params: [paramId],
      resultId: Math.random()
    });
  },

  /**
   * End automation gesture
   * @param {string} paramId - Parameter ID
   */
  endGesture(paramId) {
    if (!this.isAvailable) return;

    window.__JUCE__.backend.emitEvent('__juce__invoke', {
      name: 'endGesture',
      params: [paramId],
      resultId: Math.random()
    });
  }
};

/**
 * Setup knob interaction with parameter binding
 * @param {string} knobId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding
 */
function setupKnobInteraction(knobId, paramId) {
  const knob = document.getElementById(knobId);
  if (!knob) {
    console.error(\`Knob element not found: \${knobId}\`);
    return;
  }

  let isDragging = false;
  let startY = 0;
  let startValue = 0;

  // Mousedown - start drag
  knob.addEventListener('mousedown', async (e) => {
    isDragging = true;
    startY = e.clientY;
    startValue = await JUCEBridge.getParameter(paramId);

    // Begin automation gesture for DAW recording
    JUCEBridge.beginGesture(paramId);

    e.preventDefault();
    e.stopPropagation();
  });

  // Mousemove - drag to update value
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const deltaY = startY - e.clientY;  // Inverted (up = increase)
    const sensitivity = 0.005;
    const newValue = Math.max(0, Math.min(1, startValue + deltaY * sensitivity));

    // Fire-and-forget parameter update (instant, no blocking)
    JUCEBridge.setParameter(paramId, newValue);

    // Update visual immediately
    updateKnobVisual(knobId, newValue);
  });

  // Mouseup - end drag
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      JUCEBridge.endGesture(paramId);
      isDragging = false;
    }
  });

  // Double-click - reset to default
  knob.addEventListener('dblclick', async () => {
    // Get default value from element data attribute or use 0.5
    const defaultValue = parseFloat(knob.dataset.default || '0.5');
    JUCEBridge.setParameter(paramId, defaultValue);
    updateKnobVisual(knobId, defaultValue);
  });
}

/**
 * Setup slider interaction with parameter binding
 * @param {string} sliderId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding
 */
function setupSliderInteraction(sliderId, paramId) {
  const slider = document.getElementById(sliderId);
  if (!slider) {
    console.error(\`Slider element not found: \${sliderId}\`);
    return;
  }

  let isDragging = false;
  let startPos = 0;
  let startValue = 0;
  const isVertical = slider.classList.contains('vertical');

  slider.addEventListener('mousedown', async (e) => {
    isDragging = true;
    startPos = isVertical ? e.clientY : e.clientX;
    startValue = await JUCEBridge.getParameter(paramId);

    JUCEBridge.beginGesture(paramId);
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const currentPos = isVertical ? e.clientY : e.clientX;
    const delta = isVertical ? startPos - currentPos : currentPos - startPos;
    const sensitivity = 0.005;
    const newValue = Math.max(0, Math.min(1, startValue + delta * sensitivity));

    JUCEBridge.setParameter(paramId, newValue);
    updateSliderVisual(sliderId, newValue);
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      JUCEBridge.endGesture(paramId);
      isDragging = false;
    }
  });

  slider.addEventListener('dblclick', () => {
    const defaultValue = parseFloat(slider.dataset.default || '0.5');
    JUCEBridge.setParameter(paramId, defaultValue);
    updateSliderVisual(sliderId, defaultValue);
  });
}

/**
 * Setup button interaction with parameter binding
 * @param {string} buttonId - HTML element ID
 * @param {string} paramId - Parameter ID for JUCE binding
 */
function setupButtonInteraction(buttonId, paramId) {
  const button = document.getElementById(buttonId);
  if (!button) {
    console.error(\`Button element not found: \${buttonId}\`);
    return;
  }

  const isMomentary = button.dataset.mode === 'momentary';
  let isPressed = false;

  if (isMomentary) {
    // Momentary button - on while held
    button.addEventListener('mousedown', () => {
      isPressed = true;
      JUCEBridge.setParameter(paramId, 1.0);
      button.classList.add('pressed');
    });

    document.addEventListener('mouseup', () => {
      if (isPressed) {
        isPressed = false;
        JUCEBridge.setParameter(paramId, 0.0);
        button.classList.remove('pressed');
      }
    });
  } else {
    // Toggle button - click to toggle
    button.addEventListener('click', async () => {
      const currentValue = await JUCEBridge.getParameter(paramId);
      const newValue = currentValue > 0.5 ? 0.0 : 1.0;

      JUCEBridge.setParameter(paramId, newValue);
      button.classList.toggle('pressed', newValue > 0.5);
    });
  }
}

// Initialize JUCE bridge
JUCEBridge.initialize();

// Initialize all UI elements when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  console.log('[Bindings] Initializing UI elements...');

  // Wait briefly for JUCE bridge
  await new Promise(resolve => setTimeout(resolve, 100));

  if (!JUCEBridge.isAvailable) {
    console.warn('[Bindings] JUCE bridge not available - standalone mode');
    const statusEl = document.getElementById('status');
    if (statusEl) {
      statusEl.textContent = 'Standalone Mode';
      statusEl.style.color = '#f59e0b';
    }
  } else {
    const statusEl = document.getElementById('status');
    if (statusEl) {
      statusEl.textContent = 'Connected';
      statusEl.style.color = '#10b981';
    }
  }

  // Initialize knobs
${knobSetups || '  // No knobs with parameter bindings'}

  // Initialize sliders
${sliderSetups || '  // No sliders with parameter bindings'}

  // Initialize buttons
${buttonSetups || '  // No buttons with parameter bindings'}

  console.log('[Bindings] Initialization complete');
});
`
}

// ============================================================================
// Components Generator
// ============================================================================

/**
 * Generate components.js content
 * Creates UI update functions for elements
 *
 * @param elements - Array of element configurations
 * @returns JavaScript code as string
 *
 * @example
 * const componentsJS = generateComponentsJS(elements)
 * // Generates updateElementValue and updateElementPressed functions
 */
export function generateComponentsJS(_elements: ElementConfig[]): string {
  return `// ============================================================================
// UI Component Update Functions
// Generated by VST3 WebView UI Designer
// ============================================================================

/**
 * Update element value display (knob, slider, meter)
 * @param {string} id - Element ID (kebab-case)
 * @param {number} value - Normalized value (0-1)
 */
function updateElementValue(id, value) {
  const element = document.getElementById(id);
  if (!element) {
    console.warn(\`Element not found: \${id}\`);
    return;
  }

  // Update data attribute for CSS/JS access
  element.setAttribute('data-value', value);

  // Type-specific updates
  if (element.classList.contains('knob')) {
    updateKnobVisual(element, value);
  } else if (element.classList.contains('slider')) {
    updateSliderVisual(element, value);
  } else if (element.classList.contains('meter')) {
    updateMeterVisual(element, value);
  }
}

/**
 * Update button pressed state
 * @param {string} id - Element ID (kebab-case)
 * @param {boolean} pressed - Whether button is pressed
 */
function updateElementPressed(id, pressed) {
  const element = document.getElementById(id);
  if (!element) {
    console.warn(\`Element not found: \${id}\`);
    return;
  }

  // Update pressed state
  if (pressed) {
    element.classList.add('pressed');
  } else {
    element.classList.remove('pressed');
  }
}

// ============================================================================
// Type-Specific Visual Update Helpers
// ============================================================================

function updateKnobVisual(element, value) {
  // Update rotation or arc fill based on knob style
  // Implementation depends on exported HTML structure
  const indicator = element.querySelector('.knob-indicator');
  if (indicator) {
    const angle = -135 + (270 * value); // -135° to +135°
    indicator.style.transform = \`rotate(\${angle}deg)\`;
  }
}

function updateSliderVisual(element, value) {
  // Update thumb position and track fill
  const thumb = element.querySelector('.slider-thumb');
  const fill = element.querySelector('.slider-fill');

  if (element.classList.contains('vertical')) {
    if (thumb) thumb.style.bottom = \`\${value * 100}%\`;
    if (fill) fill.style.height = \`\${value * 100}%\`;
  } else {
    if (thumb) thumb.style.left = \`\${value * 100}%\`;
    if (fill) fill.style.width = \`\${value * 100}%\`;
  }
}

function updateMeterVisual(element, value) {
  // Update meter fill level
  const fill = element.querySelector('.meter-fill');

  if (element.classList.contains('vertical')) {
    if (fill) fill.style.height = \`\${value * 100}%\`;
  } else {
    if (fill) fill.style.width = \`\${value * 100}%\`;
  }
}
`
}

// ============================================================================
// Mock JUCE Backend Generator
// ============================================================================

/**
 * Generate mock JUCE backend for HTML preview mode
 * Allows standalone testing without JUCE runtime
 *
 * @returns JavaScript code as string
 *
 * @example
 * const mockJS = generateMockJUCE()
 * // Include in <script> tag for HTML preview
 */
export function generateMockJUCE(): string {
  return `// ============================================================================
// Mock JUCE Backend for Standalone Preview
// DO NOT include this in JUCE WebView2 plugin - only for HTML preview
// ============================================================================

if (typeof window.__JUCE__ === 'undefined') {
  console.log('Mock JUCE backend initialized (preview mode)');

  window.__JUCE__ = window.__JUCE__ || {};
  window.__JUCE__.backend = {
    /**
     * Get slider state (for knobs and sliders)
     * @param {string} id - Element ID
     * @returns Mock slider state object
     */
    getSliderState: (id) => {
      let value = 0.5; // Default to center
      const listeners = [];

      return {
        getNormalisedValue: () => value,
        setNormalisedValue: (v) => {
          value = Math.max(0, Math.min(1, v)); // Clamp 0-1
          listeners.forEach(listener => listener());
        },
        valueChangedEvent: {
          addListener: (fn) => listeners.push(fn)
        }
      };
    },

    /**
     * Get toggle button state
     * @param {string} id - Element ID
     * @returns Mock toggle state object
     */
    getToggleState: (id) => {
      let toggled = false;
      const listeners = [];

      return {
        getToggleState: () => toggled,
        setToggleState: (v) => {
          toggled = Boolean(v);
          listeners.forEach(listener => listener());
        },
        addListener: (fn) => listeners.push(fn)
      };
    }
  };

  // Add test controls for interactive preview
  window.addEventListener('DOMContentLoaded', () => {
    console.log('Mock JUCE backend ready - use console to test:');
    console.log('  window.__JUCE__.backend.getSliderState("element-id").setNormalisedValue(0.75)');
    console.log('  window.__JUCE__.backend.getToggleState("button-id").setToggleState(true)');
  });
}
`
}
