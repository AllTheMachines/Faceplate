---
phase: 25-real-time-visualizations
plan: 05
type: execute
wave: 4
depends_on: ["25-04"]
files_modified:
  - src/services/export/cssGenerator.ts
  - src/services/export/htmlGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Exported CSS includes Canvas container styles for all 5 visualization types"
    - "Exported HTML includes Canvas elements with data attributes for JUCE"
    - "Exported JavaScript includes draw functions for JUCE to call"
  artifacts:
    - path: "src/services/export/cssGenerator.ts"
      provides: "CSS generation for visualization Canvas containers"
      contains: "scrollingwaveform"
    - path: "src/services/export/htmlGenerator.ts"
      provides: "HTML generation for Canvas elements with JavaScript draw functions"
      contains: "scrollingwaveform"
  key_links:
    - from: "src/services/export/htmlGenerator.ts"
      to: "JUCE WebView2"
      via: "data attributes and JavaScript functions"
      pattern: "data-viz-type"
---

<objective>
Add export support for all 5 visualization element types to work in JUCE WebView2.

Purpose: Canvas visualizations export as HTML Canvas elements with JavaScript draw functions that JUCE can invoke with real audio data.

Output: CSS and HTML/JS generation for JUCE-compatible Canvas visualizations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/25-real-time-visualizations/25-CONTEXT.md
@.planning/phases/25-real-time-visualizations/25-RESEARCH.md
@.planning/phases/25-real-time-visualizations/25-04-SUMMARY.md
@.planning/phases/23-professional-meters/23-06-SUMMARY.md
@src/services/export/cssGenerator.ts
@src/services/export/htmlGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CSS generation for visualization containers</name>
  <files>src/services/export/cssGenerator.ts</files>
  <action>
Update `src/services/export/cssGenerator.ts` to handle visualization types.

Add helper function for visualization CSS:
```typescript
function generateVisualizationCSS(
  config: ScrollingWaveformElementConfig | SpectrumAnalyzerElementConfig | SpectrogramElementConfig | GoniometerElementConfig | VectorscopeElementConfig
): string {
  const id = toKebabCase(config.id)

  return `/* ${config.name || config.type} */
#${id} {
  position: absolute;
  left: ${config.x}px;
  top: ${config.y}px;
  width: ${config.width}px;
  height: ${config.height}px;
  background-color: ${config.backgroundColor};
  overflow: hidden;
}

#${id} canvas {
  display: block;
  width: 100%;
  height: 100%;
}
`
}
```

Add switch cases for each visualization type in the main generateElementCSS function:
```typescript
case 'scrollingwaveform':
case 'spectrumanalyzer':
case 'spectrogram':
case 'goniometer':
case 'vectorscope':
  return generateVisualizationCSS(element as ScrollingWaveformElementConfig)
```

Import the visualization types at the top of the file.
  </action>
  <verify>`grep "scrollingwaveform" src/services/export/cssGenerator.ts` shows case statement</verify>
  <done>CSS generator handles all 5 visualization types with container styles</done>
</task>

<task type="auto">
  <name>Task 2: Add HTML generation with JavaScript draw functions</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Update `src/services/export/htmlGenerator.ts` to handle visualization types.

Add helper function for visualization HTML with embedded JavaScript:
```typescript
function generateScrollingWaveformHTML(config: ScrollingWaveformElementConfig): string {
  const id = toKebabCase(config.id)
  return `<div id="${id}" class="viz-container" data-viz-type="scrollingwaveform">
  <canvas id="${id}-canvas"></canvas>
</div>
<script>
(function() {
  const canvas = document.getElementById('${id}-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  // HiDPI setup
  canvas.width = ${config.width} * dpr;
  canvas.height = ${config.height} * dpr;
  canvas.style.width = '${config.width}px';
  canvas.style.height = '${config.height}px';
  ctx.scale(dpr, dpr);

  // Draw function called by JUCE with waveform data
  window.updateWaveform_${id.replace(/-/g, '_')} = function(waveformData) {
    const width = ${config.width};
    const height = ${config.height};

    // Clear
    ctx.fillStyle = '${config.backgroundColor}';
    ctx.fillRect(0, 0, width, height);

    ${config.showGrid ? `
    // Grid
    ctx.strokeStyle = '${config.gridColor}';
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();
    ctx.globalAlpha = 1.0;
    ` : ''}

    // Waveform
    ctx.strokeStyle = '${config.waveformColor}';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < waveformData.length; i++) {
      const x = (i / waveformData.length) * width;
      const y = (height / 2) - (waveformData[i] * height * 0.4);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ${config.displayMode === 'fill' ? `
    ctx.lineTo(width, height / 2);
    ctx.closePath();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = '${config.waveformColor}';
    ctx.fill();
    ctx.globalAlpha = 1.0;
    ` : 'ctx.stroke();'}
  };

  // Register with JUCE
  if (window.__JUCE__) {
    window.__JUCE__.backend.addEventListener('waveform_${id}', (e) => {
      window.updateWaveform_${id.replace(/-/g, '_')}(e.data);
    });
  }
})();
</script>`
}

function generateSpectrumAnalyzerHTML(config: SpectrumAnalyzerElementConfig): string {
  const id = toKebabCase(config.id)
  return `<div id="${id}" class="viz-container" data-viz-type="spectrumanalyzer" data-fft-size="${config.fftSize}">
  <canvas id="${id}-canvas"></canvas>
</div>
<script>
(function() {
  const canvas = document.getElementById('${id}-canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  canvas.width = ${config.width} * dpr;
  canvas.height = ${config.height} * dpr;
  canvas.style.width = '${config.width}px';
  canvas.style.height = '${config.height}px';
  ctx.scale(dpr, dpr);

  window.updateSpectrum_${id.replace(/-/g, '_')} = function(frequencyData) {
    const width = ${config.width};
    const height = ${config.height};
    const barCount = frequencyData.length;
    const barWidth = width / barCount;
    const gapWidth = ${config.barGap};

    ctx.fillStyle = '${config.backgroundColor}';
    ctx.fillRect(0, 0, width, height);

    for (let i = 0; i < barCount; i++) {
      const magnitude = frequencyData[i];
      const x = i * barWidth;
      const barHeight = magnitude * height * 0.9;
      const y = height - barHeight;

      // Color gradient
      const hue = (1 - magnitude) * 240;
      ctx.fillStyle = \`hsl(\${hue}, 100%, \${40 + magnitude * 20}%)\`;
      ctx.fillRect(x + gapWidth / 2, y, barWidth - gapWidth, barHeight);
    }
  };

  if (window.__JUCE__) {
    window.__JUCE__.backend.addEventListener('fftData_${id}', (e) => {
      window.updateSpectrum_${id.replace(/-/g, '_')}(e.data);
    });
  }
})();
</script>`
}
```

Create similar functions for Spectrogram, Goniometer, and Vectorscope:

**generateSpectrogramHTML**: Creates updateSpectrogram function that shifts pixel buffer and draws new line

**generateGoniometerHTML**: Creates updateGoniometer function that draws L/R correlation points in circular display

**generateVectorscopeHTML**: Creates updateVectorscope function that draws Lissajous points

Add switch cases in main generateElementHTML function:
```typescript
case 'scrollingwaveform':
  return generateScrollingWaveformHTML(element as ScrollingWaveformElementConfig)
case 'spectrumanalyzer':
  return generateSpectrumAnalyzerHTML(element as SpectrumAnalyzerElementConfig)
case 'spectrogram':
  return generateSpectrogramHTML(element as SpectrogramElementConfig)
case 'goniometer':
  return generateGoniometerHTML(element as GoniometerElementConfig)
case 'vectorscope':
  return generateVectorscopeHTML(element as VectorscopeElementConfig)
```

Each export includes:
1. Canvas container div with data-viz-type attribute
2. Canvas element with unique ID
3. Inline script with HiDPI setup
4. Named update function (updateWaveform_xxx, updateSpectrum_xxx, etc.)
5. JUCE event listener registration for real-time data
  </action>
  <verify>`grep "updateSpectrum" src/services/export/htmlGenerator.ts` shows function generation</verify>
  <done>HTML generator produces Canvas elements with JavaScript draw functions for JUCE integration</done>
</task>

<task type="auto">
  <name>Task 3: Verify export integration</name>
  <files>src/services/export/cssGenerator.ts, src/services/export/htmlGenerator.ts</files>
  <action>
Ensure exports are complete:

1. Verify CSS generator imports visualization types from types/elements
2. Verify HTML generator imports visualization types from types/elements
3. Check that all 5 types have switch cases in both generators
4. Ensure JUCE event names follow consistent pattern: `{dataType}_{elementId}`
   - waveform_{id} for ScrollingWaveform
   - fftData_{id} for SpectrumAnalyzer
   - spectrogramData_{id} for Spectrogram
   - stereoData_{id} for Goniometer
   - stereoData_{id} for Vectorscope

Run TypeScript compilation to verify no type errors:
```bash
npx tsc --noEmit
```

Test by examining generated output structure (no runtime test needed - visual verification in browser).
  </action>
  <verify>`npx tsc --noEmit` passes without errors</verify>
  <done>Export generators handle all 5 visualization types with JUCE-compatible output</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. CSS generator produces container styles for all 5 types
3. HTML generator produces Canvas with JavaScript draw functions
4. Each visualization type has unique update function name
5. JUCE event listeners registered with consistent naming
6. HiDPI scaling included in exported JavaScript
</verification>

<success_criteria>
- TypeScript compiles successfully
- Scrolling Waveform exports with updateWaveform function
- Spectrum Analyzer exports with updateSpectrum function
- Spectrogram exports with updateSpectrogram function
- Goniometer exports with updateGoniometer function
- Vectorscope exports with updateVectorscope function
- All exports include HiDPI scaling (devicePixelRatio)
- All exports register with window.__JUCE__.backend
- Grid/axis overlays respect config in exported JavaScript
</success_criteria>

<output>
After completion, create `.planning/phases/25-real-time-visualizations/25-05-SUMMARY.md`
</output>
