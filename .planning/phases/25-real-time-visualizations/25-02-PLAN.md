---
phase: 25-real-time-visualizations
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/index.ts
  - src/components/elements/renderers/displays/index.ts
  - src/components/elements/renderers/index.ts
autonomous: true

must_haves:
  truths:
    - "Scrolling Waveform renders with static waveform data on Canvas"
    - "Spectrum Analyzer renders with pink noise spectrum bars on Canvas"
    - "Both visualizations handle HiDPI displays correctly"
  artifacts:
    - path: "src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx"
      provides: "Canvas-based scrolling waveform visualization"
      exports: ["ScrollingWaveformRenderer"]
    - path: "src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx"
      provides: "Canvas-based spectrum analyzer visualization"
      exports: ["SpectrumAnalyzerRenderer"]
    - path: "src/components/elements/renderers/index.ts"
      provides: "Registry entries for waveform and spectrum renderers"
      contains: "scrollingwaveform"
  key_links:
    - from: "src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx"
      to: "src/utils/mockAudioData.ts"
      via: "import generateWaveformData"
      pattern: "generateWaveformData"
    - from: "src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx"
      to: "src/utils/mockAudioData.ts"
      via: "import generatePinkNoiseSpectrum"
      pattern: "generatePinkNoiseSpectrum"
---

<objective>
Create Canvas-based renderers for Scrolling Waveform and Spectrum Analyzer visualizations.

Purpose: Implement first 2 visualization types with static mock data rendering per CONTEXT.md decisions.

Output: Two working renderers registered in the renderer registry.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/25-real-time-visualizations/25-CONTEXT.md
@.planning/phases/25-real-time-visualizations/25-RESEARCH.md
@.planning/phases/25-real-time-visualizations/25-01-SUMMARY.md
@src/components/elements/renderers/displays/WaveformRenderer.tsx
@src/components/elements/renderers/index.ts
@src/utils/mockAudioData.ts
@src/hooks/useCanvasSetup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScrollingWaveformRenderer</name>
  <files>src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx</files>
  <action>
Create `src/components/elements/renderers/displays/visualizations/` directory and `ScrollingWaveformRenderer.tsx`:

Import:
- React, useLayoutEffect, useRef, useMemo
- ScrollingWaveformElementConfig from types
- generateWaveformData from mockAudioData
- useCanvasSetup from hooks

**ScrollingWaveformRenderer({ config }: { config: ScrollingWaveformElementConfig })**

Implementation:
1. Use useCanvasSetup hook for canvas ref and HiDPI setup
2. Generate static waveform data with useMemo (frozen snapshot per CONTEXT.md)
3. useLayoutEffect to draw once (NOT animated per CONTEXT.md)

Drawing logic:
```typescript
// Clear canvas
ctx.fillStyle = config.backgroundColor
ctx.fillRect(0, 0, config.width, config.height)

// Draw grid if enabled
if (config.showGrid) {
  ctx.strokeStyle = config.gridColor
  ctx.lineWidth = 0.5
  ctx.globalAlpha = 0.3
  // Horizontal center line
  ctx.beginPath()
  ctx.moveTo(0, config.height / 2)
  ctx.lineTo(config.width, config.height / 2)
  ctx.stroke()
  // Vertical divisions (every 25%)
  for (let i = 0.25; i < 1; i += 0.25) {
    ctx.beginPath()
    ctx.moveTo(config.width * i, 0)
    ctx.lineTo(config.width * i, config.height)
    ctx.stroke()
  }
  ctx.globalAlpha = 1.0
}

// Draw waveform
const waveformData = generateWaveformData(config.width)
ctx.strokeStyle = config.waveformColor
ctx.fillStyle = config.waveformColor
ctx.lineWidth = 2

if (config.displayMode === 'fill') {
  // Fill mode: fill area between waveform and center
  ctx.beginPath()
  ctx.moveTo(0, config.height / 2)
  waveformData.forEach((sample, i) => {
    const x = i
    const y = (config.height / 2) - (sample * config.height * 0.4)
    ctx.lineTo(x, y)
  })
  ctx.lineTo(config.width, config.height / 2)
  ctx.closePath()
  ctx.globalAlpha = 0.5
  ctx.fill()
  ctx.globalAlpha = 1.0
} else {
  // Line mode: stroke path
  ctx.beginPath()
  waveformData.forEach((sample, i) => {
    const x = i
    const y = (config.height / 2) - (sample * config.height * 0.4)
    if (i === 0) ctx.moveTo(x, y)
    else ctx.lineTo(x, y)
  })
  ctx.stroke()
}
```

Return canvas element with proper styling:
```tsx
<canvas
  ref={canvasRef}
  style={{
    position: 'absolute',
    top: 0,
    left: 0,
    pointerEvents: 'none',
  }}
/>
```
  </action>
  <verify>File exists and exports component: `grep "export function ScrollingWaveformRenderer" src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx`</verify>
  <done>ScrollingWaveformRenderer created with Canvas drawing, line/fill modes, and grid overlay</done>
</task>

<task type="auto">
  <name>Task 2: Create SpectrumAnalyzerRenderer</name>
  <files>src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx</files>
  <action>
Create `SpectrumAnalyzerRenderer.tsx` in the visualizations folder:

Import:
- React, useLayoutEffect, useRef, useMemo
- SpectrumAnalyzerElementConfig from types
- generatePinkNoiseSpectrum, magnitudeToColor from mockAudioData
- useCanvasSetup from hooks

**SpectrumAnalyzerRenderer({ config }: { config: SpectrumAnalyzerElementConfig })**

Implementation:
1. Use useCanvasSetup hook for canvas ref and HiDPI setup
2. Generate static pink noise spectrum with useMemo (64 bars default)
3. useLayoutEffect to draw once (static per CONTEXT.md)

Drawing logic:
```typescript
const barCount = 64 // Fixed for mock display
const spectrum = useMemo(() => generatePinkNoiseSpectrum(barCount), [])

// Clear canvas
ctx.fillStyle = config.backgroundColor
ctx.fillRect(0, 0, config.width, config.height)

// Draw grid if enabled
if (config.showGrid) {
  ctx.strokeStyle = config.gridColor
  ctx.lineWidth = 0.5
  ctx.globalAlpha = 0.3
  // Horizontal dB lines (every -10dB)
  for (let i = 0; i < 5; i++) {
    const y = (i / 4) * config.height
    ctx.beginPath()
    ctx.moveTo(0, y)
    ctx.lineTo(config.width, y)
    ctx.stroke()
  }
  // Vertical frequency divisions (log-ish spacing)
  for (let i = 0.125; i < 1; i *= 2) {
    const x = i * config.width
    ctx.beginPath()
    ctx.moveTo(x, 0)
    ctx.lineTo(x, config.height)
    ctx.stroke()
  }
  ctx.globalAlpha = 1.0
}

// Draw spectrum bars
const barWidth = config.width / barCount
const gapWidth = config.barGap || 1

spectrum.forEach((magnitude, i) => {
  const x = i * barWidth
  const barHeight = magnitude * config.height * 0.9 // 10% margin
  const y = config.height - barHeight

  // Get color from gradient
  const color = magnitudeToColor(magnitude, config.colorGradient)
  ctx.fillStyle = color
  ctx.fillRect(
    x + gapWidth / 2,
    y,
    barWidth - gapWidth,
    barHeight
  )
})

// Draw frequency labels if enabled
if (config.showFrequencyLabels) {
  ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
  ctx.font = '10px monospace'
  ctx.textAlign = 'center'
  const freqLabels = ['20', '100', '1k', '10k', '20k']
  freqLabels.forEach((label, i) => {
    const x = ((i + 0.5) / freqLabels.length) * config.width
    ctx.fillText(label, x, config.height - 4)
  })
}

// Draw dB scale if enabled
if (config.showDbScale) {
  ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
  ctx.font = '10px monospace'
  ctx.textAlign = 'right'
  const dbLabels = ['0', '-10', '-20', '-30', '-40']
  dbLabels.forEach((label, i) => {
    const y = (i / (dbLabels.length - 1)) * config.height + 10
    ctx.fillText(label, 30, y)
  })
}
```

Return canvas element with proper styling.
  </action>
  <verify>File exists and exports component: `grep "export function SpectrumAnalyzerRenderer" src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx`</verify>
  <done>SpectrumAnalyzerRenderer created with pink noise spectrum, bar gap, grid, and scale overlays</done>
</task>

<task type="auto">
  <name>Task 3: Register renderers in registry</name>
  <files>src/components/elements/renderers/displays/visualizations/index.ts, src/components/elements/renderers/displays/index.ts, src/components/elements/renderers/index.ts</files>
  <action>
Create barrel export in `src/components/elements/renderers/displays/visualizations/index.ts`:
```typescript
export { ScrollingWaveformRenderer } from './ScrollingWaveformRenderer'
export { SpectrumAnalyzerRenderer } from './SpectrumAnalyzerRenderer'
```

Update `src/components/elements/renderers/displays/index.ts`:
- Add import for visualization renderers from './visualizations'
- Re-export ScrollingWaveformRenderer and SpectrumAnalyzerRenderer

Update `src/components/elements/renderers/index.ts`:
- Import ScrollingWaveformRenderer and SpectrumAnalyzerRenderer from displays
- Add to rendererRegistry Map:
  ```typescript
  ['scrollingwaveform', ScrollingWaveformRenderer as RendererComponent],
  ['spectrumanalyzer', SpectrumAnalyzerRenderer as RendererComponent],
  ```
- Add to re-exports at bottom of file
  </action>
  <verify>`grep "scrollingwaveform" src/components/elements/renderers/index.ts` shows registry entry</verify>
  <done>Both renderers registered in rendererRegistry for O(1) lookup</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. Scrolling Waveform renderer uses generateWaveformData for static display
3. Spectrum Analyzer renderer uses generatePinkNoiseSpectrum for static display
4. Both renderers registered in rendererRegistry
5. Grid, labels, and scale overlays respect config toggles
</verification>

<success_criteria>
- TypeScript compiles successfully
- ScrollingWaveformRenderer draws waveform on Canvas (line or fill mode)
- SpectrumAnalyzerRenderer draws spectrum bars with color gradient
- Both handle showGrid, showFrequencyLabels, showDbScale config
- Both use useLayoutEffect (not useEffect) per RESEARCH.md
- Renderers registered and can be looked up by type
</success_criteria>

<output>
After completion, create `.planning/phases/25-real-time-visualizations/25-02-SUMMARY.md`
</output>
