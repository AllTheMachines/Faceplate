---
phase: 25-real-time-visualizations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements/visualizations.ts
  - src/types/elements/index.ts
  - src/utils/mockAudioData.ts
  - src/hooks/useCanvasSetup.ts
autonomous: true

must_haves:
  truths:
    - "Visualization element types exist with configurable properties"
    - "Mock data utilities generate realistic audio patterns"
    - "Canvas setup hook handles HiDPI scaling correctly"
  artifacts:
    - path: "src/types/elements/visualizations.ts"
      provides: "5 visualization type interfaces + factory functions"
      exports: ["ScrollingWaveformElementConfig", "SpectrumAnalyzerElementConfig", "SpectrogramElementConfig", "GoniometerElementConfig", "VectorscopeElementConfig"]
    - path: "src/utils/mockAudioData.ts"
      provides: "Mock data generation for all visualization types"
      exports: ["generatePinkNoiseSpectrum", "generateWaveformData", "generateSpectrogramFrame", "generateMonoSignal"]
    - path: "src/hooks/useCanvasSetup.ts"
      provides: "Canvas HiDPI setup and context management"
      exports: ["useCanvasSetup"]
  key_links:
    - from: "src/types/elements/visualizations.ts"
      to: "src/types/elements/index.ts"
      via: "export union type"
      pattern: "VisualizationElement"
---

<objective>
Create TypeScript types, mock data utilities, and Canvas setup hook for 5 real-time visualization elements.

Purpose: Establish foundation for Canvas-based audio visualizations with proper HiDPI support and realistic mock data patterns per CONTEXT.md decisions.

Output: Type definitions, mock data generators, and reusable Canvas hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-real-time-visualizations/25-CONTEXT.md
@.planning/phases/25-real-time-visualizations/25-RESEARCH.md
@src/types/elements/displays.ts
@src/types/elements/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create visualization element types</name>
  <files>src/types/elements/visualizations.ts, src/types/elements/index.ts</files>
  <action>
Create `src/types/elements/visualizations.ts` with interfaces for all 5 visualization types:

**ScrollingWaveformElementConfig:**
- type: 'scrollingwaveform'
- displayMode: 'line' | 'fill' (per CONTEXT.md)
- waveformColor: string (default #00ff88)
- backgroundColor: string (default #1a1a1a)
- showGrid: boolean (toggleable per CONTEXT.md)
- gridColor: string
- canvasScale: number (HiDPI factor, default 1)

**SpectrumAnalyzerElementConfig:**
- type: 'spectrumanalyzer'
- fftSize: 512 | 1024 | 2048 | 4096 | 8192 (per requirements)
- frequencyScale: 'linear' | 'log' | 'mel' (per requirements)
- colorGradient: 'default' | 'fire' | 'cool' | 'grayscale'
- barGap: number (configurable per CONTEXT.md)
- backgroundColor: string (default #1a1a1a)
- showGrid: boolean
- gridColor: string
- showFrequencyLabels: boolean (toggleable per CONTEXT.md)
- showDbScale: boolean (toggleable per CONTEXT.md)
- canvasScale: number

**SpectrogramElementConfig:**
- type: 'spectrogram'
- fftSize: 512 | 1024 | 2048 | 4096 | 8192
- colorMap: 'default' | 'fire' | 'cool' | 'grayscale'
- backgroundColor: string (default #1a1a1a)
- showFrequencyLabels: boolean
- showTimeLabels: boolean
- canvasScale: number

**GoniometerElementConfig:**
- type: 'goniometer'
- traceColor: string (default #00ff88)
- backgroundColor: string (default #1a1a1a)
- showGrid: boolean (toggleable per CONTEXT.md)
- gridColor: string
- showAxisLines: boolean (L/R and M/S reference lines per CONTEXT.md)
- canvasScale: number

**VectorscopeElementConfig:**
- type: 'vectorscope'
- traceColor: string (default #00ff88)
- backgroundColor: string (default #1a1a1a)
- showGrid: boolean
- gridColor: string
- showAxisLines: boolean
- canvasScale: number

Include:
- BaseElementConfig extension for all types
- VisualizationElement union type
- Type guards (isScrollingWaveform, isSpectrumAnalyzer, etc.)
- Factory functions (createScrollingWaveform, createSpectrumAnalyzer, etc.) with sensible defaults

Default sizes per type:
- ScrollingWaveform: 200x80 (2.5:1 aspect)
- SpectrumAnalyzer: 256x150 (16:9 approx)
- Spectrogram: 256x200 (waterfall)
- Goniometer: 150x150 (square/circular)
- Vectorscope: 150x150 (square/circular)

Update `src/types/elements/index.ts`:
- Import and export VisualizationElement types
- Add to ElementConfig union
- Export all type guards and factory functions
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>5 visualization type interfaces defined with factory functions, union type exported from index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create mock audio data utilities</name>
  <files>src/utils/mockAudioData.ts</files>
  <action>
Create `src/utils/mockAudioData.ts` with static mock data generators per CONTEXT.md decisions:

**generatePinkNoiseSpectrum(barCount: number): number[]**
- Pink noise slope (-3dB/octave) for spectrum analyzer
- Formula: `Math.pow(frequency + 0.1, -0.5)` approximation
- Add ±10% random variation for natural appearance
- Normalize to 0-1 range, bias toward 0.6-0.8 levels

**generateWaveformData(sampleCount: number): number[]**
- Static snapshot of waveform (frozen, not animated per CONTEXT.md)
- Generate realistic audio-like waveform using sine waves with harmonics
- Output: array of values from -1 to 1
- Add some noise and natural variation

**generateSpectrogramFrame(width: number, fftSize: number): number[][]**
- Single frozen frame per CONTEXT.md
- Use pink noise distribution across frequency bins
- Add vertical (time) variation for realistic appearance
- Return 2D array [timeIndex][frequencyBin]

**generateMonoSignal(): { x: number, y: number }[]**
- Centered mono signal for goniometer/vectorscope (vertical line per CONTEXT.md)
- Returns array of points representing L/R correlation
- For mono: x varies slightly around 0, y varies for vertical line

**magnitudeToColor(magnitude: number, colorMap: string): string**
- Map 0-1 magnitude to heatmap color
- 'default': blue (240°) to red (0°) via HSL
- 'fire': black -> red -> orange -> yellow -> white
- 'cool': black -> blue -> cyan -> white
- 'grayscale': black -> white

Export all functions for use by visualization renderers.
  </action>
  <verify>File exists and exports expected functions: `ls src/utils/mockAudioData.ts && grep -c "export function" src/utils/mockAudioData.ts` shows 5+ exports</verify>
  <done>Mock data utilities created with pink noise spectrum, waveform data, spectrogram frames, and mono signal generators</done>
</task>

<task type="auto">
  <name>Task 3: Create Canvas setup hook</name>
  <files>src/hooks/useCanvasSetup.ts</files>
  <action>
Create `src/hooks/useCanvasSetup.ts` with a reusable hook for Canvas HiDPI setup:

**useCanvasSetup(width: number, height: number, scale?: number)**

Hook should:
1. Create canvasRef using useRef<HTMLCanvasElement>()
2. Use useLayoutEffect (NOT useEffect per RESEARCH.md) for setup
3. Handle HiDPI scaling:
   - Get devicePixelRatio from window (or use scale param if provided)
   - Set canvas.width = width * dpr
   - Set canvas.height = height * dpr
   - Set canvas.style.width = `${width}px`
   - Set canvas.style.height = `${height}px`
   - ctx.scale(dpr, dpr)
4. Return { canvasRef, ctx } where ctx is the 2D rendering context
5. Handle null checks for canvas not yet mounted

Per RESEARCH.md pattern:
```typescript
export function useCanvasSetup(
  width: number,
  height: number,
  scale?: number
) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null)

  useLayoutEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const dpr = scale || window.devicePixelRatio || 1

    canvas.width = width * dpr
    canvas.height = height * dpr
    canvas.style.width = `${width}px`
    canvas.style.height = `${height}px`

    const ctx = canvas.getContext('2d')
    if (ctx) {
      ctx.scale(dpr, dpr)
      ctxRef.current = ctx
    }
  }, [width, height, scale])

  return { canvasRef, ctx: ctxRef.current }
}
```

Note: This hook does NOT include animation loop - renderers will draw once with static mock data per CONTEXT.md decision.
  </action>
  <verify>File exists with correct hook signature: `grep "export function useCanvasSetup" src/hooks/useCanvasSetup.ts`</verify>
  <done>Canvas setup hook created with HiDPI scaling, useLayoutEffect pattern, and proper cleanup</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. All 5 visualization types can be imported from src/types/elements
3. Mock data utilities export all expected functions
4. Canvas hook uses useLayoutEffect (not useEffect)
</verification>

<success_criteria>
- TypeScript compiles successfully
- 5 visualization type interfaces exist with all properties from CONTEXT.md
- Factory functions create valid element configs
- Mock data utilities generate realistic patterns (pink noise, mono signal)
- Canvas hook handles HiDPI scaling correctly
</success_criteria>

<output>
After completion, create `.planning/phases/25-real-time-visualizations/25-01-SUMMARY.md`
</output>
