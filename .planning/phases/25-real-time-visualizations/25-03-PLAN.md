---
phase: 25-real-time-visualizations
plan: 03
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/components/elements/renderers/displays/visualizations/SpectrogramRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/GoniometerRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/VectorscopeRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/index.ts
  - src/components/elements/renderers/displays/index.ts
  - src/components/elements/renderers/index.ts
autonomous: true

must_haves:
  truths:
    - "Spectrogram renders with frozen time-frequency color map"
    - "Goniometer renders circular display with mono signal (vertical line)"
    - "Vectorscope renders Lissajous display with mono signal"
  artifacts:
    - path: "src/components/elements/renderers/displays/visualizations/SpectrogramRenderer.tsx"
      provides: "Canvas-based spectrogram waterfall visualization"
      exports: ["SpectrogramRenderer"]
    - path: "src/components/elements/renderers/displays/visualizations/GoniometerRenderer.tsx"
      provides: "Canvas-based goniometer L/R phase display"
      exports: ["GoniometerRenderer"]
    - path: "src/components/elements/renderers/displays/visualizations/VectorscopeRenderer.tsx"
      provides: "Canvas-based vectorscope Lissajous display"
      exports: ["VectorscopeRenderer"]
  key_links:
    - from: "src/components/elements/renderers/displays/visualizations/GoniometerRenderer.tsx"
      to: "src/utils/mockAudioData.ts"
      via: "import generateMonoSignal"
      pattern: "generateMonoSignal"
---

<objective>
Create Canvas-based renderers for Spectrogram, Goniometer, and Vectorscope visualizations.

Purpose: Complete the remaining 3 visualization types with static mock data rendering per CONTEXT.md decisions.

Output: Three working renderers registered in the renderer registry.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/25-real-time-visualizations/25-CONTEXT.md
@.planning/phases/25-real-time-visualizations/25-RESEARCH.md
@.planning/phases/25-real-time-visualizations/25-01-SUMMARY.md
@src/utils/mockAudioData.ts
@src/hooks/useCanvasSetup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SpectrogramRenderer</name>
  <files>src/components/elements/renderers/displays/visualizations/SpectrogramRenderer.tsx</files>
  <action>
Create `SpectrogramRenderer.tsx` in the visualizations folder:

Import:
- React, useLayoutEffect, useRef, useMemo
- SpectrogramElementConfig from types
- generateSpectrogramFrame, magnitudeToColor from mockAudioData
- useCanvasSetup from hooks

**SpectrogramRenderer({ config }: { config: SpectrogramElementConfig })**

Implementation:
1. Use useCanvasSetup hook for canvas ref and HiDPI setup
2. Generate static spectrogram frame with useMemo (single frozen frame per CONTEXT.md)
3. useLayoutEffect to draw once (NOT animated - frozen snapshot per CONTEXT.md)

Drawing logic:
```typescript
const spectrogramData = useMemo(
  () => generateSpectrogramFrame(config.width, config.fftSize),
  [config.width, config.fftSize]
)

// Clear canvas with background
ctx.fillStyle = config.backgroundColor
ctx.fillRect(0, 0, config.width, config.height)

// Draw spectrogram pixels
const frequencyBins = spectrogramData[0]?.length || 64
const timeSlices = spectrogramData.length

spectrogramData.forEach((timeSlice, timeIndex) => {
  const y = (timeIndex / timeSlices) * config.height
  const rowHeight = config.height / timeSlices

  timeSlice.forEach((magnitude, freqIndex) => {
    const x = (freqIndex / frequencyBins) * config.width
    const colWidth = config.width / frequencyBins

    const color = magnitudeToColor(magnitude, config.colorMap)
    ctx.fillStyle = color
    ctx.fillRect(x, y, colWidth + 0.5, rowHeight + 0.5) // +0.5 to prevent gaps
  })
})

// Draw frequency labels if enabled
if (config.showFrequencyLabels) {
  ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
  ctx.font = '10px monospace'
  ctx.textAlign = 'right'
  const freqLabels = ['20k', '10k', '1k', '100', '20']
  freqLabels.forEach((label, i) => {
    const y = ((i + 0.5) / freqLabels.length) * config.height
    ctx.fillText(label, 35, y + 4)
  })
}

// Draw time labels if enabled (left side = older, right = newer)
if (config.showTimeLabels) {
  ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'
  ctx.font = '10px monospace'
  ctx.textAlign = 'center'
  ctx.fillText('Time →', config.width / 2, config.height - 4)
}
```

Return canvas element with proper styling.
  </action>
  <verify>File exists and exports component: `grep "export function SpectrogramRenderer" src/components/elements/renderers/displays/visualizations/SpectrogramRenderer.tsx`</verify>
  <done>SpectrogramRenderer created with frozen waterfall display, color mapping, and frequency labels</done>
</task>

<task type="auto">
  <name>Task 2: Create GoniometerRenderer and VectorscopeRenderer</name>
  <files>src/components/elements/renderers/displays/visualizations/GoniometerRenderer.tsx, src/components/elements/renderers/displays/visualizations/VectorscopeRenderer.tsx</files>
  <action>
Create `GoniometerRenderer.tsx`:

Import:
- React, useLayoutEffect, useRef, useMemo
- GoniometerElementConfig from types
- generateMonoSignal from mockAudioData
- useCanvasSetup from hooks

**GoniometerRenderer({ config }: { config: GoniometerElementConfig })**

Drawing logic per RESEARCH.md Goniometer pattern:
```typescript
const monoSignal = useMemo(() => generateMonoSignal(), [])

const centerX = config.width / 2
const centerY = config.height / 2
const radius = Math.min(config.width, config.height) * 0.4

// Clear canvas
ctx.fillStyle = config.backgroundColor
ctx.fillRect(0, 0, config.width, config.height)

// Draw grid if enabled
if (config.showGrid) {
  ctx.strokeStyle = config.gridColor
  ctx.lineWidth = 0.5
  ctx.globalAlpha = 0.3

  // Circular grid rings
  for (let r = radius * 0.25; r <= radius; r += radius * 0.25) {
    ctx.beginPath()
    ctx.arc(centerX, centerY, r, 0, Math.PI * 2)
    ctx.stroke()
  }
  ctx.globalAlpha = 1.0
}

// Draw axis lines if enabled (L/R and M/S reference)
if (config.showAxisLines) {
  ctx.strokeStyle = config.gridColor
  ctx.lineWidth = 1
  ctx.globalAlpha = 0.5

  // Vertical center line (M axis - mono)
  ctx.beginPath()
  ctx.moveTo(centerX, centerY - radius)
  ctx.lineTo(centerX, centerY + radius)
  ctx.stroke()

  // Horizontal center line (S axis - side)
  ctx.beginPath()
  ctx.moveTo(centerX - radius, centerY)
  ctx.lineTo(centerX + radius, centerY)
  ctx.stroke()

  // Diagonal lines (L/R at 45°)
  ctx.beginPath()
  ctx.moveTo(centerX - radius * 0.707, centerY - radius * 0.707)
  ctx.lineTo(centerX + radius * 0.707, centerY + radius * 0.707)
  ctx.stroke()

  ctx.beginPath()
  ctx.moveTo(centerX + radius * 0.707, centerY - radius * 0.707)
  ctx.lineTo(centerX - radius * 0.707, centerY + radius * 0.707)
  ctx.stroke()

  // Add L/R labels
  ctx.fillStyle = config.gridColor
  ctx.font = '10px monospace'
  ctx.textAlign = 'center'
  ctx.fillText('L', centerX - radius * 0.707 - 10, centerY - radius * 0.707)
  ctx.fillText('R', centerX + radius * 0.707 + 10, centerY - radius * 0.707)

  ctx.globalAlpha = 1.0
}

// Draw mono signal (vertical line per CONTEXT.md)
ctx.strokeStyle = config.traceColor
ctx.lineWidth = 2
ctx.beginPath()
monoSignal.forEach((point, i) => {
  // Scale to canvas coordinates
  const x = centerX + point.x * radius
  const y = centerY - point.y * radius // Invert Y for screen coords
  if (i === 0) ctx.moveTo(x, y)
  else ctx.lineTo(x, y)
})
ctx.stroke()
```

---

Create `VectorscopeRenderer.tsx`:

Nearly identical to GoniometerRenderer but with Lissajous-style display. The difference is mostly in labeling and interpretation:
- Goniometer: rotated 45° (M/S mode)
- Vectorscope: standard X/Y (L on X, R on Y)

Drawing differences:
- Labels: "L" on left, "R" on top (not diagonal)
- Reference circle at unity (radius = 1.0)
- Same mono signal (vertical line for correlated mono)

Both should use the same generateMonoSignal() for mock data per CONTEXT.md (centered mono signal = vertical line).
  </action>
  <verify>`ls src/components/elements/renderers/displays/visualizations/*.tsx | wc -l` shows 5 files</verify>
  <done>GoniometerRenderer and VectorscopeRenderer created with circular display, axis lines, and mono signal</done>
</task>

<task type="auto">
  <name>Task 3: Register remaining renderers</name>
  <files>src/components/elements/renderers/displays/visualizations/index.ts, src/components/elements/renderers/displays/index.ts, src/components/elements/renderers/index.ts</files>
  <action>
Update `src/components/elements/renderers/displays/visualizations/index.ts`:
```typescript
export { ScrollingWaveformRenderer } from './ScrollingWaveformRenderer'
export { SpectrumAnalyzerRenderer } from './SpectrumAnalyzerRenderer'
export { SpectrogramRenderer } from './SpectrogramRenderer'
export { GoniometerRenderer } from './GoniometerRenderer'
export { VectorscopeRenderer } from './VectorscopeRenderer'
```

Update `src/components/elements/renderers/displays/index.ts`:
- Add imports for SpectrogramRenderer, GoniometerRenderer, VectorscopeRenderer from './visualizations'
- Re-export all 5 visualization renderers

Update `src/components/elements/renderers/index.ts`:
- Import SpectrogramRenderer, GoniometerRenderer, VectorscopeRenderer from displays
- Add to rendererRegistry Map:
  ```typescript
  ['spectrogram', SpectrogramRenderer as RendererComponent],
  ['goniometer', GoniometerRenderer as RendererComponent],
  ['vectorscope', VectorscopeRenderer as RendererComponent],
  ```
- Add to re-exports at bottom of file
  </action>
  <verify>`grep -c "Renderer" src/components/elements/renderers/displays/visualizations/index.ts` shows 5</verify>
  <done>All 5 visualization renderers registered in rendererRegistry</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. Spectrogram renders frozen frame with color-mapped frequency bins
3. Goniometer renders circular display with L/R axis lines and mono signal
4. Vectorscope renders Lissajous display with mono signal
5. All 5 visualization renderers registered in rendererRegistry
</verification>

<success_criteria>
- TypeScript compiles successfully
- SpectrogramRenderer draws waterfall color map on Canvas
- GoniometerRenderer draws circular phase display with axis lines
- VectorscopeRenderer draws Lissajous display
- All use static mock data (frozen snapshot per CONTEXT.md)
- All use useLayoutEffect (not useEffect)
- 5 renderers total in visualizations folder
</success_criteria>

<output>
After completion, create `.planning/phases/25-real-time-visualizations/25-03-SUMMARY.md`
</output>
