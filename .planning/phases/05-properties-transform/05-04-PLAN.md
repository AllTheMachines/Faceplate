---
phase: 05-properties-transform
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/Properties/PropertyPanel.tsx
  - src/components/Properties/KnobProperties.tsx
  - src/components/Properties/SliderProperties.tsx
  - src/components/Properties/ButtonProperties.tsx
  - src/components/Properties/LabelProperties.tsx
  - src/components/Properties/MeterProperties.tsx
  - src/components/Properties/ImageProperties.tsx
  - src/components/Properties/index.ts
  - src/components/Layout/RightPanel.tsx
autonomous: true

must_haves:
  truths:
    - "Property panel shows when element is selected"
    - "Property panel shows type-specific inputs for each element type"
    - "Changing property values immediately updates canvas"
    - "User can edit name and parameterId fields"
  artifacts:
    - path: "src/components/Properties/PropertyPanel.tsx"
      provides: "Main property panel with base + type-specific sections"
      min_lines: 80
    - path: "src/components/Properties/KnobProperties.tsx"
      provides: "Knob-specific properties (arc, colors, etc)"
      min_lines: 40
    - path: "src/components/Layout/RightPanel.tsx"
      provides: "Renders PropertyPanel for selected element"
      contains: "PropertyPanel"
  key_links:
    - from: "src/components/Properties/PropertyPanel.tsx"
      to: "src/types/elements.ts"
      via: "type guards"
      pattern: "isKnob|isSlider|isButton"
    - from: "src/components/Properties/PropertyPanel.tsx"
      to: "src/store/elementsSlice.ts"
      via: "updateElement"
      pattern: "updateElement.*id"
---

<objective>
Build the complete property panel with type-specific editors for all 6 element types.

Purpose: Users need to precisely configure element properties (PROP-01 through PROP-05). This includes position/size, identity (name, parameterId), and type-specific properties like colors, values, and styles.

Output: PropertyPanel component with BaseProperties (shared), and 6 type-specific property components, integrated into RightPanel to show when an element is selected.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-properties-transform/05-CONTEXT.md
@.planning/phases/05-properties-transform/05-RESEARCH.md

# Property input components (from 05-01)
@src/components/Properties/index.ts

# Element types and guards
@src/types/elements.ts

# Existing RightPanel
@src/components/Layout/RightPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PropertyPanel and type-specific property components</name>
  <files>
    - src/components/Properties/PropertyPanel.tsx
    - src/components/Properties/KnobProperties.tsx
    - src/components/Properties/SliderProperties.tsx
    - src/components/Properties/ButtonProperties.tsx
    - src/components/Properties/LabelProperties.tsx
    - src/components/Properties/MeterProperties.tsx
    - src/components/Properties/ImageProperties.tsx
    - src/components/Properties/index.ts
  </files>
  <action>
1. Create PropertyPanel.tsx:
   - Get selectedIds[0] from store (first selected element only)
   - Get element via getElement(selectedId)
   - If no element selected, show "No element selected" message
   - If multiple elements selected, show "Multiple elements selected" message (defer multi-edit to Phase 6)
   - Structure:
     ```
     <div className="space-y-6">
       {/* Position & Size */}
       <PropertySection title="Position & Size">
         <div className="grid grid-cols-2 gap-3">
           <NumberInput label="X" value={element.x} onChange={(x) => update({ x })} />
           <NumberInput label="Y" value={element.y} onChange={(y) => update({ y })} />
           <NumberInput label="Width" value={element.width} onChange={(width) => update({ width })} min={20} />
           <NumberInput label="Height" value={element.height} onChange={(height) => update({ height })} min={20} />
         </div>
         <NumberInput label="Rotation" value={element.rotation} onChange={(rotation) => update({ rotation })} min={-360} max={360} />
       </PropertySection>

       {/* Identity */}
       <PropertySection title="Identity">
         <TextInput label="Name" value={element.name} onChange={(name) => update({ name })} />
         <TextInput label="Parameter ID" value={element.parameterId || ''} onChange={(parameterId) => update({ parameterId: parameterId || undefined })} />
       </PropertySection>

       {/* Type-specific properties */}
       {isKnob(element) && <KnobProperties element={element} onUpdate={update} />}
       {isSlider(element) && <SliderProperties element={element} onUpdate={update} />}
       {isButton(element) && <ButtonProperties element={element} onUpdate={update} />}
       {isLabel(element) && <LabelProperties element={element} onUpdate={update} />}
       {isMeter(element) && <MeterProperties element={element} onUpdate={update} />}
       {isImage(element) && <ImageProperties element={element} onUpdate={update} />}
     </div>
     ```

2. Create KnobProperties.tsx:
   - Props: element (KnobElementConfig), onUpdate function
   - Sections:
     - Value: value (0-1), min, max (use NumberInput with step)
     - Arc Geometry: startAngle (-180 to 180), endAngle (-180 to 180), trackWidth
     - Style: style dropdown (arc, filled, dot, line)
     - Colors: trackColor, fillColor, indicatorColor (use ColorInput)

3. Create SliderProperties.tsx:
   - Orientation: dropdown (vertical, horizontal)
   - Value: value, min, max
   - Track: trackColor, trackFillColor
   - Thumb: thumbColor, thumbWidth, thumbHeight

4. Create ButtonProperties.tsx:
   - Behavior: mode dropdown (momentary, toggle), label text, pressed checkbox
   - Appearance: backgroundColor, textColor, borderColor, borderRadius

5. Create LabelProperties.tsx:
   - Text: text content
   - Typography: fontSize, fontFamily, fontWeight, textAlign dropdown
   - Color: color

6. Create MeterProperties.tsx:
   - Orientation: dropdown
   - Value: value, min, max
   - Colors: backgroundColor (for this plan, defer colorStops array editing)
   - Peak Hold: showPeakHold checkbox

7. Create ImageProperties.tsx:
   - Source: src (text input for URL or shows "Base64 image")
   - Fit: dropdown (contain, cover, fill, none)

8. Update index.ts to export PropertyPanel and all type-specific components

Note: Use consistent patterns:
- Each type component receives element + onUpdate
- Use PropertySection for groupings
- Use grid layout for related inputs (X/Y, Width/Height)
  </action>
  <verify>
    - npm run build passes
    - grep "isKnob" src/components/Properties/PropertyPanel.tsx confirms type guards
    - ls src/components/Properties/*.tsx | wc -l shows 8+ files
  </verify>
  <done>
    - PropertyPanel shows base properties (position, size, identity)
    - All 6 type-specific property components created
    - Type guards used to render correct properties
    - All properties update element via onUpdate callback
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate PropertyPanel into RightPanel</name>
  <files>
    - src/components/Layout/RightPanel.tsx
  </files>
  <action>
1. Update RightPanel.tsx:
   - Import PropertyPanel from '../Properties'
   - Get selectedIds from store
   - Conditional rendering:
     ```typescript
     const selectedIds = useStore((state) => state.selectedIds)
     const hasSelection = selectedIds.length > 0
     ```
   - If hasSelection, render PropertyPanel instead of (or above) canvas settings
   - Keep canvas settings visible but collapsed or below element properties
   - Layout structure:
     ```
     <div className="bg-gray-800 border-l border-gray-700 overflow-y-auto flex flex-col">
       <div className="p-4 flex-1 overflow-y-auto">
         <h2 className="text-lg font-semibold text-gray-100 mb-4">Properties</h2>

         {hasSelection ? (
           <PropertyPanel />
         ) : (
           {/* Canvas Settings Section - existing code */}
         )}
       </div>
       <ZOrderPanel />
     </div>
     ```

2. Remove the "Full property panel (Phase 5)" placeholder text

3. Ensure the panel scrolls if content overflows (overflow-y-auto on content area)
  </action>
  <verify>
    - npm run build passes
    - grep "PropertyPanel" src/components/Layout/RightPanel.tsx confirms import and usage
    - grep "Phase 5" src/components/Layout/RightPanel.tsx returns nothing (placeholder removed)
  </verify>
  <done>
    - RightPanel shows PropertyPanel when element selected
    - RightPanel shows canvas settings when no selection
    - Panel content scrolls when overflowing
    - Placeholder text removed
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- PropertyPanel renders type-specific properties based on element type
- Changing values in property panel updates elements immediately on canvas
- RightPanel conditionally shows PropertyPanel or canvas settings
</verification>

<success_criteria>
- [ ] Selecting an element shows its properties in the right panel
- [ ] Position (X, Y) and size (Width, Height) inputs work
- [ ] Name and Parameter ID fields work
- [ ] Knob-specific properties show for knobs (colors, arc settings)
- [ ] Slider-specific properties show for sliders
- [ ] Button-specific properties show for buttons
- [ ] Label-specific properties show for labels
- [ ] Meter-specific properties show for meters
- [ ] Image-specific properties show for images
- [ ] Changing any property immediately updates the canvas
</success_criteria>

<output>
After completion, create `.planning/phases/05-properties-transform/05-04-SUMMARY.md`
</output>
