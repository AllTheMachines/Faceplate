---
phase: 05-properties-transform
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Canvas/SelectionOverlay.tsx
  - src/components/Canvas/hooks/useResize.ts
  - src/components/Canvas/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "User can drag corner handles to resize elements"
    - "Resize respects minimum size (20px)"
    - "Resize accounts for viewport scale"
    - "Resize handles show correct cursors"
  artifacts:
    - path: "src/components/Canvas/hooks/useResize.ts"
      provides: "Mouse event handlers for resize operations"
      min_lines: 80
    - path: "src/components/Canvas/SelectionOverlay.tsx"
      provides: "Interactive resize handles with mouse events"
      contains: "onMouseDown"
  key_links:
    - from: "src/components/Canvas/SelectionOverlay.tsx"
      to: "src/components/Canvas/hooks/useResize.ts"
      via: "useResize hook"
      pattern: "useResize"
    - from: "src/components/Canvas/hooks/useResize.ts"
      to: "src/store/elementsSlice.ts"
      via: "updateElement"
      pattern: "updateElement.*width.*height"
---

<objective>
Make the selection overlay resize handles interactive, allowing users to resize elements by dragging handles.

Purpose: Users need to resize elements to fit their UI design (MANP-02). The resize handles already exist visually but are currently decorative.

Output: Interactive resize handles on SelectionOverlay that respond to drag operations, updating element dimensions with proper coordinate transformation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-properties-transform/05-CONTEXT.md
@.planning/phases/05-properties-transform/05-RESEARCH.md

# Existing selection overlay
@src/components/Canvas/SelectionOverlay.tsx

# Store with viewport scale
@src/store/viewportSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useResize hook</name>
  <files>
    - src/components/Canvas/hooks/useResize.ts
    - src/components/Canvas/hooks/index.ts
  </files>
  <action>
1. Create src/components/Canvas/hooks/useResize.ts:

```typescript
import { useState, useEffect, useRef, useCallback } from 'react'
import { useStore } from '../../../store'

type HandlePosition = 'nw' | 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w'

interface UseResizeReturn {
  isResizing: boolean
  startResize: (e: React.MouseEvent, position: HandlePosition, elementId: string) => void
}

export function useResize(): UseResizeReturn {
  const [isResizing, setIsResizing] = useState(false)
  const [activeHandle, setActiveHandle] = useState<HandlePosition | null>(null)
  const [elementId, setElementId] = useState<string | null>(null)

  const startPos = useRef({ x: 0, y: 0 })
  const startBounds = useRef({ x: 0, y: 0, width: 0, height: 0 })

  const scale = useStore((state) => state.scale)
  const getElement = useStore((state) => state.getElement)
  const updateElement = useStore((state) => state.updateElement)

  const startResize = useCallback((e: React.MouseEvent, position: HandlePosition, id: string) => {
    e.stopPropagation()
    e.preventDefault()

    const element = getElement(id)
    if (!element) return

    setIsResizing(true)
    setActiveHandle(position)
    setElementId(id)

    startPos.current = { x: e.clientX, y: e.clientY }
    startBounds.current = {
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height,
    }
  }, [getElement])

  useEffect(() => {
    if (!isResizing || !activeHandle || !elementId) return

    const handleMouseMove = (e: MouseEvent) => {
      // Calculate delta in canvas space (divide by scale)
      const deltaX = (e.clientX - startPos.current.x) / scale
      const deltaY = (e.clientY - startPos.current.y) / scale

      const MIN_SIZE = 20
      let updates: Partial<{ x: number; y: number; width: number; height: number }> = {}

      // Calculate new bounds based on handle position
      switch (activeHandle) {
        case 'se': // Bottom-right: only change size
          updates = {
            width: Math.max(MIN_SIZE, startBounds.current.width + deltaX),
            height: Math.max(MIN_SIZE, startBounds.current.height + deltaY),
          }
          break
        case 'sw': // Bottom-left: change x, width, height
          const newWidthSW = Math.max(MIN_SIZE, startBounds.current.width - deltaX)
          updates = {
            x: startBounds.current.x + startBounds.current.width - newWidthSW,
            width: newWidthSW,
            height: Math.max(MIN_SIZE, startBounds.current.height + deltaY),
          }
          break
        case 'ne': // Top-right: change y, width, height
          const newHeightNE = Math.max(MIN_SIZE, startBounds.current.height - deltaY)
          updates = {
            y: startBounds.current.y + startBounds.current.height - newHeightNE,
            width: Math.max(MIN_SIZE, startBounds.current.width + deltaX),
            height: newHeightNE,
          }
          break
        case 'nw': // Top-left: change x, y, width, height
          const newWidthNW = Math.max(MIN_SIZE, startBounds.current.width - deltaX)
          const newHeightNW = Math.max(MIN_SIZE, startBounds.current.height - deltaY)
          updates = {
            x: startBounds.current.x + startBounds.current.width - newWidthNW,
            y: startBounds.current.y + startBounds.current.height - newHeightNW,
            width: newWidthNW,
            height: newHeightNW,
          }
          break
        case 'n': // Top edge: only change y and height
          const newHeightN = Math.max(MIN_SIZE, startBounds.current.height - deltaY)
          updates = {
            y: startBounds.current.y + startBounds.current.height - newHeightN,
            height: newHeightN,
          }
          break
        case 's': // Bottom edge: only change height
          updates = {
            height: Math.max(MIN_SIZE, startBounds.current.height + deltaY),
          }
          break
        case 'e': // Right edge: only change width
          updates = {
            width: Math.max(MIN_SIZE, startBounds.current.width + deltaX),
          }
          break
        case 'w': // Left edge: change x and width
          const newWidthW = Math.max(MIN_SIZE, startBounds.current.width - deltaX)
          updates = {
            x: startBounds.current.x + startBounds.current.width - newWidthW,
            width: newWidthW,
          }
          break
      }

      updateElement(elementId, updates)
    }

    const handleMouseUp = () => {
      setIsResizing(false)
      setActiveHandle(null)
      setElementId(null)
    }

    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)

    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isResizing, activeHandle, elementId, scale, updateElement])

  return { isResizing, startResize }
}

export function getResizeCursor(position: HandlePosition): string {
  switch (position) {
    case 'nw':
    case 'se':
      return 'nwse-resize'
    case 'ne':
    case 'sw':
      return 'nesw-resize'
    case 'n':
    case 's':
      return 'ns-resize'
    case 'e':
    case 'w':
      return 'ew-resize'
    default:
      return 'default'
  }
}
```

2. Export from index.ts: Add `export { useResize, getResizeCursor } from './useResize'`
  </action>
  <verify>
    - npm run build passes
    - grep "useResize" src/components/Canvas/hooks/index.ts confirms export
  </verify>
  <done>
    - useResize hook created with mouse event handlers
    - All 8 resize directions handled correctly
    - Minimum size (20px) enforced
    - Coordinate transform (divide by scale) applied
    - getResizeCursor utility exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SelectionOverlay with interactive handles</name>
  <files>
    - src/components/Canvas/SelectionOverlay.tsx
  </files>
  <action>
1. Update SelectionOverlay.tsx:
   - Import useResize and getResizeCursor from hooks
   - Call useResize hook at top of component
   - Create ResizeHandle sub-component or render function that:
     - Sets pointerEvents: 'auto' (critical - override parent pointer-events: none)
     - Sets cursor via getResizeCursor(position)
     - Has onMouseDown that calls startResize(e, position, elementId)
   - Update each of the 8 existing handle divs to be ResizeHandles with correct position prop

2. Handle positions mapping:
   - Top-left corner (left: -4px, top: -4px) = 'nw'
   - Top-right corner (right: -4px, top: -4px) = 'ne'
   - Bottom-left corner (left: -4px, bottom: -4px) = 'sw'
   - Bottom-right corner (right: -4px, bottom: -4px) = 'se'
   - Top edge (left: 50%, top: -4px) = 'n'
   - Bottom edge (left: 50%, bottom: -4px) = 's'
   - Right edge (right: -4px, top: 50%) = 'e'
   - Left edge (left: -4px, top: 50%) = 'w'

3. Keep the parent div as pointerEvents: 'none' but each handle gets pointerEvents: 'auto'
  </action>
  <verify>
    - npm run build passes
    - grep "onMouseDown" src/components/Canvas/SelectionOverlay.tsx shows handle events
    - grep "pointerEvents: 'auto'" src/components/Canvas/SelectionOverlay.tsx confirms handles are clickable
  </verify>
  <done>
    - All 8 resize handles are interactive
    - Handles show correct resize cursors (nwse, nesw, ns, ew)
    - Dragging handles resizes the element
    - Resize respects minimum size
    - Parent overlay remains non-interactive (only handles respond)
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- useResize hook exists with proper mouse event handling
- SelectionOverlay handles have onMouseDown and correct cursors
- All 8 resize directions (4 corners + 4 edges) are implemented
</verification>

<success_criteria>
- [ ] Resize handles show correct cursors on hover
- [ ] Dragging corner handles resizes in both dimensions
- [ ] Dragging edge handles resizes in one dimension
- [ ] Minimum size (20px) is enforced
- [ ] Resize works correctly at different zoom levels
- [ ] Element position updates correctly for nw/ne/sw/w/n handles (which affect position)
</success_criteria>

<output>
After completion, create `.planning/phases/05-properties-transform/05-03-SUMMARY.md`
</output>
