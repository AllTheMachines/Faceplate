---
phase: 05-properties-transform
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/App.tsx
  - src/components/elements/BaseElement.tsx
  - src/store/elementsSlice.ts
autonomous: true

must_haves:
  truths:
    - "User can drag selected elements to move them on canvas"
    - "Element follows cursor during drag with live preview"
    - "Element position updates correctly accounting for zoom/pan"
    - "Drag only works on selected elements (not all elements)"
  artifacts:
    - path: "src/App.tsx"
      provides: "handleDragEnd distinguishes element move from palette drop"
      contains: "data.current?.sourceType === 'element'"
    - path: "src/components/elements/BaseElement.tsx"
      provides: "useDraggable for selected elements"
      contains: "useDraggable"
  key_links:
    - from: "src/components/elements/BaseElement.tsx"
      to: "@dnd-kit/core"
      via: "useDraggable hook"
      pattern: "useDraggable.*id.*element"
    - from: "src/App.tsx"
      to: "src/store/elementsSlice.ts"
      via: "updateElement on drag end"
      pattern: "updateElement.*id.*\\{.*x:.*y:"
---

<objective>
Enable dragging selected elements to reposition them on the canvas.

Purpose: Users need to move elements by dragging to arrange their UI layout. This is a core spatial manipulation feature (MANP-01).

Output: Selected elements become draggable via @dnd-kit, with handleDragEnd updated to handle both palette drops and element moves, using coordinate transform to account for zoom/pan.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-properties-transform/05-CONTEXT.md
@.planning/phases/05-properties-transform/05-RESEARCH.md

# Existing drag-drop implementation
@src/App.tsx
@src/components/elements/BaseElement.tsx

# Prior summary with coordinate transform pattern
@.planning/phases/04-palette-element-creation/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make BaseElement draggable when selected</name>
  <files>
    - src/components/elements/BaseElement.tsx
    - src/store/elementsSlice.ts
  </files>
  <action>
1. Update BaseElement.tsx:
   - Import useDraggable from @dnd-kit/core
   - Import useStore from store
   - Get selectedIds from store: `const selectedIds = useStore((state) => state.selectedIds)`
   - Check if element is selected: `const isSelected = selectedIds.includes(element.id)`
   - Use useDraggable hook:
     ```typescript
     const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
       id: `element-${element.id}`,
       data: {
         sourceType: 'element',
         element,
       },
       disabled: !isSelected || element.locked,
     })
     ```
   - Apply transform during drag for live preview:
     ```typescript
     const dragStyle = transform ? {
       transform: `translate(${transform.x}px, ${transform.y}px)`,
     } : undefined
     ```
   - Merge dragStyle into existing style object
   - Apply setNodeRef to the wrapper div
   - Spread {...listeners} {...attributes} on wrapper div
   - Add cursor: isDragging ? 'grabbing' : (isSelected ? 'grab' : 'pointer')
   - Ensure onClick still works by checking for drag state
  </action>
  <verify>
    - npm run build passes
    - grep "useDraggable" src/components/elements/BaseElement.tsx shows import and usage
  </verify>
  <done>
    - BaseElement uses useDraggable when selected
    - Dragging shows live transform preview
    - Locked elements cannot be dragged
    - Non-selected elements cannot be dragged
  </done>
</task>

<task type="auto">
  <name>Task 2: Update handleDragEnd to support element moves</name>
  <files>
    - src/App.tsx
  </files>
  <action>
1. Update handleDragEnd in App.tsx to distinguish between:
   - Palette drops (sourceType === 'palette' or undefined, existing behavior)
   - Element moves (sourceType === 'element')

2. For element moves:
   ```typescript
   const { active, delta } = event
   const sourceType = active.data.current?.sourceType

   if (sourceType === 'element') {
     // Element move
     const element = active.data.current?.element
     if (!element) return

     // Convert screen delta to canvas delta (divide by scale)
     const canvasDeltaX = delta.x / scale
     const canvasDeltaY = delta.y / scale

     // Calculate new position
     const newX = element.x + canvasDeltaX
     const newY = element.y + canvasDeltaY

     // Update element position
     updateElement(element.id, { x: newX, y: newY })
     return
   }

   // Existing palette drop logic (unchanged)...
   ```

3. Get updateElement from store at component level

4. Key insight: delta is in screen space, must divide by scale to get canvas space movement. At 2x zoom, a 100px mouse move should result in 50px canvas movement.
  </action>
  <verify>
    - npm run build passes
    - grep "sourceType === 'element'" src/App.tsx confirms element move handling
    - grep "delta.x / scale" src/App.tsx confirms coordinate transform
  </verify>
  <done>
    - handleDragEnd handles both palette drops and element moves
    - Element moves use correct coordinate transform (delta / scale)
    - Existing palette drop functionality preserved
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- BaseElement imports and uses useDraggable from @dnd-kit/core
- handleDragEnd distinguishes element moves from palette drops
- Coordinate transform divides delta by scale for correct movement
</verification>

<success_criteria>
- [ ] Selected elements show grab cursor and can be dragged
- [ ] Non-selected elements cannot be dragged
- [ ] Element follows cursor during drag (live preview via transform)
- [ ] Element position updates correctly on drag end
- [ ] Works correctly at different zoom levels (coordinate transform applied)
- [ ] Palette drag-drop still works (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/05-properties-transform/05-02-SUMMARY.md`
</output>
