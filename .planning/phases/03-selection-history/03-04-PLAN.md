---
phase: 03-selection-history
plan: 04
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/components/Canvas/MarqueeSelection.tsx
  - src/components/Canvas/hooks/useMarquee.ts
  - src/components/Canvas/hooks/index.ts
  - src/components/Canvas/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag on canvas background to create a marquee selection rectangle"
    - "Elements intersecting the marquee become selected"
    - "Marquee rectangle is visible during drag"
    - "Marquee works correctly with zoomed/panned canvas"
  artifacts:
    - path: "src/components/Canvas/MarqueeSelection.tsx"
      provides: "Marquee rectangle visual"
      min_lines: 20
    - path: "src/components/Canvas/hooks/useMarquee.ts"
      provides: "Marquee drag logic"
      exports: ["useMarquee"]
  key_links:
    - from: "src/components/Canvas/hooks/useMarquee.ts"
      to: "src/utils/intersection.ts"
      via: "AABB intersection"
      pattern: "intersectRect"
    - from: "src/components/Canvas/hooks/useMarquee.ts"
      to: "selectMultiple"
      via: "store action"
      pattern: "selectMultiple"
---

<objective>
Implement marquee (drag) selection for selecting multiple elements by drawing a rectangle.

Purpose: Marquee selection enables CANV-06 (drag selection) and is essential for efficiently selecting groups of elements. Users drag on canvas background to select all elements within the drawn rectangle.

Output: MarqueeSelection component and useMarquee hook that handle drag-to-select functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-selection-history/03-CONTEXT.md
@.planning/phases/03-selection-history/03-RESEARCH.md
@src/components/Canvas/Canvas.tsx
@src/utils/intersection.ts
@src/store/elementsSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useMarquee hook</name>
  <files>src/components/Canvas/hooks/useMarquee.ts, src/components/Canvas/hooks/index.ts</files>
  <action>
Create a hook to manage marquee drag selection state and logic.

**State:**
```typescript
interface MarqueeState {
  isActive: boolean
  startX: number  // Canvas-relative start position
  startY: number
  currentX: number  // Canvas-relative current position
  currentY: number
}
```

**Implementation:**

```typescript
import { useState, useCallback, useRef } from 'react'
import { useStore } from '../../../store'
import { intersectRect, Rect } from '../../../utils/intersection'

export function useMarquee(canvasRef: React.RefObject<HTMLDivElement>) {
  const [marquee, setMarquee] = useState<MarqueeState | null>(null)
  const elements = useStore((state) => state.elements)
  const selectMultiple = useStore((state) => state.selectMultiple)
  const scale = useStore((state) => state.scale)
  const offsetX = useStore((state) => state.offsetX)
  const offsetY = useStore((state) => state.offsetY)

  // Convert screen coordinates to canvas coordinates
  const screenToCanvas = useCallback((screenX: number, screenY: number) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }

    // Get position relative to viewport container
    const relX = screenX - rect.left
    const relY = screenY - rect.top

    // Reverse the transform: first un-offset, then un-scale
    const canvasX = (relX - offsetX) / scale
    const canvasY = (relY - offsetY) / scale

    return { x: canvasX, y: canvasY }
  }, [scale, offsetX, offsetY, canvasRef])

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    // Only start marquee on left click, not during pan (spacebar)
    if (e.button !== 0) return

    const { x, y } = screenToCanvas(e.clientX, e.clientY)
    setMarquee({
      isActive: true,
      startX: x,
      startY: y,
      currentX: x,
      currentY: y,
    })
  }, [screenToCanvas])

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!marquee?.isActive) return

    const { x, y } = screenToCanvas(e.clientX, e.clientY)
    setMarquee((prev) => prev ? { ...prev, currentX: x, currentY: y } : null)

    // Calculate marquee rect (handle negative dimensions)
    const marqueeRect: Rect = {
      left: Math.min(marquee.startX, x),
      top: Math.min(marquee.startY, y),
      right: Math.max(marquee.startX, x),
      bottom: Math.max(marquee.startY, y),
    }

    // Find intersecting elements
    const intersecting = elements.filter((el) => {
      const elRect: Rect = {
        left: el.x,
        top: el.y,
        right: el.x + el.width,
        bottom: el.y + el.height,
      }
      return intersectRect(marqueeRect, elRect)
    })

    // Update selection with intersecting element IDs
    selectMultiple(intersecting.map((el) => el.id))
  }, [marquee, screenToCanvas, elements, selectMultiple])

  const handleMouseUp = useCallback(() => {
    setMarquee(null)
  }, [])

  // Calculate marquee rect for rendering (in canvas coordinates)
  const marqueeRect = marquee ? {
    x: Math.min(marquee.startX, marquee.currentX),
    y: Math.min(marquee.startY, marquee.currentY),
    width: Math.abs(marquee.currentX - marquee.startX),
    height: Math.abs(marquee.currentY - marquee.startY),
  } : null

  return {
    marqueeRect,
    isActive: marquee?.isActive ?? false,
    handlers: {
      onMouseDown: handleMouseDown,
      onMouseMove: handleMouseMove,
      onMouseUp: handleMouseUp,
      onMouseLeave: handleMouseUp,
    },
  }
}
```

**Key points:**
- Convert screen coordinates to canvas coordinates accounting for scale and offset
- Use AABB intersection to find overlapping elements
- Handle negative drag directions (dragging up-left)
- Clear marquee on mouse up or mouse leave

**Update hooks/index.ts:**
Add export: `export { useMarquee } from './useMarquee'`
  </action>
  <verify>Hook compiles without TypeScript errors</verify>
  <done>useMarquee returns marqueeRect and handlers for drag selection</done>
</task>

<task type="auto">
  <name>Task 2: Create MarqueeSelection component</name>
  <files>src/components/Canvas/MarqueeSelection.tsx</files>
  <action>
Create a component to render the marquee selection rectangle.

**Props:**
```typescript
interface MarqueeSelectionProps {
  rect: {
    x: number
    y: number
    width: number
    height: number
  }
}
```

**Implementation:**
```typescript
export function MarqueeSelection({ rect }: MarqueeSelectionProps) {
  return (
    <div
      style={{
        position: 'absolute',
        left: rect.x,
        top: rect.y,
        width: rect.width,
        height: rect.height,
        border: '1px dashed #3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        pointerEvents: 'none',
      }}
    />
  )
}
```

**Styling:**
- Dashed blue border (same blue as selection)
- Light blue fill with low opacity
- pointerEvents: none to not interfere with mouse events
- Position absolute, rendered inside canvas-background
  </action>
  <verify>Component renders a styled rectangle at specified position</verify>
  <done>MarqueeSelection renders a dashed blue rectangle with transparent fill</done>
</task>

<task type="auto">
  <name>Task 3: Integrate marquee into Canvas</name>
  <files>src/components/Canvas/Canvas.tsx</files>
  <action>
Wire up marquee selection into the Canvas component.

**Changes:**

1. Import useMarquee and MarqueeSelection:
```typescript
import { MarqueeSelection } from './MarqueeSelection'
import { usePan, useZoom, useKeyboardShortcuts, useMarquee } from './hooks'
```

2. Create ref for the canvas background (or reuse viewport ref):
The marquee needs a ref to the element that receives mouse events. Use the viewport ref since that's where events are captured.

3. Call useMarquee with the viewport ref:
```typescript
const { marqueeRect, isActive: isMarqueeActive, handlers: marqueeHandlers } = useMarquee(viewportRef)
```

4. Merge handlers carefully - marquee should NOT activate during pan (spacebar held):
```typescript
// Combine pan and marquee handlers
const handleMouseDown = (e: React.MouseEvent) => {
  // Pan takes priority when spacebar is held
  if (isPanning) {
    panHandlers.onMouseDown?.(e)
  } else {
    // Check if clicking on canvas background (not an element)
    // Start marquee only if clicking empty space
    marqueeHandlers.onMouseDown(e)
  }
}
```

**Important:** Need to prevent marquee from starting when:
- Spacebar is held (pan mode)
- Clicking on an element (element click handles selection)

**Approach:**
- Marquee starts on mousedown on the canvas-background div (not viewport)
- Elements stop propagation, so background won't receive clicks on elements

5. Add marquee handlers to canvas-background div:
```typescript
<div
  className="canvas-background"
  style={{...}}
  onClick={clearSelection}
  onMouseDown={marqueeHandlers.onMouseDown}
  onMouseMove={marqueeHandlers.onMouseMove}
  onMouseUp={marqueeHandlers.onMouseUp}
  onMouseLeave={marqueeHandlers.onMouseLeave}
>
```

6. Render MarqueeSelection inside canvas-background when active:
```typescript
{/* Marquee selection rectangle */}
{marqueeRect && marqueeRect.width > 5 && marqueeRect.height > 5 && (
  <MarqueeSelection rect={marqueeRect} />
)}
```

**Threshold:** Only show marquee after dragging more than 5px to avoid accidental marquees on click.

7. Remove the clearSelection onClick from background since marquee onMouseDown will handle clicks:
When user just clicks (no drag), marquee ends with zero selection which effectively clears.
Or keep clearSelection for click-without-drag by checking if marquee had no movement.

**Simpler approach:** Keep clearSelection onClick. Marquee mousedown doesn't need to clear since:
- If user clicks without dragging: onClick fires (after mouseup) and clears selection
- If user drags: marquee selects elements, onClick doesn't fire (drag vs click detection)

Actually, onClick fires regardless. Need to prevent clearSelection when marquee just ended.

**Solution:** Track if marquee was just active. If marquee was active (had movement), don't clear on click.
Or: Remove onClick, let marquee handle both cases:
- Click (no drag): marquee ends with empty selection = effectively clears
- Drag: marquee selects elements

Use this simpler approach - remove onClick={clearSelection} from background.
  </action>
  <verify>Dragging on canvas creates blue dashed rectangle, elements within are selected</verify>
  <done>Marquee selection works: drag on canvas background selects elements within rectangle</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Drag on empty canvas area: dashed blue rectangle appears
3. Elements within rectangle become selected (blue border shows)
4. Releasing mouse finalizes selection
5. Marquee works correctly when canvas is zoomed in/out
6. Marquee works correctly when canvas is panned
7. Spacebar+drag still pans (doesn't start marquee)
8. Clicking element still selects it (marquee doesn't interfere)
</verification>

<success_criteria>
- CANV-06: Marquee (drag) selection - works correctly
- Marquee visual is clearly visible during drag
- Selection updates in real-time as marquee is dragged
- Coordinate transforms are correct at all zoom levels
- No interference with existing pan, zoom, or click selection
</success_criteria>

<output>
After completion, create `.planning/phases/03-selection-history/03-04-SUMMARY.md`
</output>
