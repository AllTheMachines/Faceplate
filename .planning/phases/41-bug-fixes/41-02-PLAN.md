---
phase: 41-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ContainerEditor/ContainerEditorCanvas.tsx
autonomous: true

must_haves:
  truths:
    - "Dragging one selected element moves all selected elements together"
    - "Each element maintains correct relative offset during drag"
    - "Final positions are snapped to grid for all moved elements"
    - "Single-select drag continues to work (regression)"
  artifacts:
    - path: "src/components/ContainerEditor/ContainerEditorCanvas.tsx"
      provides: "Multi-select drag implementation in container editor"
      contains: "selectedIds.forEach"
  key_links:
    - from: "ContainerEditorCanvas"
      to: "updateElement"
      via: "handleMouseUp for all selected elements"
      pattern: "selectedIds\\.forEach.*updateElement"
---

<objective>
Fix container editor to drag all selected elements together as a group

Purpose: GitHub Issue #3 - When multiple elements are selected in the container editor, dragging one should move all selected elements together, maintaining their relative positions.
Output: Modified ContainerEditorCanvas.tsx with multi-select drag support.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/components/ContainerEditor/ContainerEditorCanvas.tsx
@src/components/elements/BaseElement.tsx (reference for main canvas multi-drag pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement multi-select drag in container editor</name>
  <files>src/components/ContainerEditor/ContainerEditorCanvas.tsx</files>
  <action>
Modify ContainerEditorCanvas to support dragging multiple selected elements together.

**Current State:**
- `DragState` tracks only one `childId`
- `getDragOffset` only returns offset for the dragged element
- `handleMouseUp` only updates position for `drag.childId`

**Required Changes:**

1. **Extend DragState to track starting positions of ALL selected elements:**
```typescript
interface DragState {
  isDragging: boolean
  startX: number
  startY: number
  currentX: number
  currentY: number
  // Map of element ID to starting position
  elementStartPositions: Map<string, { x: number; y: number }>
}
```

2. **Modify startDrag to capture positions of all selected elements:**
```typescript
const startDrag = useCallback((childId: string, e: React.MouseEvent) => {
  e.stopPropagation()
  e.preventDefault()

  const child = elements.find((el) => el.id === childId)
  if (!child) return

  // Handle selection with modifier keys
  handleElementClick(childId, e)

  // Only start drag if not deselecting
  const isAltOrCtrl = e.altKey || e.ctrlKey || e.metaKey
  const wasSelected = selectedIds.includes(childId)
  if (isAltOrCtrl && wasSelected) {
    return
  }

  // Determine which elements to drag:
  // - If clicked element is selected, drag all selected elements
  // - If clicked element is not selected, it becomes selected (from handleElementClick), drag only it
  const elementsToInclude = selectedIds.includes(childId) ? selectedIds : [childId]

  // Capture starting positions of all elements to drag
  const startPositions = new Map<string, { x: number; y: number }>()
  for (const id of elementsToInclude) {
    const el = elements.find((e) => e.id === id)
    if (el && el.parentId === containerId) {  // Only elements in this container
      startPositions.set(id, { x: el.x, y: el.y })
    }
  }

  setDrag({
    isDragging: true,
    startX: e.clientX,
    startY: e.clientY,
    currentX: e.clientX,
    currentY: e.clientY,
    elementStartPositions: startPositions
  })
}, [elements, selectedIds, handleElementClick, containerId])
```

3. **Modify handleMouseUp to update ALL dragged elements:**
```typescript
const handleMouseUp = () => {
  if (drag.elementStartPositions.size > 0) {
    const deltaX = drag.currentX - drag.startX
    const deltaY = drag.currentY - drag.startY

    // Update each element that was being dragged
    drag.elementStartPositions.forEach((startPos, elementId) => {
      let newX = Math.max(0, Math.min(contentWidth - 20, startPos.x + deltaX))
      let newY = Math.max(0, Math.min(contentHeight - 20, startPos.y + deltaY))

      // Snap to grid if enabled
      const snapped = snapPosition(newX, newY)
      newX = snapped.x
      newY = snapped.y

      updateElement(elementId, { x: newX, y: newY })
    })
  }

  setDrag({
    isDragging: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    elementStartPositions: new Map()
  })
}
```

4. **Modify getDragOffset to return offset for ANY element being dragged:**
```typescript
const getDragOffset = (childId: string) => {
  if (!drag.isDragging || !drag.elementStartPositions.has(childId)) {
    return { x: 0, y: 0 }
  }
  return {
    x: drag.currentX - drag.startX,
    y: drag.currentY - drag.startY
  }
}
```

5. **Update the initial drag state:**
```typescript
const [drag, setDrag] = useState<DragState>({
  isDragging: false,
  startX: 0,
  startY: 0,
  currentX: 0,
  currentY: 0,
  elementStartPositions: new Map()
})
```

6. **Update visual feedback to show all dragged elements:**
In the render loop, check if element is being dragged:
```typescript
const isBeingDragged = drag.isDragging && drag.elementStartPositions.has(child.id)
```

7. **Update debug display to show count of dragged elements:**
```typescript
{drag.isDragging && (
  <div className="absolute bottom-4 left-4 bg-black/80 text-white text-xs p-2 rounded">
    Dragging: {drag.elementStartPositions.size} element{drag.elementStartPositions.size > 1 ? 's' : ''} | Offset: {Math.round(drag.currentX - drag.startX)}, {Math.round(drag.currentY - drag.startY)}
  </div>
)}
```
  </action>
  <verify>
1. Build passes: `npm run build`
2. Manual test:
   - Open container editor
   - Add multiple elements
   - Select multiple elements (Shift+click or Ctrl+click)
   - Drag one selected element
   - All selected elements should move together maintaining relative positions
3. Regression test:
   - Single element drag still works
   - Deselect via Alt/Ctrl+click still works
  </verify>
  <done>
Multiple selected elements in container editor move together when one is dragged. Each element maintains its relative position to others during drag. Grid snapping applies to all moved elements. Single-element drag continues to work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update buildInfo timestamp</name>
  <files>src/buildInfo.ts</files>
  <action>
Update the build timestamp to current time in CET format:
```typescript
export const lastUpdated = 'DD Mon HH:MM CET'
```
  </action>
  <verify>Check file contains current timestamp</verify>
  <done>buildInfo.ts has current timestamp</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Multi-select drag in container editor moves all selected elements
3. Relative positions maintained during drag
4. Grid snap applies to final positions of all elements
5. Single-select drag still works (regression)
</verification>

<success_criteria>
- Dragging one selected element moves all selected elements together
- Relative positions preserved during drag
- Grid snapping works for all moved elements
- No regression in single-select drag behavior
</success_criteria>

<output>
After completion, create `.planning/phases/41-bug-fixes/41-02-SUMMARY.md`
</output>
