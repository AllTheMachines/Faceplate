---
phase: 10-uat-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Canvas/hooks/useMarquee.ts
autonomous: true

must_haves:
  truths:
    - "Marquee selection starts at the exact mouse click position"
    - "Marquee rectangle visually follows the mouse from click origin"
    - "Marquee works correctly at all zoom levels (0.25x, 1x, 4x)"
    - "Marquee works correctly when canvas is panned away from origin"
  artifacts:
    - path: "src/components/Canvas/hooks/useMarquee.ts"
      provides: "Corrected coordinate transformation for marquee"
      contains: "getBoundingClientRect"
  key_links:
    - from: "useMarquee.ts screenToCanvas"
      to: "Canvas transform container"
      via: "Coordinate conversion accounting for pan offset and scale"
      pattern: "offsetX|offsetY|scale"
---

<objective>
Fix the marquee selection position offset bug where clicking in the middle of the canvas causes the marquee to start in the upper-left corner instead of at the click position.

Purpose: Users reported that marquee selection starts at the wrong position, making it impossible to select elements by dragging a box around them. This breaks a core selection workflow.

Output: Corrected `useMarquee.ts` with proper coordinate conversion that accounts for the canvas transform hierarchy.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Source files
@src/components/Canvas/hooks/useMarquee.ts
@src/components/Canvas/Canvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Diagnose coordinate conversion issue</name>
  <files>src/components/Canvas/hooks/useMarquee.ts</files>
  <action>
Analyze the coordinate conversion logic in `screenToCanvas`:

Current implementation:
```typescript
const rect = canvasRef.current?.getBoundingClientRect()
const relX = screenX - rect.left
const relY = screenY - rect.top
const canvasX = (relX - offsetX) / scale
const canvasY = (relY - offsetY) / scale
```

The bug: `getBoundingClientRect()` returns the VISUAL position of the canvas background element, which already includes the CSS transform (`translate(offsetX, offsetY) scale(scale)`). When we then subtract `offsetX` and `offsetY` again, we're double-applying the offset.

The fix: The `rect.left` and `rect.top` from `getBoundingClientRect()` already account for the transform. We should NOT subtract offset again. We only need to:
1. Get position relative to the canvas background element
2. Divide by scale (to get canvas-space coordinates)

Update `screenToCanvas` to:
```typescript
const screenToCanvas = useCallback(
  (screenX: number, screenY: number) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }

    // Get position relative to the canvas background (getBoundingClientRect already includes transform)
    const relX = screenX - rect.left
    const relY = screenY - rect.top

    // Only divide by scale - the rect already accounts for translation
    const canvasX = relX / scale
    const canvasY = relY / scale

    return { x: canvasX, y: canvasY }
  },
  [scale, canvasRef]
)
```

Note: Remove `offsetX` and `offsetY` from the dependency array since they're no longer used in the calculation.
  </action>
  <verify>
Run `npm run dev` and test:
1. At zoom 100% with canvas at origin: Click in center of canvas, marquee should start at click position
2. Pan canvas to the right/down: Click in center of visible canvas, marquee should start at click position
3. Zoom to 200%: Click in center, marquee should start at click position
4. Zoom to 50% with pan: Click in center, marquee should start at click position
  </verify>
  <done>Marquee rectangle starts exactly at the mouse click position regardless of zoom level or pan offset</done>
</task>

<task type="auto">
  <name>Task 2: Verify marquee element selection still works</name>
  <files>src/components/Canvas/hooks/useMarquee.ts</files>
  <action>
After fixing the coordinate conversion, verify that the element intersection detection still works correctly.

The `handleMouseMove` function uses `marquee.startX/startY` and the current position to calculate the marquee rectangle for intersection testing. Since both start and current positions now use the corrected `screenToCanvas`, the intersection math should work correctly.

Test the intersection detection:
1. Create multiple elements on canvas
2. Draw marquee around one element - only that element should be selected
3. Draw marquee around multiple elements - all should be selected
4. Draw marquee that doesn't touch any element - no selection change

If any issues are found with selection, review the `intersectRect` utility and the element bounds calculation in `handleMouseMove`.
  </action>
  <verify>
1. Add 3-4 elements scattered on canvas
2. Drag marquee around a single element - verify it gets selected
3. Drag marquee around multiple elements - verify all get selected
4. Drag marquee in empty area - verify selection is preserved (not cleared)
5. Test at different zoom levels (50%, 100%, 200%)
  </verify>
  <done>Marquee selection correctly selects elements that intersect with the marquee rectangle at all zoom levels</done>
</task>

</tasks>

<verification>
1. Open the app with `npm run dev`
2. Add several elements to the canvas
3. Pan the canvas so it's not at origin
4. Zoom to 150%
5. Click and drag to create marquee - it should start exactly at click position
6. Drag marquee around elements - they should be selected
7. Release mouse - selection should persist
</verification>

<success_criteria>
- Marquee selection starts at exact mouse click position
- Marquee works correctly at all zoom levels (25%, 50%, 100%, 200%, 400%)
- Marquee works correctly when canvas is panned
- Element selection via marquee still functions correctly
- No regressions in other selection functionality (click, shift+click)
</success_criteria>

<output>
After completion, create `.planning/phases/10-uat-bug-fixes/10-01-SUMMARY.md`
</output>
