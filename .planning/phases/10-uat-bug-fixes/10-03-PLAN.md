---
phase: 10-uat-bug-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Import/TemplateImporter.tsx
  - src/services/import/templateParser.ts
  - src/store/elementsSlice.ts
autonomous: true

must_haves:
  truths:
    - "Template import creates elements that appear on the canvas"
    - "Imported elements are visible after import completes"
    - "Imported elements are positioned at correct canvas coordinates"
    - "Imported elements are selectable after import"
    - "Import modal closes after successful import"
  artifacts:
    - path: "src/components/Import/TemplateImporter.tsx"
      provides: "Working import flow that adds elements to store"
      contains: "addElement"
    - path: "src/services/import/templateParser.ts"
      provides: "Parser that extracts correct positions from HTML/CSS"
      contains: "parseNumeric"
    - path: "src/store/elementsSlice.ts"
      provides: "addElement action that correctly adds elements to state"
      contains: "addElement"
  key_links:
    - from: "TemplateImporter handleImport"
      to: "store addElement"
      via: "forEach loop calling addElement for each parsed element"
      pattern: "addElements\\(element\\)"
    - from: "templateParser parseJUCETemplate"
      to: "element factories"
      via: "createKnob, createSlider, etc."
      pattern: "create(Knob|Slider|Button)"
---

<objective>
Fix the template import feature so that imported elements appear on the canvas at correct positions and are visible/selectable after import.

Purpose: Users reported that after importing a template, "nothing happens" - elements are supposedly created but don't appear on the canvas. This completely breaks the template import workflow.

Output: Working template import that creates visible, selectable elements at correct positions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Source files
@src/components/Import/TemplateImporter.tsx
@src/services/import/templateParser.ts
@src/store/elementsSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Debug and fix the import flow</name>
  <files>src/components/Import/TemplateImporter.tsx, src/store/elementsSlice.ts</files>
  <action>
Investigate the import flow:

1. In `TemplateImporter.tsx`, the import happens here:
```typescript
preview.elements.forEach((element) => {
  addElements(element)  // Note: variable is named addElements but calls addElement
})
```

The variable is named `addElements` but it's assigned from `state.addElement` (singular):
```typescript
const addElements = useStore((state) => state.addElement)
```

This should work, but verify the store's `addElement` action.

2. Check `elementsSlice.ts` for the `addElement` implementation. Verify:
   - It correctly adds the element to the elements array
   - It doesn't require any specific fields that might be missing from imported elements
   - It triggers a re-render of the canvas

3. Add console.log debugging to trace the flow:
```typescript
const handleImport = useCallback(() => {
  if (!preview) return

  setImporting(true)
  console.log('Importing elements:', preview.elements)

  setCanvasDimensions(preview.canvasWidth, preview.canvasHeight)
  clearSelection()

  preview.elements.forEach((element) => {
    console.log('Adding element:', element.id, element.type, element.x, element.y)
    addElements(element)
  })

  console.log('Import complete')
  setImporting(false)
  // ... rest
}, [preview, addElements, setCanvasDimensions, clearSelection, onClose])
```

4. Verify the elements are actually being added to the store by checking the Zustand devtools or adding:
```typescript
// After the forEach loop
const currentElements = useStore.getState().elements
console.log('Elements in store after import:', currentElements.length)
```
  </action>
  <verify>
1. Run `npm run dev` with browser DevTools console open
2. Click Import Template, drop an HTML file
3. Click Parse Template, then Import
4. Check console for the debug logs
5. Verify elements are being added (logs show element details)
  </verify>
  <done>Import flow correctly calls addElement for each parsed element</done>
</task>

<task type="auto">
  <name>Task 2: Verify element factory functions create valid elements</name>
  <files>src/services/import/templateParser.ts</files>
  <action>
Check the `parseJUCETemplate` function to ensure it creates valid elements:

1. Verify the element factory functions (`createKnob`, `createSlider`, etc.) receive all required properties
2. Check that `x` and `y` are being extracted correctly from CSS
3. Verify `width` and `height` have valid non-zero values

Look at the position extraction:
```typescript
const x = parseNumeric(inlineStyle.left || cssStyle.left, 0)
const y = parseNumeric(inlineStyle.top || cssStyle.top, 0)
const width = parseNumeric(inlineStyle.width || cssStyle.width, 60)
const height = parseNumeric(inlineStyle.height || cssStyle.height, 60)
```

Potential issues:
1. If elements have `position: relative` in CSS, `left/top` might not be set
2. If CSS uses different units (%, em), parseNumeric might return incorrect values
3. If elements are nested, their positions might be relative to parent containers

Add validation after parsing:
```typescript
// After creating element
console.log(`Parsed ${type}: ${name} at (${x}, ${y}) size ${width}x${height}`)

// Ensure element has valid position and size
if (x < 0 || y < 0) {
  errors.push(`Element ${name} has negative position (${x}, ${y})`)
}
if (width < 20 || height < 20) {
  errors.push(`Element ${name} has small size (${width}x${height})`)
}
```

Also verify the elements array is returned correctly:
```typescript
console.log(`parseJUCETemplate returning ${elements.length} elements`)
return {
  elements,
  canvasWidth,
  canvasHeight,
  errors,
}
```
  </action>
  <verify>
1. Create a simple test HTML file with a knob:
```html
<!DOCTYPE html>
<html>
<head><style>
#plugin-container { width: 400px; height: 300px; }
#test-knob { position: absolute; left: 100px; top: 50px; width: 60px; height: 60px; }
</style></head>
<body>
<div id="plugin-container">
  <div id="test-knob" class="knob"></div>
</div>
</body>
</html>
```
2. Import this file
3. Verify console shows "test-knob at (100, 50) size 60x60"
4. Verify the knob appears on canvas at position 100, 50
  </verify>
  <done>Template parser extracts valid positions and sizes from HTML/CSS</done>
</task>

<task type="auto">
  <name>Task 3: Ensure canvas updates after import</name>
  <files>src/components/Import/TemplateImporter.tsx</files>
  <action>
The issue might be that React isn't re-rendering after the import. Verify the store update triggers a re-render:

1. The `addElement` action in the store should be using Zustand's `set` correctly
2. The Canvas component should be subscribed to `elements` state

Check if the issue is the order of operations:
```typescript
// Current order:
setCanvasDimensions(preview.canvasWidth, preview.canvasHeight)  // Update canvas size
clearSelection()  // Clear selection
preview.elements.forEach((element) => {
  addElements(element)  // Add elements
})
```

Try batching the updates:
```typescript
const handleImport = useCallback(() => {
  if (!preview) return
  setImporting(true)

  // Update canvas dimensions first
  setCanvasDimensions(preview.canvasWidth, preview.canvasHeight)

  // Clear selection
  clearSelection()

  // Add all elements
  preview.elements.forEach((element) => {
    addElements(element)
  })

  // Close modal - do this AFTER elements are added
  setImporting(false)
  setFiles({})
  setPreview(null)
  onClose()
}, [preview, addElements, setCanvasDimensions, clearSelection, onClose])
```

If issues persist, try using React state to force a re-render, or use `flushSync` from react-dom:
```typescript
import { flushSync } from 'react-dom'

// Wrap state updates
flushSync(() => {
  preview.elements.forEach((element) => {
    addElements(element)
  })
})
```

Also check if the modal closing is racing with the state update - if `onClose` triggers a component unmount that interferes with the store update.
  </action>
  <verify>
1. Import a template with multiple elements
2. Verify elements appear on canvas immediately
3. Verify modal closes after import
4. Verify elements are selectable
5. Verify undo works (Ctrl+Z removes imported elements)
  </verify>
  <done>Canvas correctly updates to show imported elements after import completes</done>
</task>

</tasks>

<verification>
End-to-end test:
1. Create a test template file:
```html
<!DOCTYPE html>
<html>
<head>
<style>
#plugin-container { width: 500px; height: 400px; position: relative; }
#gain-knob { position: absolute; left: 50px; top: 50px; width: 80px; height: 80px; }
#volume-slider { position: absolute; left: 200px; top: 100px; width: 40px; height: 150px; }
#bypass-button { position: absolute; left: 300px; top: 50px; width: 100px; height: 40px; }
</style>
</head>
<body>
<div id="plugin-container">
  <div id="gain-knob" class="knob" data-parameter-id="gain"></div>
  <div id="volume-slider" class="slider" data-parameter-id="volume"></div>
  <div id="bypass-button" class="button">Bypass</div>
</div>
</body>
</html>
```
2. Open the app, click Import Template
3. Drop the HTML file
4. Click Parse Template - verify "Found 3 elements" appears
5. Click Import 3 Elements
6. Verify: Modal closes, canvas shows 3 elements at correct positions
7. Click each element - verify they are selectable and show correct properties
</verification>

<success_criteria>
- Template import creates visible elements on canvas
- Elements appear at correct positions matching the HTML/CSS layout
- Elements are selectable after import
- Import modal closes after successful import
- Imported elements have correct type-specific properties
- Undo correctly removes imported elements
</success_criteria>

<output>
After completion, create `.planning/phases/10-uat-bug-fixes/10-03-SUMMARY.md`
</output>
