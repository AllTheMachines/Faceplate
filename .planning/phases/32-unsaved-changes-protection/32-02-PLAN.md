---
phase: 32-unsaved-changes-protection
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - src/components/project/SaveLoadPanel.tsx
  - src/components/dialogs/UnsavedChangesDialog.tsx
  - src/components/Layout/LeftPanel.tsx
  - src/buildInfo.ts
autonomous: true

must_haves:
  truths:
    - "Save button changes to orange/amber when project has unsaved changes"
    - "Save button returns to blue after successful save"
    - "Browser shows warning dialog when closing/refreshing with unsaved changes"
    - "Warning dialog appears when loading project/template with unsaved changes"
    - "Warning dialog offers Save / Don't Save / Cancel options"
    - "Asterisk disappears from document title after save"
  artifacts:
    - path: "src/components/dialogs/UnsavedChangesDialog.tsx"
      provides: "3-option warning dialog (Save/Don't Save/Cancel)"
      exports: ["UnsavedChangesDialog"]
    - path: "src/components/project/SaveLoadPanel.tsx"
      provides: "Updated save button with dirty state indicator + warning integration"
      min_lines: 200
  key_links:
    - from: "src/components/project/SaveLoadPanel.tsx"
      to: "src/store/index.ts"
      via: "setSavedState call after save"
      pattern: "setSavedState"
    - from: "src/components/project/SaveLoadPanel.tsx"
      to: "src/components/dialogs/UnsavedChangesDialog.tsx"
      via: "dialog trigger on load"
      pattern: "UnsavedChangesDialog"
---

<objective>
Complete unsaved changes protection with visual save button indicator and warning dialogs.

Purpose: Provide clear visual feedback when project has unsaved changes (orange save button) and protect users from accidental data loss when loading projects/templates or closing the browser.

Output: Orange dirty indicator on save button, UnsavedChangesDialog component, integration with load project and load template flows.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-unsaved-changes-protection/32-CONTEXT.md
@.planning/phases/32-unsaved-changes-protection/32-RESEARCH.md
@.planning/phases/32-unsaved-changes-protection/32-01-SUMMARY.md
@src/store/index.ts
@src/components/project/SaveLoadPanel.tsx
@src/components/dialogs/NewProjectDialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UnsavedChangesDialog component</name>
  <files>src/components/dialogs/UnsavedChangesDialog.tsx</files>
  <action>
Create `src/components/dialogs/UnsavedChangesDialog.tsx` following existing dialog patterns (NewProjectDialog.tsx):

```typescript
import React from 'react'

interface UnsavedChangesDialogProps {
  isOpen: boolean
  onSave: () => void      // User chose to save first
  onDiscard: () => void   // User chose to continue without saving
  onCancel: () => void    // User cancelled the action
  actionDescription?: string  // e.g., "loading a new project"
}

export const UnsavedChangesDialog: React.FC<UnsavedChangesDialogProps> = ({
  isOpen,
  onSave,
  onDiscard,
  onCancel,
  actionDescription = 'continuing',
}) => {
  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-[400px]">
        <h2 className="text-xl font-bold mb-4 text-white">Unsaved Changes</h2>
        <p className="text-gray-300 text-sm mb-6">
          You have unsaved changes. Save before {actionDescription}?
        </p>

        <div className="flex gap-3">
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded text-white text-sm"
          >
            Cancel
          </button>
          <button
            onClick={onDiscard}
            className="flex-1 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded text-white text-sm"
          >
            Don't Save
          </button>
          <button
            onClick={onSave}
            className="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white text-sm font-medium"
          >
            Save
          </button>
        </div>
      </div>
    </div>
  )
}
```

Key design decisions per CONTEXT.md:
- 3-option pattern: Save / Don't Save / Cancel
- Primary (blue highlighted) button: Save
- Neutral/informative tone
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>UnsavedChangesDialog component exists with 3-button pattern</done>
</task>

<task type="auto">
  <name>Task 2: Update SaveLoadPanel with dirty indicator and save state capture</name>
  <files>src/components/project/SaveLoadPanel.tsx</files>
  <action>
Update `src/components/project/SaveLoadPanel.tsx`:

1. Import dirty state from store:
   ```typescript
   const isDirty = useStore((state) => state.isDirty())
   const setSavedState = useStore((state) => state.setSavedState)
   const clearSavedState = useStore((state) => state.clearSavedState)
   ```

2. Import UnsavedChangesDialog:
   ```typescript
   import { UnsavedChangesDialog } from '../dialogs/UnsavedChangesDialog'
   ```

3. Add state for pending action and dialog:
   ```typescript
   const [pendingAction, setPendingAction] = useState<{
     type: 'load' | 'template'
     execute: () => Promise<void>
   } | null>(null)
   ```

4. Update Save button styling - use orange/amber when dirty:
   ```typescript
   className={`flex-1 flex items-center justify-center gap-2 ${
     isDirty
       ? 'bg-amber-600 hover:bg-amber-700'  // Orange when dirty
       : 'bg-blue-600 hover:bg-blue-700'    // Blue when clean
   } disabled:bg-gray-600 text-white px-3 py-2 rounded text-sm font-medium transition-colors`}
   ```

5. Update handleSave to capture snapshot AFTER successful save:
   ```typescript
   const handleSave = async () => {
     setLoading(true)
     setError(null)

     try {
       // Capture current state snapshot BEFORE save (to compare against)
       const currentSnapshot = JSON.stringify({
         elements,
         canvasWidth,
         canvasHeight,
         backgroundColor,
         backgroundType,
         gradientConfig,
         snapToGrid,
         gridSize,
         assets,
         knobStyles,
       })

       const json = serializeProject({ ... })
       await saveProjectFile(json)

       // After successful save, update saved state
       const timestamp = Date.now()
       setSavedState(currentSnapshot, timestamp)
       setLastModified(timestamp)
     } catch (err) {
       setError(err instanceof Error ? err.message : 'Failed to save project')
     } finally {
       setLoading(false)
     }
   }
   ```

6. Wrap handleLoad to check dirty state first:
   ```typescript
   const handleLoadClick = () => {
     if (isDirty) {
       setPendingAction({
         type: 'load',
         execute: handleLoad,
       })
     } else {
       handleLoad()
     }
   }
   ```

7. Wrap handleLoadTemplate to check dirty state:
   ```typescript
   const handleLoadTemplateClick = async (templateId: string) => {
     if (!templateId) return

     if (isDirty) {
       setPendingAction({
         type: 'template',
         execute: () => handleLoadTemplate(templateId),
       })
     } else {
       handleLoadTemplate(templateId)
     }
   }
   ```

8. Update handleLoad to call clearSavedState after loading (new project has no saved state):
   After successful load, call `setSavedState(snapshot, loadedTimestamp)` where snapshot is the loaded state and timestamp is from the loaded file (data.lastModified).

9. Add dialog handlers:
   ```typescript
   const handleDialogSave = async () => {
     await handleSave()
     if (pendingAction) {
       await pendingAction.execute()
     }
     setPendingAction(null)
   }

   const handleDialogDiscard = async () => {
     if (pendingAction) {
       await pendingAction.execute()
     }
     setPendingAction(null)
   }

   const handleDialogCancel = () => {
     setPendingAction(null)
   }
   ```

10. Render UnsavedChangesDialog at end of component:
    ```typescript
    <UnsavedChangesDialog
      isOpen={pendingAction !== null}
      onSave={handleDialogSave}
      onDiscard={handleDialogDiscard}
      onCancel={handleDialogCancel}
      actionDescription={
        pendingAction?.type === 'load'
          ? 'loading a project'
          : 'loading a template'
      }
    />
    ```

11. Update button onClick handlers to use the wrapped versions:
    - Save button: still `onClick={handleSave}` (no change needed)
    - Load button: `onClick={handleLoadClick}`
    - Template dropdown: `onChange={(e) => handleLoadTemplateClick(e.target.value)}`
  </action>
  <verify>
1. `npm run build` compiles
2. Run `npm run dev`:
   - Add element, save button turns orange
   - Click Save, button returns to blue
   - Add another element, try to load project - dialog appears
  </verify>
  <done>Save button shows orange when dirty, warning dialog appears before load operations</done>
</task>

<task type="auto">
  <name>Task 3: Update LeftPanel Import Template to check dirty state + update buildInfo</name>
  <files>src/components/Layout/LeftPanel.tsx, src/components/Import/TemplateImporter.tsx, src/buildInfo.ts</files>
  <action>
1. Check if TemplateImporter needs dirty state protection:
   - Read `src/components/Import/TemplateImporter.tsx` to understand its flow
   - If it loads templates that would overwrite canvas, add similar protection:
     - Pass `isDirty` and a callback to handle the unsaved changes flow
     - OR: Delegate to SaveLoadPanel pattern

   If TemplateImporter just opens a dialog, dirty check can happen when user confirms template selection inside the importer. Add prop `onLoadWithCheck` that handles dirty state.

   Alternatively, keep it simple: TemplateImporter already has its own "Import" confirmation button - add UnsavedChangesDialog inside TemplateImporter if isDirty is true when user clicks Import.

2. Update `src/buildInfo.ts` with current timestamp:
   ```typescript
   export const lastUpdated = '27 Jan HH:MM CET'
   ```
   (Replace HH:MM with actual time when executing)

Note: LeftPanel no longer uses buildInfo for display (replaced with "Last saved" in Plan 01), but other parts of app may still reference it. Keep buildInfo.ts updated per CLAUDE.md instructions.
  </action>
  <verify>
1. `npm run build` compiles
2. Open Template Importer with unsaved changes - appropriate warning appears
  </verify>
  <done>Template import flow is protected against unsaved changes loss</done>
</task>

</tasks>

<verification>
**Full phase verification (all 4 success criteria):**

1. **Visual indicator when dirty:**
   - Add element -> Save button turns orange
   - Save project -> Save button turns blue
   - Add another element -> Save button turns orange again

2. **Browser beforeunload warning:**
   - Add element (dirty state)
   - Try to close browser tab or press F5
   - Browser shows native "Leave site?" warning

3. **Warning dialog for load operations:**
   - Add element (dirty state)
   - Click "Load Project" -> UnsavedChangesDialog appears
   - Test "Cancel" -> Dialog closes, nothing loads
   - Test "Don't Save" -> Project loads, unsaved work lost
   - Test "Save" -> Project saves, then loads
   - Same flow for "Load Template" dropdown

4. **Last saved indicator:**
   - Fresh project shows "Never saved"
   - Save project -> Shows "Last saved: less than a minute ago"
   - Wait 1+ minute -> Shows "Last saved: 1 minute ago"
   - Document title asterisk appears/disappears correctly
</verification>

<success_criteria>
- Save button is orange/amber (bg-amber-600) when isDirty is true
- Save button is blue (bg-blue-600) when isDirty is false
- UnsavedChangesDialog appears before loading project or template when dirty
- Dialog provides Save/Don't Save/Cancel with correct behavior
- Browser beforeunload triggers when closing with unsaved changes
- Document title asterisk clears after successful save
- "Last saved" indicator updates after save with relative time
</success_criteria>

<output>
After completion, create `.planning/phases/32-unsaved-changes-protection/32-02-SUMMARY.md`
</output>
