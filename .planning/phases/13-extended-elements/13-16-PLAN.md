---
phase: 13-extended-elements
plan: 16
type: execute
wave: 1
depends_on: []
files_modified:
  - src/App.tsx
  - src/components/Palette/PaletteItem.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Drag preview shown at mouse cursor while dragging from palette"
    - "Preview matches the element type being dragged"
    - "Preview disappears when drag ends"
  artifacts:
    - path: "src/App.tsx"
      provides: "DragOverlay with element preview"
      contains: "DragOverlay"
  key_links:
    - from: "src/App.tsx"
      to: "@dnd-kit/core DragOverlay"
      via: "import and render"
      pattern: "DragOverlay"
---

<objective>
Add drag preview overlay that shows element preview at mouse cursor during palette drag.

Purpose: Improve UX by showing a visual preview of the element being dragged, following the mouse cursor. This is a common drag-and-drop pattern that helps users understand what they're about to place.

Output: Visual preview follows mouse during palette drag operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/App.tsx
@src/components/Palette/PaletteItem.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DragOverlay with element preview</name>
  <files>src/App.tsx</files>
  <action>
1. Import DragOverlay and useDndMonitor from @dnd-kit/core:
```typescript
import {
  DndContext,
  DragEndEvent,
  DragMoveEvent,
  DragOverlay,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core'
```

2. Add state to track active drag:
```typescript
import { useState } from 'react'

// Inside App component:
const [activeDragData, setActiveDragData] = useState<{
  elementType: string
  variant?: Record<string, unknown>
} | null>(null)
```

3. Add handleDragStart to capture drag data:
```typescript
const handleDragStart = (event: DragStartEvent) => {
  const { active } = event
  const sourceType = active.data.current?.sourceType

  // Only show overlay for palette drags, not element moves
  if (sourceType !== 'element') {
    const { elementType, variant } = active.data.current || {}
    if (elementType) {
      setActiveDragData({ elementType, variant })
    }
  }
}
```

4. Update handleDragEnd to clear the drag data:
```typescript
// At the end of handleDragEnd, clear drag state
setActiveDragData(null)
```

5. Add DragStartEvent to imports and add onDragStart to DndContext:
```typescript
<DndContext
  sensors={sensors}
  onDragStart={handleDragStart}
  onDragMove={handleDragMove}
  onDragEnd={handleDragEnd}
>
```

6. Add DragOverlay component inside DndContext, after ThreePanelLayout:
```typescript
<DragOverlay dropAnimation={null}>
  {activeDragData && (
    <DragPreview
      elementType={activeDragData.elementType}
      variant={activeDragData.variant}
    />
  )}
</DragOverlay>
```

7. Create DragPreview component in the same file (before App function) that renders a preview based on element type. Import the necessary renderers and create functions from PaletteItem.tsx pattern:
```typescript
// Import renderers at top of file
import { KnobRenderer } from './components/elements/renderers/KnobRenderer'
// ... other renderers as needed

function DragPreview({
  elementType,
  variant
}: {
  elementType: string
  variant?: Record<string, unknown>
}) {
  // Create preview element similar to PaletteItem
  const previewElement = createPreviewElement(elementType, variant)
  if (!previewElement) return null

  return (
    <div
      style={{
        opacity: 0.8,
        pointerEvents: 'none',
        width: previewElement.width,
        height: previewElement.height,
      }}
    >
      {/* Render appropriate renderer based on type */}
    </div>
  )
}
```

NOTE: For simplicity, the DragPreview can show a simple styled box with the element type name if importing all renderers is too complex. A minimal viable implementation:

```typescript
function DragPreview({
  elementType,
  variant
}: {
  elementType: string
  variant?: Record<string, unknown>
}) {
  return (
    <div
      className="bg-gray-700 border border-blue-500 rounded px-3 py-2 shadow-lg"
      style={{
        opacity: 0.9,
        pointerEvents: 'none',
      }}
    >
      <span className="text-sm text-white capitalize">{elementType}</span>
    </div>
  )
}
```

The simpler approach is recommended to avoid duplicating the complex preview rendering logic from PaletteItem.tsx.
  </action>
  <verify>
1. Run `npm run dev`
2. Drag any element from palette - preview should appear at cursor
3. Move mouse while dragging - preview should follow
4. Drop element on canvas - preview should disappear
5. Drag element already on canvas (element move) - NO overlay should appear (existing behavior preserved)
  </verify>
  <done>Drag preview overlay shows element type indicator at mouse cursor during palette drags. Preview disappears when drag ends or is cancelled.</done>
</task>

</tasks>

<verification>
1. npm run dev succeeds with no errors
2. Dragging from palette shows visual preview at cursor
3. Preview follows mouse during drag
4. Preview disappears on drop or cancel
5. Element moves on canvas do NOT show overlay (no regression)
</verification>

<success_criteria>
- DragOverlay renders during palette drags
- Preview follows mouse cursor position
- Preview shows element type being dragged
- No interference with existing element drag behavior
- Clean disappearance on drag end
</success_criteria>

<output>
After completion, create `.planning/phases/13-extended-elements/13-16-SUMMARY.md`
</output>
