---
phase: 13-extended-elements
plan: 12
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Properties/DropdownProperties.tsx
  - src/components/Properties/RadioGroupProperties.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can add new options to Dropdown by pressing Enter in textarea"
    - "User can add new options to Radio Group by pressing Enter in textarea"
    - "Options are preserved while typing, including empty lines"
    - "Empty lines are filtered only when user leaves the textarea"
  artifacts:
    - path: "src/components/Properties/DropdownProperties.tsx"
      provides: "Dropdown options textarea with local state"
      contains: "useState"
    - path: "src/components/Properties/RadioGroupProperties.tsx"
      provides: "RadioGroup options textarea with local state"
      contains: "useState"
  key_links:
    - from: "textarea onChange"
      to: "local state"
      via: "setLocalOptions"
      pattern: "setLocalOptions.*e\\.target\\.value"
    - from: "textarea onBlur"
      to: "onUpdate"
      via: "filter and update"
      pattern: "onBlur.*filter"
---

<objective>
Fix textarea editing in Dropdown and RadioGroup property panels

Purpose: The current implementation filters empty lines on every keystroke, making it impossible to press Enter to add new options. Users need to be able to type multiple options on separate lines.

Output: Dropdown and RadioGroup property panels with editable textareas that preserve newlines during typing and only filter on blur.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-extended-elements/13-UAT.md

Root cause from UAT diagnosis:
- DropdownProperties.tsx line 19: onChange immediately filters empty lines with `.filter((line) => line.trim() !== '')`
- RadioGroupProperties.tsx line 19: Same issue - filters empty lines immediately
- This prevents users from pressing Enter to add new lines

Fix pattern: Use local state to store raw text during editing, only filter when blur occurs.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DropdownProperties textarea</name>
  <files>src/components/Properties/DropdownProperties.tsx</files>
  <action>
Refactor the options textarea to use local state:

1. Add React useState import
2. Create local state for raw textarea content:
   - Initialize from `element.options.join('\n')`
   - Use `useEffect` to sync when element.options changes externally (e.g., different element selected)

3. Change textarea handlers:
   - `value`: Use local state instead of `element.options.join('\n')`
   - `onChange`: Set local state directly (no filtering)
   - `onBlur`: Filter empty lines and call onUpdate with filtered options

Implementation pattern:
```tsx
import { useState, useEffect } from 'react'

// Inside component:
const [localOptions, setLocalOptions] = useState(element.options.join('\n'))

// Sync when element changes (different element selected)
useEffect(() => {
  setLocalOptions(element.options.join('\n'))
}, [element.id, element.options])

// In textarea:
value={localOptions}
onChange={(e) => setLocalOptions(e.target.value)}
onBlur={() => {
  const options = localOptions.split('\n').filter((line) => line.trim() !== '')
  if (options.length === 0) options.push('Option 1')
  onUpdate({ options })
}}
```

Keep the rest of the component unchanged (appearance section, selected index dropdown).
  </action>
  <verify>
1. `npm run build` completes without errors
2. Manual test: Add Dropdown, edit options textarea, press Enter - newline is preserved while typing
3. Click outside textarea - empty lines are filtered
  </verify>
  <done>User can type newlines in Dropdown options textarea; filtering only occurs on blur</done>
</task>

<task type="auto">
  <name>Task 2: Fix RadioGroupProperties textarea</name>
  <files>src/components/Properties/RadioGroupProperties.tsx</files>
  <action>
Apply the same fix pattern as DropdownProperties:

1. Add React useState and useEffect imports
2. Create local state for raw textarea content
3. Add useEffect to sync when element changes
4. Change textarea handlers to use local state and filter on blur

Implementation pattern (identical to Dropdown):
```tsx
import { useState, useEffect } from 'react'

// Inside component:
const [localOptions, setLocalOptions] = useState(element.options.join('\n'))

useEffect(() => {
  setLocalOptions(element.options.join('\n'))
}, [element.id, element.options])

// In textarea:
value={localOptions}
onChange={(e) => setLocalOptions(e.target.value)}
onBlur={() => {
  const options = localOptions.split('\n').filter((line) => line.trim() !== '')
  if (options.length === 0) options.push('Option 1')
  onUpdate({ options })
}}
```

Keep the rest of the component unchanged (layout section, appearance section).
  </action>
  <verify>
1. `npm run build` completes without errors
2. Manual test: Add RadioGroup, edit options textarea, press Enter - newline is preserved while typing
3. Click outside textarea - empty lines are filtered
  </verify>
  <done>User can type newlines in RadioGroup options textarea; filtering only occurs on blur</done>
</task>

</tasks>

<verification>
1. `npm run build` - No TypeScript errors
2. `npm run lint` - No ESLint errors
3. Manual verification:
   - Add Dropdown element, verify options textarea is editable
   - Press Enter to add new lines, verify they stay while typing
   - Click away, verify empty lines are removed
   - Repeat for RadioGroup element
</verification>

<success_criteria>
- Dropdown options textarea accepts Enter key and preserves newlines while editing
- RadioGroup options textarea accepts Enter key and preserves newlines while editing
- Empty lines are filtered on blur (not on every keystroke)
- Both components still correctly update the element when user finishes editing
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-extended-elements/13-12-SUMMARY.md`
</output>
