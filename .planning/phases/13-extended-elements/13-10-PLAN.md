---
phase: 13-extended-elements
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements.ts
  - src/components/elements/Element.tsx
  - src/components/elements/renderers/ModulationMatrixRenderer.tsx
  - src/components/Properties/ModulationMatrixProperties.tsx
  - src/components/Properties/PropertyPanel.tsx
  - src/components/Palette/Palette.tsx
  - src/services/export/htmlGenerator.ts
  - src/services/export/cssGenerator.ts
autonomous: true

must_haves:
  truths:
    - "User can add Modulation Matrix placeholder element"
    - "Matrix displays configurable rows (sources) and columns (destinations)"
    - "Matrix cells show placeholder state (filled/empty)"
    - "Property panel allows configuring source and destination labels"
    - "Element exports with table structure for JUCE integration"
  artifacts:
    - path: "src/types/elements.ts"
      provides: "ModulationMatrixElementConfig interface"
      contains: "type: 'modulationmatrix'"
    - path: "src/components/elements/renderers/ModulationMatrixRenderer.tsx"
      provides: "Grid-based modulation matrix rendering"
      contains: "sources"
  key_links:
    - from: "src/services/export/htmlGenerator.ts"
      to: "HTML"
      via: "table structure with data-source, data-destination attributes"
---

<objective>
Add Modulation Matrix placeholder widget for source/destination routing.

Purpose: Synthesizers and complex effects need modulation routing matrices. Phase 13 creates a configurable placeholder - actual routing logic is in JUCE. This is requirement ELEM-12.

Output:
- ModulationMatrixElementConfig type with source/destination labels
- Grid-based renderer showing routing table
- Property panel for configuring labels
- Palette entry in new "Complex Widgets" category
- Export with table structure for JUCE integration

NOTE: This is a PLACEHOLDER. Actual modulation routing requires JUCE backend integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-extended-elements/13-CONTEXT.md
@.planning/phases/13-extended-elements/13-RESEARCH.md

@src/types/elements.ts
@src/components/elements/Element.tsx
@src/components/Properties/PropertyPanel.tsx
@src/components/Palette/Palette.tsx
@src/services/export/htmlGenerator.ts
@src/services/export/cssGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ModulationMatrixElementConfig type</name>
  <files>src/types/elements.ts</files>
  <action>
Add ModulationMatrixElementConfig interface:
```typescript
export interface ModulationMatrixElementConfig extends BaseElementConfig {
  type: 'modulationmatrix'

  // Sources (rows) - modulation sources like LFO1, ENV1, etc.
  sources: string[]

  // Destinations (columns) - modulation targets like Pitch, Filter, Amp, etc.
  destinations: string[]

  // Cell styling
  cellSize: number  // Size of each cell in pixels
  cellColor: string  // Background of cells
  activeColor: string  // Color when cell is "connected"
  borderColor: string

  // Header styling
  headerBackground: string
  headerColor: string
  headerFontSize: number

  // For preview: which cells are "active" (index pairs)
  // In real use, JUCE provides this data
  previewActiveConnections: Array<[number, number]>  // [sourceIndex, destIndex]
}
```

Update ElementConfig union.

Add type guard:
```typescript
export function isModulationMatrix(element: ElementConfig): element is ModulationMatrixElementConfig {
  return element.type === 'modulationmatrix'
}
```

Add factory function:
```typescript
export function createModulationMatrix(overrides?: Partial<ModulationMatrixElementConfig>): ModulationMatrixElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'modulationmatrix',
    name: 'Mod Matrix',
    x: 0, y: 0,
    width: 280, height: 180,
    rotation: 0, zIndex: 0,
    locked: false, visible: true,
    sources: ['LFO 1', 'LFO 2', 'ENV 1', 'ENV 2'],
    destinations: ['Pitch', 'Filter', 'Amp', 'Pan'],
    cellSize: 28,
    cellColor: '#1f2937',
    activeColor: '#3b82f6',
    borderColor: '#374151',
    headerBackground: '#111827',
    headerColor: '#9ca3af',
    headerFontSize: 10,
    previewActiveConnections: [[0, 1], [2, 0]],  // LFO1->Filter, ENV1->Pitch
    ...overrides,
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ModulationMatrixElementConfig type defined with type guard and factory function</done>
</task>

<task type="auto">
  <name>Task 2: Create ModulationMatrixRenderer and update Element switch</name>
  <files>
src/components/elements/renderers/ModulationMatrixRenderer.tsx
src/components/elements/Element.tsx
  </files>
  <action>
Create ModulationMatrixRenderer.tsx:
```tsx
import type { ModulationMatrixElementConfig } from '../../../types/elements'

interface ModulationMatrixRendererProps {
  config: ModulationMatrixElementConfig
}

export function ModulationMatrixRenderer({ config }: ModulationMatrixRendererProps) {
  const isActive = (sourceIdx: number, destIdx: number) => {
    return config.previewActiveConnections.some(
      ([s, d]) => s === sourceIdx && d === destIdx
    )
  }

  return (
    <div
      className="modulationmatrix-element"
      style={{
        width: '100%',
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
        border: `1px solid ${config.borderColor}`,
        borderRadius: '4px',
        backgroundColor: config.cellColor,
      }}
    >
      {/* Header row with destination labels */}
      <div
        style={{
          display: 'flex',
          backgroundColor: config.headerBackground,
          borderBottom: `1px solid ${config.borderColor}`,
        }}
      >
        {/* Empty corner cell */}
        <div
          style={{
            width: `${config.cellSize * 1.5}px`,
            minWidth: `${config.cellSize * 1.5}px`,
            height: `${config.cellSize}px`,
            borderRight: `1px solid ${config.borderColor}`,
          }}
        />
        {/* Destination headers */}
        {config.destinations.map((dest, idx) => (
          <div
            key={idx}
            style={{
              width: `${config.cellSize}px`,
              minWidth: `${config.cellSize}px`,
              height: `${config.cellSize}px`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: `${config.headerFontSize}px`,
              color: config.headerColor,
              borderRight: `1px solid ${config.borderColor}`,
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
              padding: '2px',
            }}
            title={dest}
          >
            {dest.slice(0, 3)}
          </div>
        ))}
      </div>

      {/* Matrix rows */}
      <div style={{ flex: 1, overflow: 'auto' }}>
        {config.sources.map((source, sourceIdx) => (
          <div
            key={sourceIdx}
            style={{
              display: 'flex',
              borderBottom: `1px solid ${config.borderColor}`,
            }}
          >
            {/* Source label */}
            <div
              style={{
                width: `${config.cellSize * 1.5}px`,
                minWidth: `${config.cellSize * 1.5}px`,
                height: `${config.cellSize}px`,
                display: 'flex',
                alignItems: 'center',
                paddingLeft: '4px',
                fontSize: `${config.headerFontSize}px`,
                color: config.headerColor,
                backgroundColor: config.headerBackground,
                borderRight: `1px solid ${config.borderColor}`,
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
              }}
              title={source}
            >
              {source}
            </div>

            {/* Matrix cells */}
            {config.destinations.map((_, destIdx) => {
              const active = isActive(sourceIdx, destIdx)
              return (
                <div
                  key={destIdx}
                  style={{
                    width: `${config.cellSize}px`,
                    minWidth: `${config.cellSize}px`,
                    height: `${config.cellSize}px`,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    borderRight: `1px solid ${config.borderColor}`,
                    backgroundColor: active ? config.activeColor : 'transparent',
                  }}
                >
                  {active && (
                    <div
                      style={{
                        width: '8px',
                        height: '8px',
                        borderRadius: '50%',
                        backgroundColor: '#fff',
                      }}
                    />
                  )}
                </div>
              )
            })}
          </div>
        ))}
      </div>
    </div>
  )
}
```

Update Element.tsx:
1. Import ModulationMatrixRenderer
2. Add case:
```tsx
case 'modulationmatrix':
  return <ModulationMatrixRenderer config={element} />
```
  </action>
  <verify>TypeScript compiles and modulation matrix renders with sources, destinations, and preview connections</verify>
  <done>ModulationMatrixRenderer shows grid table with headers and active connections; Element.tsx routes correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add property panel, palette entry, and export</name>
  <files>
src/components/Properties/ModulationMatrixProperties.tsx
src/components/Properties/PropertyPanel.tsx
src/components/Palette/Palette.tsx
src/services/export/htmlGenerator.ts
src/services/export/cssGenerator.ts
  </files>
  <action>
Create ModulationMatrixProperties.tsx:
```tsx
import { PropertySection } from './PropertySection'
import { NumberInput } from './NumberInput'
import { ColorInput } from './ColorInput'
import type { ModulationMatrixElementConfig, ElementConfig } from '../../types/elements'

interface ModulationMatrixPropertiesProps {
  element: ModulationMatrixElementConfig
  onUpdate: (updates: Partial<ElementConfig>) => void
}

export function ModulationMatrixProperties({ element, onUpdate }: ModulationMatrixPropertiesProps) {
  const handleSourcesChange = (text: string) => {
    const sources = text.split('\n').filter(line => line.trim() !== '')
    onUpdate({ sources })
  }

  const handleDestinationsChange = (text: string) => {
    const destinations = text.split('\n').filter(line => line.trim() !== '')
    onUpdate({ destinations })
  }

  return (
    <>
      <PropertySection title="Sources (Rows)">
        <div>
          <label className="block text-xs text-gray-400 mb-1">Sources (one per line)</label>
          <textarea
            value={element.sources.join('\n')}
            onChange={(e) => handleSourcesChange(e.target.value)}
            className="w-full bg-gray-700 border border-gray-600 text-white rounded px-2 py-1.5 text-sm"
            rows={4}
          />
        </div>
      </PropertySection>

      <PropertySection title="Destinations (Columns)">
        <div>
          <label className="block text-xs text-gray-400 mb-1">Destinations (one per line)</label>
          <textarea
            value={element.destinations.join('\n')}
            onChange={(e) => handleDestinationsChange(e.target.value)}
            className="w-full bg-gray-700 border border-gray-600 text-white rounded px-2 py-1.5 text-sm"
            rows={4}
          />
        </div>
      </PropertySection>

      <PropertySection title="Cell Styling">
        <NumberInput
          label="Cell Size"
          value={element.cellSize}
          onChange={(cellSize) => onUpdate({ cellSize })}
          min={20}
          max={50}
        />
        <ColorInput
          label="Cell Background"
          value={element.cellColor}
          onChange={(cellColor) => onUpdate({ cellColor })}
        />
        <ColorInput
          label="Active Color"
          value={element.activeColor}
          onChange={(activeColor) => onUpdate({ activeColor })}
        />
        <ColorInput
          label="Border Color"
          value={element.borderColor}
          onChange={(borderColor) => onUpdate({ borderColor })}
        />
      </PropertySection>

      <PropertySection title="Header Styling">
        <ColorInput
          label="Background"
          value={element.headerBackground}
          onChange={(headerBackground) => onUpdate({ headerBackground })}
        />
        <ColorInput
          label="Text Color"
          value={element.headerColor}
          onChange={(headerColor) => onUpdate({ headerColor })}
        />
        <NumberInput
          label="Font Size"
          value={element.headerFontSize}
          onChange={(headerFontSize) => onUpdate({ headerFontSize })}
          min={8}
          max={14}
        />
      </PropertySection>
    </>
  )
}
```

Update PropertyPanel.tsx with case for modulationmatrix.

Update Palette.tsx - add new category:
```typescript
{
  name: 'Complex Widgets',
  items: [
    { id: 'modulationmatrix', type: 'modulationmatrix', name: 'Mod Matrix' },
  ],
},
```

Update htmlGenerator.ts:
```typescript
case 'modulationmatrix':
  const sourcesData = element.sources.map(s => escapeHTML(s)).join(',')
  const destsData = element.destinations.map(d => escapeHTML(d)).join(',')
  return `<div id="${id}" class="${baseClass} modulationmatrix-element" data-type="modulationmatrix" data-sources="${sourcesData}" data-destinations="${destsData}" style="${positionStyle}">
    <div class="modmatrix-placeholder">Modulation Matrix</div>
  </div>`
```

Update cssGenerator.ts with modulation matrix styles.
  </action>
  <verify>
1. Run `npm run dev`
2. Find "Complex Widgets" category in palette
3. Drag Mod Matrix to canvas
4. Verify grid displays with sources/destinations
5. In property panel, add/remove sources
6. Verify matrix updates row count
7. Export project, verify HTML contains data-sources and data-destinations
  </verify>
  <done>ModulationMatrixProperties complete; Complex Widgets category added; Export generates table structure with data attributes</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build`
2. Complex Widgets category appears in Palette with Mod Matrix
3. Matrix renders with configurable sources (rows) and destinations (columns)
4. Active connections show indicator dots
5. Property panel allows editing sources and destinations
6. Cell and header styling is configurable
7. Exported HTML contains data-sources and data-destinations attributes
8. Exported CSS contains matrix styling
</verification>

<success_criteria>
- [ ] ModulationMatrixElementConfig type exists with sources, destinations arrays
- [ ] Type guard isModulationMatrix works correctly
- [ ] Factory function createModulationMatrix has sensible defaults
- [ ] ModulationMatrixRenderer displays grid with headers
- [ ] Preview connections show as filled cells
- [ ] Element.tsx handles 'modulationmatrix' type
- [ ] ModulationMatrixProperties allows editing sources/destinations
- [ ] Palette "Complex Widgets" category contains Mod Matrix
- [ ] HTML export contains data attributes for JUCE
- [ ] CSS export generates matrix styling
</success_criteria>

<output>
After completion, create `.planning/phases/13-extended-elements/13-10-SUMMARY.md`
</output>
