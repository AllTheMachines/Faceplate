---
phase: 13-extended-elements
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements.ts
  - src/components/elements/Element.tsx
  - src/components/elements/renderers/DropdownRenderer.tsx
  - src/components/elements/renderers/CheckboxRenderer.tsx
  - src/components/elements/renderers/RadioGroupRenderer.tsx
  - src/components/Properties/DropdownProperties.tsx
  - src/components/Properties/CheckboxProperties.tsx
  - src/components/Properties/RadioGroupProperties.tsx
  - src/components/Properties/PropertyPanel.tsx
  - src/components/Palette/Palette.tsx
  - src/services/export/htmlGenerator.ts
  - src/services/export/cssGenerator.ts
autonomous: true

must_haves:
  truths:
    - "User can add Dropdown element with configurable options list"
    - "User can add Checkbox element with label in configurable position"
    - "User can add Radio Group element with multiple mutually exclusive options"
    - "Dropdown shows selected option and arrow indicator"
    - "Checkbox shows check state and label"
    - "Radio Group shows all options with correct selected state"
    - "All form controls export correctly to native HTML form elements"
  artifacts:
    - path: "src/types/elements.ts"
      provides: "DropdownElementConfig, CheckboxElementConfig, RadioGroupElementConfig interfaces"
      contains: "type: 'dropdown'"
    - path: "src/components/elements/renderers/DropdownRenderer.tsx"
      provides: "Dropdown rendering with options"
      min_lines: 25
    - path: "src/components/elements/renderers/CheckboxRenderer.tsx"
      provides: "Checkbox with label rendering"
      contains: "labelPosition"
  key_links:
    - from: "src/services/export/htmlGenerator.ts"
      to: "native HTML"
      via: "select, input[type=checkbox], input[type=radio] elements"
---

<objective>
Add form control elements (Dropdown, Checkbox, Radio Group) using native HTML form elements.

Purpose: Audio plugins need form controls for preset selection, option toggles, and mutually exclusive choices. This is requirement ELEM-09.

Output:
- Three form control element types
- Renderers using native HTML form elements
- Property panels for options configuration
- Palette category "Form Controls"
- Export to native HTML (select, checkbox, radio)

NOTE: Using native HTML form controls for accessibility, keyboard navigation, and clean JUCE export.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-extended-elements/13-CONTEXT.md
@.planning/phases/13-extended-elements/13-RESEARCH.md

@src/types/elements.ts
@src/components/elements/Element.tsx
@src/components/Properties/PropertyPanel.tsx
@src/components/Palette/Palette.tsx
@src/services/export/htmlGenerator.ts
@src/services/export/cssGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add form control element types</name>
  <files>src/types/elements.ts</files>
  <action>
Add three form control interfaces:

1. DropdownElementConfig:
```typescript
export interface DropdownElementConfig extends BaseElementConfig {
  type: 'dropdown'
  options: string[]  // List of option labels
  selectedIndex: number
  placeholder: string
  fontSize: number
  textColor: string
  backgroundColor: string
  borderColor: string
  borderRadius: number
}
```

2. CheckboxElementConfig:
```typescript
export interface CheckboxElementConfig extends BaseElementConfig {
  type: 'checkbox'
  checked: boolean
  label: string
  labelPosition: 'left' | 'right'
  fontSize: number
  textColor: string
  checkColor: string
}
```

3. RadioGroupElementConfig:
```typescript
export interface RadioGroupElementConfig extends BaseElementConfig {
  type: 'radiogroup'
  options: string[]  // List of option labels
  selectedIndex: number
  orientation: 'horizontal' | 'vertical'
  fontSize: number
  textColor: string
  checkColor: string
  gap: number  // Space between options
}
```

Update ElementConfig union to include all three.

Add type guards:
```typescript
export function isDropdown(element: ElementConfig): element is DropdownElementConfig {
  return element.type === 'dropdown'
}
export function isCheckbox(element: ElementConfig): element is CheckboxElementConfig {
  return element.type === 'checkbox'
}
export function isRadioGroup(element: ElementConfig): element is RadioGroupElementConfig {
  return element.type === 'radiogroup'
}
```

Add factory functions:
```typescript
export function createDropdown(overrides?: Partial<DropdownElementConfig>): DropdownElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'dropdown',
    name: 'Dropdown',
    x: 0, y: 0,
    width: 150, height: 32,
    rotation: 0, zIndex: 0,
    locked: false, visible: true,
    options: ['Option 1', 'Option 2', 'Option 3'],
    selectedIndex: 0,
    placeholder: 'Select...',
    fontSize: 14,
    textColor: '#ffffff',
    backgroundColor: '#374151',
    borderColor: '#4b5563',
    borderRadius: 4,
    ...overrides,
  }
}

export function createCheckbox(overrides?: Partial<CheckboxElementConfig>): CheckboxElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'checkbox',
    name: 'Checkbox',
    x: 0, y: 0,
    width: 120, height: 24,
    rotation: 0, zIndex: 0,
    locked: false, visible: true,
    checked: false,
    label: 'Checkbox',
    labelPosition: 'right',
    fontSize: 14,
    textColor: '#ffffff',
    checkColor: '#3b82f6',
    ...overrides,
  }
}

export function createRadioGroup(overrides?: Partial<RadioGroupElementConfig>): RadioGroupElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'radiogroup',
    name: 'Radio Group',
    x: 0, y: 0,
    width: 150, height: 80,
    rotation: 0, zIndex: 0,
    locked: false, visible: true,
    options: ['Option A', 'Option B', 'Option C'],
    selectedIndex: 0,
    orientation: 'vertical',
    fontSize: 14,
    textColor: '#ffffff',
    checkColor: '#3b82f6',
    gap: 8,
    ...overrides,
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Three form control element types defined with type guards and factory functions</done>
</task>

<task type="auto">
  <name>Task 2: Create form control renderers and update Element switch</name>
  <files>
src/components/elements/renderers/DropdownRenderer.tsx
src/components/elements/renderers/CheckboxRenderer.tsx
src/components/elements/renderers/RadioGroupRenderer.tsx
src/components/elements/Element.tsx
  </files>
  <action>
Create DropdownRenderer.tsx:
```tsx
import type { DropdownElementConfig } from '../../../types/elements'

interface DropdownRendererProps {
  config: DropdownElementConfig
}

export function DropdownRenderer({ config }: DropdownRendererProps) {
  return (
    <select
      className="dropdown-element"
      value={config.selectedIndex}
      readOnly
      style={{
        width: '100%',
        height: '100%',
        fontSize: `${config.fontSize}px`,
        color: config.textColor,
        backgroundColor: config.backgroundColor,
        border: `1px solid ${config.borderColor}`,
        borderRadius: `${config.borderRadius}px`,
        padding: '0 8px',
        cursor: 'pointer',
        appearance: 'none',
        backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ffffff' d='M3 4l3 4 3-4H3z'/%3E%3C/svg%3E")`,
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'right 8px center',
        pointerEvents: 'none',  // Prevent interaction in designer
      }}
    >
      {config.options.length === 0 ? (
        <option>{config.placeholder}</option>
      ) : (
        config.options.map((option, index) => (
          <option key={index} value={index}>
            {option}
          </option>
        ))
      )}
    </select>
  )
}
```

Create CheckboxRenderer.tsx:
```tsx
import type { CheckboxElementConfig } from '../../../types/elements'

interface CheckboxRendererProps {
  config: CheckboxElementConfig
}

export function CheckboxRenderer({ config }: CheckboxRendererProps) {
  return (
    <label
      className="checkbox-element"
      style={{
        width: '100%',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        flexDirection: config.labelPosition === 'left' ? 'row-reverse' : 'row',
        cursor: 'pointer',
        userSelect: 'none',
      }}
    >
      <input
        type="checkbox"
        checked={config.checked}
        readOnly
        style={{
          width: '16px',
          height: '16px',
          accentColor: config.checkColor,
          cursor: 'pointer',
          pointerEvents: 'none',
        }}
      />
      <span
        style={{
          fontSize: `${config.fontSize}px`,
          color: config.textColor,
        }}
      >
        {config.label}
      </span>
    </label>
  )
}
```

Create RadioGroupRenderer.tsx:
```tsx
import type { RadioGroupElementConfig } from '../../../types/elements'

interface RadioGroupRendererProps {
  config: RadioGroupElementConfig
}

export function RadioGroupRenderer({ config }: RadioGroupRendererProps) {
  const isVertical = config.orientation === 'vertical'

  return (
    <div
      className="radiogroup-element"
      role="radiogroup"
      style={{
        width: '100%',
        height: '100%',
        display: 'flex',
        flexDirection: isVertical ? 'column' : 'row',
        gap: `${config.gap}px`,
        alignItems: isVertical ? 'flex-start' : 'center',
      }}
    >
      {config.options.map((option, index) => (
        <label
          key={index}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '6px',
            cursor: 'pointer',
            userSelect: 'none',
          }}
        >
          <input
            type="radio"
            name={config.id}
            checked={index === config.selectedIndex}
            readOnly
            style={{
              width: '16px',
              height: '16px',
              accentColor: config.checkColor,
              cursor: 'pointer',
              pointerEvents: 'none',
            }}
          />
          <span
            style={{
              fontSize: `${config.fontSize}px`,
              color: config.textColor,
            }}
          >
            {option}
          </span>
        </label>
      ))}
    </div>
  )
}
```

Update Element.tsx:
1. Import all three renderers
2. Add cases to switch:
```tsx
case 'dropdown':
  return <DropdownRenderer config={element} />
case 'checkbox':
  return <CheckboxRenderer config={element} />
case 'radiogroup':
  return <RadioGroupRenderer config={element} />
```
  </action>
  <verify>TypeScript compiles and `npm run dev` renders form controls correctly</verify>
  <done>Three form control renderers created; Element.tsx routes correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add property panels, palette category, and export</name>
  <files>
src/components/Properties/DropdownProperties.tsx
src/components/Properties/CheckboxProperties.tsx
src/components/Properties/RadioGroupProperties.tsx
src/components/Properties/PropertyPanel.tsx
src/components/Palette/Palette.tsx
src/services/export/htmlGenerator.ts
src/services/export/cssGenerator.ts
  </files>
  <action>
Create DropdownProperties.tsx:
```tsx
import { PropertySection } from './PropertySection'
import { NumberInput } from './NumberInput'
import { ColorInput } from './ColorInput'
import { TextInput } from './TextInput'
import type { DropdownElementConfig, ElementConfig } from '../../types/elements'

interface DropdownPropertiesProps {
  element: DropdownElementConfig
  onUpdate: (updates: Partial<ElementConfig>) => void
}

export function DropdownProperties({ element, onUpdate }: DropdownPropertiesProps) {
  const handleOptionsChange = (text: string) => {
    const options = text.split('\n').filter(line => line.trim() !== '')
    onUpdate({ options })
  }

  return (
    <>
      <PropertySection title="Options">
        <div>
          <label className="block text-xs text-gray-400 mb-1">Options (one per line)</label>
          <textarea
            value={element.options.join('\n')}
            onChange={(e) => handleOptionsChange(e.target.value)}
            className="w-full bg-gray-700 border border-gray-600 text-white rounded px-2 py-1.5 text-sm"
            rows={4}
          />
        </div>
        <NumberInput
          label="Selected Index"
          value={element.selectedIndex}
          onChange={(selectedIndex) => onUpdate({ selectedIndex })}
          min={0}
          max={Math.max(0, element.options.length - 1)}
        />
        <TextInput
          label="Placeholder"
          value={element.placeholder}
          onChange={(placeholder) => onUpdate({ placeholder })}
        />
      </PropertySection>

      <PropertySection title="Appearance">
        <NumberInput
          label="Font Size"
          value={element.fontSize}
          onChange={(fontSize) => onUpdate({ fontSize })}
          min={10}
          max={24}
        />
        <ColorInput
          label="Text Color"
          value={element.textColor}
          onChange={(textColor) => onUpdate({ textColor })}
        />
        <ColorInput
          label="Background"
          value={element.backgroundColor}
          onChange={(backgroundColor) => onUpdate({ backgroundColor })}
        />
        <ColorInput
          label="Border Color"
          value={element.borderColor}
          onChange={(borderColor) => onUpdate({ borderColor })}
        />
        <NumberInput
          label="Border Radius"
          value={element.borderRadius}
          onChange={(borderRadius) => onUpdate({ borderRadius })}
          min={0}
          max={16}
        />
      </PropertySection>
    </>
  )
}
```

Create CheckboxProperties.tsx with sections:
- State: checked (checkbox)
- Label: label (TextInput), labelPosition (select left/right)
- Appearance: fontSize, textColor, checkColor

Create RadioGroupProperties.tsx with sections:
- Options: options (textarea), selectedIndex
- Layout: orientation (select), gap
- Appearance: fontSize, textColor, checkColor

Update PropertyPanel.tsx with cases for dropdown, checkbox, radiogroup.

Update Palette.tsx - add new category:
```typescript
{
  name: 'Form Controls',
  items: [
    { id: 'dropdown', type: 'dropdown', name: 'Dropdown' },
    { id: 'checkbox', type: 'checkbox', name: 'Checkbox' },
    { id: 'radiogroup', type: 'radiogroup', name: 'Radio Group' },
  ],
},
```

Update htmlGenerator.ts with cases:
```typescript
case 'dropdown':
  const optionsHTML = element.options.map((opt, i) =>
    `<option value="${i}"${i === element.selectedIndex ? ' selected' : ''}>${escapeHTML(opt)}</option>`
  ).join('\n        ')
  return `<select id="${id}" class="${baseClass} dropdown-element" data-type="dropdown" style="${positionStyle}">
        ${optionsHTML}
      </select>`

case 'checkbox':
  return `<label id="${id}" class="${baseClass} checkbox-element" data-type="checkbox" style="${positionStyle}">
      <input type="checkbox"${element.checked ? ' checked' : ''} />
      <span>${escapeHTML(element.label)}</span>
    </label>`

case 'radiogroup':
  const radioName = toKebabCase(element.name)
  const radiosHTML = element.options.map((opt, i) =>
    `<label><input type="radio" name="${radioName}"${i === element.selectedIndex ? ' checked' : ''} /><span>${escapeHTML(opt)}</span></label>`
  ).join('\n        ')
  return `<div id="${id}" class="${baseClass} radiogroup-element" data-type="radiogroup" role="radiogroup" style="${positionStyle}">
        ${radiosHTML}
      </div>`
```

Update cssGenerator.ts with cases for dropdown, checkbox, radiogroup styling.
  </action>
  <verify>
1. Run `npm run dev`
2. Find "Form Controls" category in palette
3. Drag each form control to canvas
4. Verify property panels show correct controls
5. Edit options in Dropdown properties, verify options update
6. Toggle checkbox checked state
7. Change Radio Group selection
8. Export project, verify native HTML form elements in output
  </verify>
  <done>Form control property panels complete; Palette has Form Controls category; Export generates native HTML form elements</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build`
2. Palette shows "Form Controls" category with Dropdown, Checkbox, Radio Group
3. Dropdown renders with options and arrow indicator
4. Checkbox renders with label in correct position
5. Radio Group renders all options with correct selection
6. Property panels have appropriate controls for each type
7. Exported HTML uses native form elements (select, input[checkbox], input[radio])
8. Exported CSS styles form controls appropriately
</verification>

<success_criteria>
- [ ] DropdownElementConfig, CheckboxElementConfig, RadioGroupElementConfig types exist
- [ ] Type guards work for all three types
- [ ] Factory functions have sensible defaults
- [ ] DropdownRenderer shows options and selection
- [ ] CheckboxRenderer shows check state and label
- [ ] RadioGroupRenderer shows options with correct selected state
- [ ] Element.tsx handles all three types
- [ ] Property panels allow editing options, selection, and appearance
- [ ] Palette "Form Controls" category contains all three elements
- [ ] HTML export uses native form elements
</success_criteria>

<output>
After completion, create `.planning/phases/13-extended-elements/13-04-SUMMARY.md`
</output>
