---
phase: 13-extended-elements
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements.ts
  - src/components/elements/Element.tsx
  - src/components/elements/renderers/RectangleRenderer.tsx
  - src/components/elements/renderers/LineRenderer.tsx
  - src/components/Properties/RectangleProperties.tsx
  - src/components/Properties/LineProperties.tsx
  - src/components/Properties/PropertyPanel.tsx
  - src/components/Palette/Palette.tsx
  - src/services/export/htmlGenerator.ts
  - src/services/export/cssGenerator.ts
autonomous: true

must_haves:
  truths:
    - "User can add Rectangle element with configurable fill and border"
    - "User can add Line element for visual separators"
    - "Rectangle supports fill color, border, and border radius"
    - "Line supports horizontal, vertical, and diagonal orientations"
    - "Both elements export correctly to HTML/CSS"
  artifacts:
    - path: "src/types/elements.ts"
      provides: "RectangleElementConfig and LineElementConfig interfaces"
      contains: "type: 'rectangle'"
    - path: "src/components/elements/renderers/RectangleRenderer.tsx"
      provides: "Rectangle with fill and border"
      min_lines: 15
    - path: "src/components/elements/renderers/LineRenderer.tsx"
      provides: "Line with orientation support"
      contains: "orientation"
  key_links:
    - from: "src/services/export/htmlGenerator.ts"
      to: "native HTML"
      via: "div for rectangle, hr or div for line"
---

<objective>
Add decorative elements (Rectangle, Line) for visual organization.

Purpose: Audio plugin UIs need background boxes and separators for visual organization. This is requirement ELEM-10.

Output:
- RectangleElementConfig and LineElementConfig types
- Renderers for rectangle and line
- Property panels for configuration
- Palette entries in updated "Images & Decorative" category
- Export support
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-extended-elements/13-CONTEXT.md
@.planning/phases/13-extended-elements/13-RESEARCH.md

@src/types/elements.ts
@src/components/elements/Element.tsx
@src/components/Properties/PropertyPanel.tsx
@src/components/Palette/Palette.tsx
@src/services/export/htmlGenerator.ts
@src/services/export/cssGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Rectangle and Line element types</name>
  <files>src/types/elements.ts</files>
  <action>
Add RectangleElementConfig interface:
```typescript
export interface RectangleElementConfig extends BaseElementConfig {
  type: 'rectangle'

  // Fill
  fillColor: string
  fillOpacity: number  // 0-1

  // Border
  borderWidth: number
  borderColor: string
  borderStyle: 'solid' | 'dashed' | 'dotted'
  borderRadius: number
}
```

Add LineElementConfig interface:
```typescript
export interface LineElementConfig extends BaseElementConfig {
  type: 'line'

  // Orientation (width/height determine actual line direction)
  // horizontal: width > height (line runs left-to-right)
  // vertical: height > width (line runs top-to-bottom)
  // For diagonal, use rotation

  // Style
  strokeWidth: number
  strokeColor: string
  strokeStyle: 'solid' | 'dashed' | 'dotted'
}
```

Update ElementConfig union.

Add type guards:
```typescript
export function isRectangle(element: ElementConfig): element is RectangleElementConfig {
  return element.type === 'rectangle'
}
export function isLine(element: ElementConfig): element is LineElementConfig {
  return element.type === 'line'
}
```

Add factory functions:
```typescript
export function createRectangle(overrides?: Partial<RectangleElementConfig>): RectangleElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'rectangle',
    name: 'Rectangle',
    x: 0, y: 0,
    width: 100, height: 80,
    rotation: 0, zIndex: 0,
    locked: false, visible: true,
    fillColor: '#1e293b',
    fillOpacity: 1,
    borderWidth: 1,
    borderColor: '#475569',
    borderStyle: 'solid',
    borderRadius: 0,
    ...overrides,
  }
}

export function createLine(overrides?: Partial<LineElementConfig>): LineElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'line',
    name: 'Line',
    x: 0, y: 0,
    width: 100, height: 2,  // Horizontal line by default
    rotation: 0, zIndex: 0,
    locked: false, visible: true,
    strokeWidth: 2,
    strokeColor: '#475569',
    strokeStyle: 'solid',
    ...overrides,
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>RectangleElementConfig and LineElementConfig types defined with type guards and factories</done>
</task>

<task type="auto">
  <name>Task 2: Create renderers and update Element switch</name>
  <files>
src/components/elements/renderers/RectangleRenderer.tsx
src/components/elements/renderers/LineRenderer.tsx
src/components/elements/Element.tsx
  </files>
  <action>
Create RectangleRenderer.tsx:
```tsx
import type { RectangleElementConfig } from '../../../types/elements'

interface RectangleRendererProps {
  config: RectangleElementConfig
}

export function RectangleRenderer({ config }: RectangleRendererProps) {
  return (
    <div
      className="rectangle-element"
      style={{
        width: '100%',
        height: '100%',
        backgroundColor: config.fillColor,
        opacity: config.fillOpacity,
        border: config.borderWidth > 0
          ? `${config.borderWidth}px ${config.borderStyle} ${config.borderColor}`
          : 'none',
        borderRadius: `${config.borderRadius}px`,
        boxSizing: 'border-box',
      }}
    />
  )
}
```

Create LineRenderer.tsx:
```tsx
import type { LineElementConfig } from '../../../types/elements'

interface LineRendererProps {
  config: LineElementConfig
}

export function LineRenderer({ config }: LineRendererProps) {
  // Determine if line is more horizontal or vertical based on aspect ratio
  const isHorizontal = config.width >= config.height

  return (
    <div
      className="line-element"
      style={{
        width: '100%',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
      }}
    >
      <div
        style={{
          width: isHorizontal ? '100%' : `${config.strokeWidth}px`,
          height: isHorizontal ? `${config.strokeWidth}px` : '100%',
          backgroundColor: config.strokeColor,
          borderStyle: config.strokeStyle === 'solid' ? undefined : config.strokeStyle,
          // For dashed/dotted, use border instead of background
          ...(config.strokeStyle !== 'solid' && isHorizontal ? {
            backgroundColor: 'transparent',
            borderTop: `${config.strokeWidth}px ${config.strokeStyle} ${config.strokeColor}`,
            height: 0,
          } : {}),
          ...(config.strokeStyle !== 'solid' && !isHorizontal ? {
            backgroundColor: 'transparent',
            borderLeft: `${config.strokeWidth}px ${config.strokeStyle} ${config.strokeColor}`,
            width: 0,
          } : {}),
        }}
      />
    </div>
  )
}
```

Update Element.tsx:
1. Import RectangleRenderer and LineRenderer
2. Add cases to switch:
```tsx
case 'rectangle':
  return <RectangleRenderer config={element} />
case 'line':
  return <LineRenderer config={element} />
```
  </action>
  <verify>TypeScript compiles and both elements render correctly in browser</verify>
  <done>RectangleRenderer and LineRenderer created; Element.tsx routes correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add property panels, palette entries, and export</name>
  <files>
src/components/Properties/RectangleProperties.tsx
src/components/Properties/LineProperties.tsx
src/components/Properties/PropertyPanel.tsx
src/components/Palette/Palette.tsx
src/services/export/htmlGenerator.ts
src/services/export/cssGenerator.ts
  </files>
  <action>
Create RectangleProperties.tsx:
```tsx
import { PropertySection } from './PropertySection'
import { NumberInput } from './NumberInput'
import { ColorInput } from './ColorInput'
import type { RectangleElementConfig, ElementConfig } from '../../types/elements'

interface RectanglePropertiesProps {
  element: RectangleElementConfig
  onUpdate: (updates: Partial<ElementConfig>) => void
}

export function RectangleProperties({ element, onUpdate }: RectanglePropertiesProps) {
  return (
    <>
      <PropertySection title="Fill">
        <ColorInput
          label="Color"
          value={element.fillColor}
          onChange={(fillColor) => onUpdate({ fillColor })}
        />
        <NumberInput
          label="Opacity"
          value={element.fillOpacity}
          onChange={(fillOpacity) => onUpdate({ fillOpacity })}
          min={0}
          max={1}
          step={0.1}
        />
      </PropertySection>

      <PropertySection title="Border">
        <NumberInput
          label="Width"
          value={element.borderWidth}
          onChange={(borderWidth) => onUpdate({ borderWidth })}
          min={0}
          max={10}
        />
        <ColorInput
          label="Color"
          value={element.borderColor}
          onChange={(borderColor) => onUpdate({ borderColor })}
        />
        <div>
          <label className="block text-xs text-gray-400 mb-1">Style</label>
          <select
            value={element.borderStyle}
            onChange={(e) => onUpdate({ borderStyle: e.target.value as 'solid' | 'dashed' | 'dotted' })}
            className="w-full bg-gray-700 border border-gray-600 text-white rounded px-2 py-1.5 text-sm"
          >
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
        </div>
        <NumberInput
          label="Radius"
          value={element.borderRadius}
          onChange={(borderRadius) => onUpdate({ borderRadius })}
          min={0}
          max={50}
        />
      </PropertySection>
    </>
  )
}
```

Create LineProperties.tsx:
```tsx
import { PropertySection } from './PropertySection'
import { NumberInput } from './NumberInput'
import { ColorInput } from './ColorInput'
import type { LineElementConfig, ElementConfig } from '../../types/elements'

interface LinePropertiesProps {
  element: LineElementConfig
  onUpdate: (updates: Partial<ElementConfig>) => void
}

export function LineProperties({ element, onUpdate }: LinePropertiesProps) {
  return (
    <>
      <PropertySection title="Line">
        <NumberInput
          label="Stroke Width"
          value={element.strokeWidth}
          onChange={(strokeWidth) => onUpdate({ strokeWidth })}
          min={1}
          max={20}
        />
        <ColorInput
          label="Color"
          value={element.strokeColor}
          onChange={(strokeColor) => onUpdate({ strokeColor })}
        />
        <div>
          <label className="block text-xs text-gray-400 mb-1">Style</label>
          <select
            value={element.strokeStyle}
            onChange={(e) => onUpdate({ strokeStyle: e.target.value as 'solid' | 'dashed' | 'dotted' })}
            className="w-full bg-gray-700 border border-gray-600 text-white rounded px-2 py-1.5 text-sm"
          >
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
        </div>
      </PropertySection>

      <PropertySection title="Tip">
        <p className="text-xs text-gray-400">
          For horizontal lines: make width &gt; height<br/>
          For vertical lines: make height &gt; width<br/>
          For diagonal: use rotation
        </p>
      </PropertySection>
    </>
  )
}
```

Update PropertyPanel.tsx with cases for rectangle, line.

Update Palette.tsx - add to existing "Images & Decorative" category:
```typescript
{ id: 'rectangle', type: 'rectangle', name: 'Rectangle' },
{ id: 'line', type: 'line', name: 'Line' },
```

Update htmlGenerator.ts:
```typescript
case 'rectangle':
  return `<div id="${id}" class="${baseClass} rectangle-element" data-type="rectangle" style="${positionStyle}"></div>`

case 'line':
  return `<div id="${id}" class="${baseClass} line-element" data-type="line" style="${positionStyle}"><div class="line-stroke"></div></div>`
```

Update cssGenerator.ts:
```typescript
case 'rectangle':
  return `${selector} {
  background-color: ${element.fillColor};
  opacity: ${element.fillOpacity};
  ${element.borderWidth > 0 ? `border: ${element.borderWidth}px ${element.borderStyle} ${element.borderColor};` : ''}
  border-radius: ${element.borderRadius}px;
  box-sizing: border-box;
}`

case 'line':
  const isHorizontal = element.width >= element.height
  if (isHorizontal) {
    return `${selector} {
  display: flex;
  align-items: center;
}
${selector} .line-stroke {
  width: 100%;
  height: ${element.strokeWidth}px;
  background-color: ${element.strokeStyle === 'solid' ? element.strokeColor : 'transparent'};
  ${element.strokeStyle !== 'solid' ? `border-top: ${element.strokeWidth}px ${element.strokeStyle} ${element.strokeColor};` : ''}
}`
  } else {
    return `${selector} {
  display: flex;
  justify-content: center;
}
${selector} .line-stroke {
  width: ${element.strokeWidth}px;
  height: 100%;
  background-color: ${element.strokeStyle === 'solid' ? element.strokeColor : 'transparent'};
  ${element.strokeStyle !== 'solid' ? `border-left: ${element.strokeWidth}px ${element.strokeStyle} ${element.strokeColor};` : ''}
}`
  }
```
  </action>
  <verify>
1. Run `npm run dev`
2. Find Rectangle and Line in "Images & Decorative" category
3. Drag Rectangle to canvas - verify fill and border appear
4. Change border radius in property panel
5. Drag Line to canvas - verify line appears
6. Resize line to be vertical, verify it renders correctly
7. Change stroke style to dashed
8. Export project, verify HTML/CSS for both elements
  </verify>
  <done>Property panels complete; Palette entries added; Export generates correct HTML/CSS</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run build`
2. Rectangle and Line appear in Palette (Images & Decorative category)
3. Rectangle renders with configurable fill, border, and radius
4. Line renders horizontally or vertically based on aspect ratio
5. Dashed/dotted line styles work correctly
6. Property panels have appropriate controls
7. Exported HTML contains correct markup
8. Exported CSS handles both orientations and styles
</verification>

<success_criteria>
- [ ] RectangleElementConfig and LineElementConfig types exist
- [ ] Type guards work for both types
- [ ] Factory functions have sensible defaults
- [ ] RectangleRenderer displays fill, border, and radius
- [ ] LineRenderer handles horizontal/vertical based on dimensions
- [ ] Line supports solid/dashed/dotted styles
- [ ] Element.tsx handles both types
- [ ] Property panels exist for both elements
- [ ] Palette "Images & Decorative" includes both new elements
- [ ] HTML export generates correct markup
- [ ] CSS export handles all configurations
</success_criteria>

<output>
After completion, create `.planning/phases/13-extended-elements/13-06-SUMMARY.md`
</output>
