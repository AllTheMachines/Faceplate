---
phase: 19-architecture-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/components/elements/renderers/index.ts
  - src/components/elements/Element.tsx
autonomous: true

must_haves:
  truths:
    - "Element.tsx uses Map-based registry lookup instead of switch statement"
    - "All 25 element types render correctly on canvas"
    - "TypeScript exhaustive type checking preserved"
    - "Adding new element type requires only registry entry, not switch case"
  artifacts:
    - path: "src/components/elements/renderers/index.ts"
      provides: "Renderer registry Map"
      exports: ["rendererRegistry"]
    - path: "src/components/elements/Element.tsx"
      provides: "Element component with registry lookup"
      contains: "rendererRegistry.get"
  key_links:
    - from: "src/components/elements/Element.tsx"
      to: "src/components/elements/renderers/index.ts"
      via: "imports rendererRegistry"
      pattern: "import.*rendererRegistry.*from"
    - from: "src/components/elements/renderers/index.ts"
      to: "src/components/elements/renderers/*Renderer.tsx"
      via: "imports all renderer components"
      pattern: "import.*Renderer.*from"
---

<objective>
Replace the switch statement in Element.tsx with a Map-based renderer registry for O(1) component lookup.

Purpose: The current 26-case switch statement grows linearly with element types. A Map-based registry provides constant-time lookup and cleaner extensibility - adding new elements requires only a registry entry instead of modifying switch logic.

Output: New renderers/index.ts with registry Map, refactored Element.tsx using registry lookup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-architecture-refactoring/19-RESEARCH.md
@src/components/elements/Element.tsx
@src/types/elements.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create renderer registry</name>
  <files>src/components/elements/renderers/index.ts</files>
  <action>
Create src/components/elements/renderers/index.ts with a Map-based renderer registry.

```typescript
/**
 * Element Renderer Registry
 *
 * Maps element types to their renderer components for O(1) lookup.
 * Adding new element types requires only adding an entry here.
 */

import React from 'react'
import type { ElementConfig } from '../../../types/elements'

// Import all renderers
import { KnobRenderer } from './KnobRenderer'
import { SliderRenderer } from './SliderRenderer'
import { ButtonRenderer } from './ButtonRenderer'
import { LabelRenderer } from './LabelRenderer'
import { MeterRenderer } from './MeterRenderer'
import { ImageRenderer } from './ImageRenderer'
import { DropdownRenderer } from './DropdownRenderer'
import { CheckboxRenderer } from './CheckboxRenderer'
import { RadioGroupRenderer } from './RadioGroupRenderer'
import { ModulationMatrixRenderer } from './ModulationMatrixRenderer'
import { RangeSliderRenderer } from './RangeSliderRenderer'
import { RectangleRenderer } from './RectangleRenderer'
import { LineRenderer } from './LineRenderer'
import { PanelRenderer } from './PanelRenderer'
import { FrameRenderer } from './FrameRenderer'
import { GroupBoxRenderer } from './GroupBoxRenderer'
import { DbDisplayRenderer } from './DbDisplayRenderer'
import { FrequencyDisplayRenderer } from './FrequencyDisplayRenderer'
import { GainReductionMeterRenderer } from './GainReductionMeterRenderer'
import { PresetBrowserRenderer } from './PresetBrowserRenderer'
import { WaveformRenderer } from './WaveformRenderer'
import { OscilloscopeRenderer } from './OscilloscopeRenderer'
import { TextFieldRenderer } from './TextFieldRenderer'
import { CollapsibleRenderer } from './CollapsibleRenderer'
import { SvgGraphicRenderer } from './SvgGraphicRenderer'

// Renderer component type - accepts config prop and renders element
export type RendererComponent = React.ComponentType<{ config: ElementConfig }>

/**
 * Registry mapping element type strings to their renderer components.
 * Use Map for O(1) lookup performance.
 */
export const rendererRegistry = new Map<ElementConfig['type'], RendererComponent>([
  // Controls
  ['knob', KnobRenderer as RendererComponent],
  ['slider', SliderRenderer as RendererComponent],
  ['button', ButtonRenderer as RendererComponent],
  ['rangeslider', RangeSliderRenderer as RendererComponent],
  ['dropdown', DropdownRenderer as RendererComponent],
  ['checkbox', CheckboxRenderer as RendererComponent],
  ['radiogroup', RadioGroupRenderer as RendererComponent],
  ['textfield', TextFieldRenderer as RendererComponent],

  // Displays
  ['label', LabelRenderer as RendererComponent],
  ['meter', MeterRenderer as RendererComponent],
  ['dbdisplay', DbDisplayRenderer as RendererComponent],
  ['frequencydisplay', FrequencyDisplayRenderer as RendererComponent],
  ['gainreductionmeter', GainReductionMeterRenderer as RendererComponent],
  ['waveform', WaveformRenderer as RendererComponent],
  ['oscilloscope', OscilloscopeRenderer as RendererComponent],
  ['presetbrowser', PresetBrowserRenderer as RendererComponent],
  ['modulationmatrix', ModulationMatrixRenderer as RendererComponent],

  // Containers
  ['panel', PanelRenderer as RendererComponent],
  ['frame', FrameRenderer as RendererComponent],
  ['groupbox', GroupBoxRenderer as RendererComponent],
  ['collapsible', CollapsibleRenderer as RendererComponent],

  // Decorative
  ['image', ImageRenderer as RendererComponent],
  ['svggraphic', SvgGraphicRenderer as RendererComponent],
  ['rectangle', RectangleRenderer as RendererComponent],
  ['line', LineRenderer as RendererComponent],
])

/**
 * Get renderer for an element type.
 * Returns undefined if type not found (should never happen with proper typing).
 */
export function getRenderer(type: ElementConfig['type']): RendererComponent | undefined {
  return rendererRegistry.get(type)
}

// Re-export all individual renderers for direct import if needed
export { KnobRenderer } from './KnobRenderer'
export { SliderRenderer } from './SliderRenderer'
export { ButtonRenderer } from './ButtonRenderer'
export { LabelRenderer } from './LabelRenderer'
export { MeterRenderer } from './MeterRenderer'
export { ImageRenderer } from './ImageRenderer'
export { DropdownRenderer } from './DropdownRenderer'
export { CheckboxRenderer } from './CheckboxRenderer'
export { RadioGroupRenderer } from './RadioGroupRenderer'
export { ModulationMatrixRenderer } from './ModulationMatrixRenderer'
export { RangeSliderRenderer } from './RangeSliderRenderer'
export { RectangleRenderer } from './RectangleRenderer'
export { LineRenderer } from './LineRenderer'
export { PanelRenderer } from './PanelRenderer'
export { FrameRenderer } from './FrameRenderer'
export { GroupBoxRenderer } from './GroupBoxRenderer'
export { DbDisplayRenderer } from './DbDisplayRenderer'
export { FrequencyDisplayRenderer } from './FrequencyDisplayRenderer'
export { GainReductionMeterRenderer } from './GainReductionMeterRenderer'
export { PresetBrowserRenderer } from './PresetBrowserRenderer'
export { WaveformRenderer } from './WaveformRenderer'
export { OscilloscopeRenderer } from './OscilloscopeRenderer'
export { TextFieldRenderer } from './TextFieldRenderer'
export { CollapsibleRenderer } from './CollapsibleRenderer'
export { SvgGraphicRenderer } from './SvgGraphicRenderer'
```

The `as RendererComponent` cast is needed because each renderer accepts a specific config type (e.g., KnobElementConfig) but the Map stores them generically.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>Renderer registry created with all 25 element types mapped</done>
</task>

<task type="auto">
  <name>Task 2: Refactor Element.tsx to use registry</name>
  <files>src/components/elements/Element.tsx</files>
  <action>
Replace the switch statement in Element.tsx with registry lookup.

```typescript
import React from 'react'
import { ElementConfig } from '../../types/elements'
import { useStore } from '../../store'
import { BaseElement } from './BaseElement'
import { getRenderer } from './renderers'

interface ElementProps {
  element: ElementConfig
}

function ElementComponent({ element }: ElementProps) {
  // Get selection actions from store
  const selectElement = useStore((state) => state.selectElement)
  const toggleSelection = useStore((state) => state.toggleSelection)
  const addToSelection = useStore((state) => state.addToSelection)
  const lockAllMode = useStore((state) => state.lockAllMode)

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation()

    // Lock-all mode blocks ALL interactions (for UI testing)
    if (lockAllMode) return

    // Get current selection to check if element is already selected
    const selectedIds = useStore.getState().selectedIds
    const isAlreadySelected = selectedIds.includes(element.id)

    if (e.shiftKey) {
      // Shift+click: add to selection
      addToSelection(element.id)
    } else if (e.ctrlKey || e.metaKey) {
      // Ctrl/Cmd+click: toggle in selection
      toggleSelection(element.id)
    } else if (isAlreadySelected && selectedIds.length > 1) {
      // Plain click on already-selected element with multi-selection: keep selection
    } else {
      // Plain click: select only this element
      selectElement(element.id)
    }
  }

  // Get renderer from registry
  const Renderer = getRenderer(element.type)

  // Fallback for unknown types (should never happen with proper typing)
  if (!Renderer) {
    console.warn(`No renderer found for element type: ${element.type}`)
    return null
  }

  return (
    <BaseElement element={element} onClick={handleClick}>
      <Renderer config={element} />
    </BaseElement>
  )
}

// Memoize to prevent re-renders when other elements change
export const Element = React.memo(ElementComponent)
```

Key changes:
1. Remove all 25 individual renderer imports - now handled by registry
2. Remove renderContent() function with switch statement
3. Use getRenderer(element.type) for O(1) lookup
4. Add runtime fallback check for unknown types (defensive)
5. Keep all selection handling logic unchanged
  </action>
  <verify>
Run build and verify elements render:
```bash
npm run build
npm run dev
# Manually verify: drag knob, slider, button onto canvas - they render correctly
```
  </verify>
  <done>Element.tsx uses registry lookup; switch statement removed</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npm run dev` - application starts
3. Test rendering: drag each element type onto canvas, verify it renders
4. Verify Element.tsx no longer contains switch statement
5. Verify renderers/index.ts contains registry with all 25 types
</verification>

<success_criteria>
- [ ] renderers/index.ts exports rendererRegistry Map with 25 entries
- [ ] Element.tsx uses getRenderer() instead of switch statement
- [ ] Element.tsx file size reduced (from ~135 LOC to ~60 LOC)
- [ ] All element types render correctly on canvas
- [ ] Build passes without TypeScript errors
- [ ] No changes to individual renderer files required
</success_criteria>

<output>
After completion, create `.planning/phases/19-architecture-refactoring/19-02-SUMMARY.md`
</output>
