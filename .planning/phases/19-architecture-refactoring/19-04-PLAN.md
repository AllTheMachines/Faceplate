---
phase: 19-architecture-refactoring
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - src/components/Layout/TopBar.tsx
  - src/lib/keyboard.ts
  - src/components/Canvas/hooks/useKeyboardShortcuts.ts
autonomous: true

must_haves:
  truths:
    - "Undo/redo buttons visible in toolbar near logo"
    - "Undo button disabled when history is empty"
    - "Redo button disabled when no actions to redo"
    - "Keyboard shortcuts work correctly on QWERTZ layouts (Ctrl+Z for undo)"
  artifacts:
    - path: "src/components/Layout/TopBar.tsx"
      provides: "Toolbar with undo/redo buttons"
      contains: "undo"
    - path: "src/lib/keyboard.ts"
      provides: "Keyboard layout detection utility"
      exports: ["detectKeyboardLayout", "getUndoShortcutLabel"]
  key_links:
    - from: "src/components/Layout/TopBar.tsx"
      to: "src/store"
      via: "useStore for undo/redo state"
      pattern: "useStore.temporal"
    - from: "src/components/Canvas/hooks/useKeyboardShortcuts.ts"
      to: "src/lib/keyboard.ts"
      via: "imports layout detection (if needed for display)"
      pattern: "import.*keyboard"
---

<objective>
Add visible undo/redo buttons to the toolbar and implement QWERTZ keyboard layout detection for correct shortcut display.

Purpose: Users currently rely on keyboard shortcuts (Ctrl+Z/Y) for undo/redo with no visual feedback. Adding buttons makes undo/redo discoverable and shows current state. QWERTZ layout detection ensures keyboard shortcuts work correctly on German keyboards.

Output: TopBar.tsx with undo/redo buttons, keyboard.ts with layout detection utility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-architecture-refactoring/19-RESEARCH.md
@src/components/Layout/TopBar.tsx
@src/components/Canvas/hooks/useKeyboardShortcuts.ts
@src/store/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create keyboard layout detection utility</name>
  <files>src/lib/keyboard.ts</files>
  <action>
Create src/lib/keyboard.ts with keyboard layout detection.

```typescript
/**
 * Keyboard Layout Detection
 *
 * Detects physical keyboard layout (QWERTY vs QWERTZ) for correct
 * shortcut display. Uses experimental Keyboard API with fallback.
 */

export type KeyboardLayout = 'QWERTY' | 'QWERTZ' | 'unknown'

// Cache detected layout
let detectedLayout: KeyboardLayout | null = null

/**
 * Detect keyboard layout using the experimental Keyboard API.
 * Returns cached result after first detection.
 *
 * QWERTZ detection: On QWERTZ keyboards, the physical 'Z' key produces 'y'
 * because Y and Z are swapped compared to QWERTY.
 */
export async function detectKeyboardLayout(): Promise<KeyboardLayout> {
  // Return cached result if available
  if (detectedLayout !== null) {
    return detectedLayout
  }

  // Check if Keyboard API is available (Chromium browsers only)
  if (!('keyboard' in navigator) || !navigator.keyboard?.getLayoutMap) {
    detectedLayout = 'unknown'
    return detectedLayout
  }

  try {
    const layoutMap = await navigator.keyboard.getLayoutMap()

    // Check what character the physical 'Z' key produces
    const keyZ = layoutMap.get('KeyZ')

    if (keyZ === 'y') {
      // Physical Z produces 'y' -> QWERTZ layout (Y and Z swapped)
      detectedLayout = 'QWERTZ'
    } else if (keyZ === 'z') {
      // Physical Z produces 'z' -> QWERTY layout
      detectedLayout = 'QWERTY'
    } else {
      // Unknown mapping
      detectedLayout = 'unknown'
    }
  } catch (error) {
    console.warn('Keyboard layout detection failed:', error)
    detectedLayout = 'unknown'
  }

  return detectedLayout
}

/**
 * Get the display label for undo shortcut based on layout.
 * Note: The actual Ctrl+Z shortcut works on both layouts because
 * react-hotkeys-hook uses key codes, not characters.
 */
export function getUndoShortcutLabel(layout: KeyboardLayout): string {
  // On all platforms, the shortcut is Ctrl+Z (or Cmd+Z on Mac)
  // The label should reflect what the user sees on their keyboard
  const isMac = typeof navigator !== 'undefined' && navigator.platform?.includes('Mac')
  const modifier = isMac ? '\u2318' : 'Ctrl+'

  // Ctrl+Z works the same on QWERTY and QWERTZ
  // because it's the same physical key position
  return `${modifier}Z`
}

/**
 * Get the display label for redo shortcut based on layout.
 */
export function getRedoShortcutLabel(layout: KeyboardLayout): string {
  const isMac = typeof navigator !== 'undefined' && navigator.platform?.includes('Mac')
  const modifier = isMac ? '\u2318' : 'Ctrl+'

  if (isMac) {
    return `${modifier}Shift+Z`
  }

  // Windows/Linux: Ctrl+Y or Ctrl+Shift+Z both work
  return `${modifier}Y`
}

/**
 * Check if current environment likely has a QWERTZ keyboard.
 * Uses browser language as a hint (German, Czech, etc. use QWERTZ).
 */
export function isLikelyQWERTZ(): boolean {
  if (typeof navigator === 'undefined') return false

  const lang = navigator.language?.toLowerCase() || ''

  // Countries that commonly use QWERTZ
  return (
    lang.startsWith('de') || // German
    lang.startsWith('cs') || // Czech
    lang.startsWith('sk') || // Slovak
    lang.startsWith('hu') || // Hungarian
    lang.startsWith('sl') || // Slovenian
    lang.startsWith('hr')    // Croatian
  )
}
```

Note on QWERTZ support:
- react-hotkeys-hook uses KeyboardEvent.key or KeyboardEvent.code
- Ctrl+Z works the same on QWERTZ because it's the same physical key
- The Y/Z swap affects character input, not shortcut bindings
- Layout detection is primarily useful for displaying correct labels in tooltips
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>Keyboard layout detection utility created with QWERTZ support</done>
</task>

<task type="auto">
  <name>Task 2: Add undo/redo buttons to TopBar</name>
  <files>src/components/Layout/TopBar.tsx</files>
  <action>
Update TopBar.tsx to include undo/redo buttons near the logo.

```typescript
import { useState, useEffect } from 'react'
import { NewProjectDialog } from '../dialogs/NewProjectDialog'
import { useStore } from '../../store'
import { detectKeyboardLayout, getUndoShortcutLabel, getRedoShortcutLabel, type KeyboardLayout } from '../../lib/keyboard'

// Undo icon (arrow curving left)
function UndoIcon({ className = 'w-4 h-4' }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
    </svg>
  )
}

// Redo icon (arrow curving right)
function RedoIcon({ className = 'w-4 h-4' }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M21 10H11a8 8 0 00-8 8v2M21 10l-6 6m6-6l-6-6" />
    </svg>
  )
}

export const TopBar = () => {
  const [showNewProjectDialog, setShowNewProjectDialog] = useState(false)
  const [keyboardLayout, setKeyboardLayout] = useState<KeyboardLayout>('unknown')

  // Get undo/redo state from temporal store
  const pastStates = useStore.temporal((state) => state.pastStates)
  const futureStates = useStore.temporal((state) => state.futureStates)
  const undo = useStore.temporal((state) => state.undo)
  const redo = useStore.temporal((state) => state.redo)

  const canUndo = pastStates.length > 0
  const canRedo = futureStates.length > 0

  // Detect keyboard layout on mount
  useEffect(() => {
    detectKeyboardLayout().then(setKeyboardLayout)
  }, [])

  const undoLabel = getUndoShortcutLabel(keyboardLayout)
  const redoLabel = getRedoShortcutLabel(keyboardLayout)

  return (
    <div className="top-bar flex items-center gap-4 p-4">
      <span className="text-xl font-bold text-white tracking-tight mr-2">Facet</span>

      {/* Undo/Redo buttons */}
      <div className="flex items-center gap-1 mr-2">
        <button
          onClick={() => undo()}
          disabled={!canUndo}
          className={`p-2 rounded transition-colors ${
            canUndo
              ? 'text-gray-300 hover:text-white hover:bg-gray-700'
              : 'text-gray-600 cursor-not-allowed'
          }`}
          title={`Undo (${undoLabel})`}
          aria-label="Undo"
        >
          <UndoIcon />
        </button>
        <button
          onClick={() => redo()}
          disabled={!canRedo}
          className={`p-2 rounded transition-colors ${
            canRedo
              ? 'text-gray-300 hover:text-white hover:bg-gray-700'
              : 'text-gray-600 cursor-not-allowed'
          }`}
          title={`Redo (${redoLabel})`}
          aria-label="Redo"
        >
          <RedoIcon />
        </button>
      </div>

      <button
        onClick={() => setShowNewProjectDialog(true)}
        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-white font-medium"
      >
        New Project
      </button>

      {/* Other buttons */}

      <NewProjectDialog
        isOpen={showNewProjectDialog}
        onClose={() => setShowNewProjectDialog(false)}
      />
    </div>
  )
}
```

Key features:
1. Undo/redo buttons positioned between logo and "New Project" button
2. Buttons disabled when no actions to undo/redo (visual feedback)
3. Tooltips show keyboard shortcut (e.g., "Undo (Ctrl+Z)")
4. SVG icons matching dark theme style
5. Keyboard layout detected for correct shortcut labels
  </action>
  <verify>
Run build and verify buttons appear:
```bash
npm run build
npm run dev
# Manually verify:
# 1. Undo/redo buttons visible near logo
# 2. Buttons disabled initially (no history)
# 3. Add element, undo button becomes active
# 4. Click undo, element removed, redo becomes active
# 5. Tooltips show shortcuts
```
  </verify>
  <done>Undo/redo buttons visible in toolbar with correct state and tooltips</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npm run dev` - application starts
3. Undo/redo buttons visible in TopBar near logo
4. Buttons correctly disabled when history empty
5. Adding element enables undo button
6. Clicking undo restores previous state and enables redo
7. Keyboard shortcuts (Ctrl+Z, Ctrl+Y) still work
8. Tooltips show correct shortcut labels
</verification>

<success_criteria>
- [ ] src/lib/keyboard.ts exports detectKeyboardLayout function
- [ ] TopBar.tsx shows undo/redo buttons near logo
- [ ] Undo button disabled when pastStates is empty
- [ ] Redo button disabled when futureStates is empty
- [ ] Clicking undo calls useStore.temporal().undo()
- [ ] Clicking redo calls useStore.temporal().redo()
- [ ] Button tooltips show keyboard shortcuts
- [ ] Build passes without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-architecture-refactoring/19-04-SUMMARY.md`
</output>
