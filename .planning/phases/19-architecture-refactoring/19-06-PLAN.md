---
phase: 19-architecture-refactoring
plan: 06
type: execute
wave: 3
depends_on: ["19-02", "19-03", "19-05"]
files_modified:
  - src/components/elements/renderers/index.ts
  - src/components/elements/Element.tsx
  - vite.config.ts
  - src/components/elements/renderers/README.md
autonomous: true

must_haves:
  truths:
    - "Suspense boundaries wrap renderer components with loading fallback"
    - "Vite produces separate chunks for each category"
    - "Infrastructure ready for future React.lazy adoption"
    - "Application functions identically (no visible loading states normally)"
  artifacts:
    - path: "src/components/elements/Element.tsx"
      provides: "Element component with Suspense boundary"
      contains: "Suspense"
    - path: "vite.config.ts"
      provides: "Build config with manual chunks"
      contains: "manualChunks"
    - path: "src/components/elements/renderers/README.md"
      provides: "Documentation for code splitting pattern"
      contains: "React.lazy"
  key_links:
    - from: "vite.config.ts"
      to: "src/components/elements/renderers/*/index.ts"
      via: "manual chunk configuration"
      pattern: "elements-controls"
---

<objective>
Establish code splitting infrastructure with Suspense boundaries and Vite chunk configuration to prepare for future React.lazy adoption.

Purpose: As element types grow from 25 to 100+, loading all renderers upfront will impact initial load time. This plan establishes the infrastructure (Suspense boundaries, Vite chunks) so that React.lazy can be adopted incrementally in future phases.

Output: Suspense boundaries in Element.tsx, Vite config with category chunks, documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-architecture-refactoring/19-RESEARCH.md
@.planning/phases/19-architecture-refactoring/19-02-SUMMARY.md
@.planning/phases/19-architecture-refactoring/19-05-SUMMARY.md
@src/components/elements/renderers/index.ts
@src/components/elements/Element.tsx
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Suspense boundary to Element component</name>
  <files>src/components/elements/Element.tsx</files>
  <action>
Read existing Element.tsx from Plan 19-02 first and preserve its registry lookup pattern. Only add Suspense wrapper around the Renderer component - do not replace the registry-based lookup.

The existing Element.tsx uses:
- `getRenderer(element.type)` for O(1) registry lookup
- Selection handling logic (handleClick with shift/ctrl/cmd)
- BaseElement wrapper

Add Suspense boundary while preserving all existing functionality:

```typescript
import React, { Suspense } from 'react'
import { ElementConfig } from '../../types/elements'
import { useStore } from '../../store'
import { BaseElement } from './BaseElement'
import { getRenderer } from './renderers'

interface ElementProps {
  element: ElementConfig
}

// Loading placeholder for future lazy-loaded renderers
function RendererFallback() {
  return (
    <div className="w-full h-full flex items-center justify-center text-gray-500 text-xs">
      Loading...
    </div>
  )
}

function ElementComponent({ element }: ElementProps) {
  // Get selection actions from store
  const selectElement = useStore((state) => state.selectElement)
  const toggleSelection = useStore((state) => state.toggleSelection)
  const addToSelection = useStore((state) => state.addToSelection)
  const lockAllMode = useStore((state) => state.lockAllMode)

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation()

    // Lock-all mode blocks ALL interactions
    if (lockAllMode) return

    const selectedIds = useStore.getState().selectedIds
    const isAlreadySelected = selectedIds.includes(element.id)

    if (e.shiftKey) {
      addToSelection(element.id)
    } else if (e.ctrlKey || e.metaKey) {
      toggleSelection(element.id)
    } else if (isAlreadySelected && selectedIds.length > 1) {
      // Keep selection
    } else {
      selectElement(element.id)
    }
  }

  // Get renderer from registry (preserve Plan 19-02 pattern)
  const Renderer = getRenderer(element.type)

  if (!Renderer) {
    console.warn(`No renderer found for element type: ${element.type}`)
    return null
  }

  return (
    <BaseElement element={element} onClick={handleClick}>
      <Suspense fallback={<RendererFallback />}>
        <Renderer config={element} />
      </Suspense>
    </BaseElement>
  )
}

export const Element = React.memo(ElementComponent)
```

The Suspense boundary:
- Shows a minimal loading state while renderer chunk loads (future use)
- Falls back gracefully if chunk fails (shows loading, doesn't crash)
- Currently all renderers load synchronously, so fallback is never visible
- Infrastructure is ready for when React.lazy is adopted
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>Suspense boundary added to Element component</done>
</task>

<task type="auto">
  <name>Task 2: Configure Vite for category-based chunks</name>
  <files>vite.config.ts</files>
  <action>
Update vite.config.ts to configure manual chunks for element categories.

First read current vite.config.ts, then add chunk configuration:

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // Vendor chunks
          'vendor-react': ['react', 'react-dom'],
          'vendor-dnd': ['@dnd-kit/core', '@dnd-kit/utilities'],
          'vendor-zustand': ['zustand'],

          // Element category chunks (for future lazy loading)
          'elements-controls': [
            './src/components/elements/renderers/controls/index.ts',
          ],
          'elements-displays': [
            './src/components/elements/renderers/displays/index.ts',
          ],
          'elements-containers': [
            './src/components/elements/renderers/containers/index.ts',
          ],
          'elements-decorative': [
            './src/components/elements/renderers/decorative/index.ts',
          ],
        },
      },
    },
  },
})
```

Note: This configuration prepares the infrastructure for lazy loading.
Currently, all categories are bundled into separate chunks but loaded synchronously.
When React.lazy is adopted (future phase), these chunks will load on-demand.
  </action>
  <verify>Build produces separate chunks: `npm run build && ls -la dist/assets/*.js`</verify>
  <done>Vite configured with category-based manual chunks</done>
</task>

<task type="auto">
  <name>Task 3: Document code splitting pattern for future elements</name>
  <files>src/components/elements/renderers/README.md</files>
  <action>
Create documentation for the code splitting pattern.

```markdown
# Element Renderers

Element renderers are React components that render the visual representation
of elements on the canvas.

## Directory Structure

```
renderers/
  controls/       # Knob, Slider, Button, etc.
  displays/       # Label, Meter, dB Display, etc.
  containers/     # Panel, Frame, GroupBox, etc.
  decorative/     # Image, Rectangle, Line, etc.
  index.ts        # Registry and exports
```

## Adding a New Element

1. Create the renderer in the appropriate category folder:
   ```
   renderers/controls/NewControlRenderer.tsx
   ```

2. Export from category index:
   ```typescript
   // controls/index.ts
   export { NewControlRenderer } from './NewControlRenderer'
   ```

3. Add to registry in main index.ts:
   ```typescript
   ['newcontrol', NewControlRenderer as RendererComponent],
   ```

4. Add corresponding type in `src/types/elements/controls.ts`

5. Add property panel in `src/components/Properties/controls/`

## Code Splitting Infrastructure

Renderers are organized by category to enable future code splitting:

**Current state (Phase 19):**
- Suspense boundaries in place around renderers
- Vite configured with category-based manual chunks
- All categories load synchronously (bundled separately but loaded together)

**Future state (when React.lazy adopted):**
- Each category can be lazy-loaded independently
- Initial page load only includes commonly-used elements
- Less-common elements load on first use

To convert a category to lazy loading:
```typescript
// Change from:
import { KnobRenderer } from './controls'

// To:
const KnobRenderer = React.lazy(() => import('./controls/KnobRenderer'))
```

The Suspense boundary in Element.tsx handles loading states.

## Registry Pattern

The registry uses a Map for O(1) lookup:
```typescript
const Renderer = rendererRegistry.get(element.type)
```

Benefits:
- Constant time lookup regardless of element count
- Easy to add new elements without modifying switch logic
- Supports lazy loading with React.lazy
```
  </action>
  <verify>File created: `cat src/components/elements/renderers/README.md`</verify>
  <done>Code splitting pattern documented for future reference</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Build output shows separate chunk files for categories
3. `npm run dev` - application starts and works normally
4. Suspense boundary doesn't cause visual issues (renderers load synchronously)
5. All element types still render correctly
6. README.md documents the pattern for future contributors
</verification>

<success_criteria>
- [ ] Element.tsx wraps renderer in Suspense boundary
- [ ] vite.config.ts configures manual chunks for categories
- [ ] Build produces separate JS files for element categories
- [ ] Application works identically (no visible loading states)
- [ ] README.md documents the code splitting pattern
- [ ] Build passes without TypeScript errors
- [ ] Infrastructure ready for incremental lazy loading adoption
</success_criteria>

<output>
After completion, create `.planning/phases/19-architecture-refactoring/19-06-SUMMARY.md`
</output>
