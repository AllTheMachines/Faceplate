---
phase: 19-architecture-refactoring
plan: 06
type: execute
wave: 3
depends_on: ["19-02", "19-03", "19-05"]
files_modified:
  - src/components/elements/renderers/index.ts
  - src/components/Properties/index.ts
  - vite.config.ts
autonomous: true

must_haves:
  truths:
    - "React.lazy used for category-based code splitting"
    - "Suspense boundaries wrap lazy components with loading fallback"
    - "Vite produces separate chunks for each category"
    - "Initial page load does not include all renderer code"
  artifacts:
    - path: "src/components/elements/renderers/index.ts"
      provides: "Lazy-loaded renderer registry"
      contains: "React.lazy"
    - path: "vite.config.ts"
      provides: "Build config with manual chunks"
      contains: "manualChunks"
  key_links:
    - from: "src/components/elements/renderers/index.ts"
      to: "src/components/elements/renderers/*/index.ts"
      via: "dynamic import"
      pattern: "import\\("
---

<objective>
Establish code splitting infrastructure using React.lazy for category-based renderer and property component loading.

Purpose: As element types grow from 25 to 100+, loading all renderers upfront impacts initial load time. Lazy loading by category (controls, displays, containers, decorative) defers loading until a category is needed.

Output: Lazy-loaded registry with Suspense boundaries, Vite config with category chunks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-architecture-refactoring/19-RESEARCH.md
@.planning/phases/19-architecture-refactoring/19-05-SUMMARY.md
@src/components/elements/renderers/index.ts
@src/components/Properties/index.ts
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Suspense boundary to Element component</name>
  <files>src/components/elements/Element.tsx</files>
  <action>
Update Element.tsx to wrap renderer in Suspense boundary for lazy loading support.

```typescript
import React, { Suspense } from 'react'
import { ElementConfig } from '../../types/elements'
import { useStore } from '../../store'
import { BaseElement } from './BaseElement'
import { getRenderer } from './renderers'

interface ElementProps {
  element: ElementConfig
}

// Loading placeholder for lazy-loaded renderers
function RendererFallback() {
  return (
    <div className="w-full h-full flex items-center justify-center text-gray-500 text-xs">
      Loading...
    </div>
  )
}

function ElementComponent({ element }: ElementProps) {
  // Get selection actions from store
  const selectElement = useStore((state) => state.selectElement)
  const toggleSelection = useStore((state) => state.toggleSelection)
  const addToSelection = useStore((state) => state.addToSelection)
  const lockAllMode = useStore((state) => state.lockAllMode)

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation()

    // Lock-all mode blocks ALL interactions
    if (lockAllMode) return

    const selectedIds = useStore.getState().selectedIds
    const isAlreadySelected = selectedIds.includes(element.id)

    if (e.shiftKey) {
      addToSelection(element.id)
    } else if (e.ctrlKey || e.metaKey) {
      toggleSelection(element.id)
    } else if (isAlreadySelected && selectedIds.length > 1) {
      // Keep selection
    } else {
      selectElement(element.id)
    }
  }

  // Get renderer from registry
  const Renderer = getRenderer(element.type)

  if (!Renderer) {
    console.warn(`No renderer found for element type: ${element.type}`)
    return null
  }

  return (
    <BaseElement element={element} onClick={handleClick}>
      <Suspense fallback={<RendererFallback />}>
        <Renderer config={element} />
      </Suspense>
    </BaseElement>
  )
}

export const Element = React.memo(ElementComponent)
```

The Suspense boundary:
- Shows a minimal loading state while renderer chunk loads
- Falls back gracefully if chunk fails (shows loading, doesn't crash)
- Only visible on first render of a category (subsequent renders instant)
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>Suspense boundary added to Element component</done>
</task>

<task type="auto">
  <name>Task 2: Configure Vite for category-based chunks</name>
  <files>vite.config.ts</files>
  <action>
Update vite.config.ts to configure manual chunks for element categories.

First read current vite.config.ts, then add chunk configuration:

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // Vendor chunks
          'vendor-react': ['react', 'react-dom'],
          'vendor-dnd': ['@dnd-kit/core', '@dnd-kit/utilities'],
          'vendor-zustand': ['zustand'],

          // Element category chunks (for future lazy loading)
          'elements-controls': [
            './src/components/elements/renderers/controls/index.ts',
          ],
          'elements-displays': [
            './src/components/elements/renderers/displays/index.ts',
          ],
          'elements-containers': [
            './src/components/elements/renderers/containers/index.ts',
          ],
          'elements-decorative': [
            './src/components/elements/renderers/decorative/index.ts',
          ],

          // Property panel category chunks
          'properties-controls': [
            './src/components/Properties/controls/index.ts',
          ],
          'properties-displays': [
            './src/components/Properties/displays/index.ts',
          ],
          'properties-containers': [
            './src/components/Properties/containers/index.ts',
          ],
          'properties-decorative': [
            './src/components/Properties/decorative/index.ts',
          ],
        },
      },
    },
  },
})
```

Note: This configuration prepares the infrastructure for lazy loading.
The actual lazy() calls can be added incrementally as needed.
For now, all categories load synchronously but are bundled into separate chunks.
  </action>
  <verify>Build produces separate chunks: `npm run build && ls -la dist/assets/*.js`</verify>
  <done>Vite configured with category-based manual chunks</done>
</task>

<task type="auto">
  <name>Task 3: Document code splitting pattern for future elements</name>
  <files>src/components/elements/renderers/README.md</files>
  <action>
Create documentation for the code splitting pattern.

```markdown
# Element Renderers

Element renderers are React components that render the visual representation
of elements on the canvas.

## Directory Structure

```
renderers/
  controls/       # Knob, Slider, Button, etc.
  displays/       # Label, Meter, dB Display, etc.
  containers/     # Panel, Frame, GroupBox, etc.
  decorative/     # Image, Rectangle, Line, etc.
  index.ts        # Registry and exports
```

## Adding a New Element

1. Create the renderer in the appropriate category folder:
   ```
   renderers/controls/NewControlRenderer.tsx
   ```

2. Export from category index:
   ```typescript
   // controls/index.ts
   export { NewControlRenderer } from './NewControlRenderer'
   ```

3. Add to registry in main index.ts:
   ```typescript
   ['newcontrol', NewControlRenderer as RendererComponent],
   ```

4. Add corresponding type in `src/types/elements/controls.ts`

5. Add property panel in `src/components/Properties/controls/`

## Code Splitting

Renderers are organized by category to enable code splitting:
- Each category can be lazy-loaded independently
- Initial page load only includes commonly-used elements
- Less-common elements load on first use

The Suspense boundary in Element.tsx handles loading states.

## Registry Pattern

The registry uses a Map for O(1) lookup:
```typescript
const Renderer = rendererRegistry.get(element.type)
```

Benefits:
- Constant time lookup regardless of element count
- Easy to add new elements without modifying switch logic
- Supports lazy loading with React.lazy
```
  </action>
  <verify>File created: `cat src/components/elements/renderers/README.md`</verify>
  <done>Code splitting pattern documented for future reference</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Build output shows separate chunk files for categories
3. `npm run dev` - application starts and works normally
4. Suspense boundary doesn't cause visual issues (fast enough to not show)
5. All element types still render correctly
6. README.md documents the pattern for future contributors
</verification>

<success_criteria>
- [ ] Element.tsx wraps renderer in Suspense boundary
- [ ] vite.config.ts configures manual chunks for categories
- [ ] Build produces separate JS files for element categories
- [ ] Application works identically (no visible loading states normally)
- [ ] README.md documents the code splitting pattern
- [ ] Build passes without TypeScript errors
- [ ] Infrastructure ready for incremental lazy loading adoption
</success_criteria>

<output>
After completion, create `.planning/phases/19-architecture-refactoring/19-06-SUMMARY.md`
</output>
