---
phase: 19-architecture-refactoring
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/components/Properties/index.ts
  - src/components/Properties/PropertyPanel.tsx
autonomous: true

must_haves:
  truths:
    - "PropertyPanel uses Map-based registry lookup instead of conditional chains"
    - "All 25 element types show correct property panels"
    - "PropertyPanel.tsx reduced from 207 LOC to under 100 LOC"
    - "Adding new element type requires only registry entry, not conditional chain edit"
  artifacts:
    - path: "src/components/Properties/index.ts"
      provides: "Property component registry Map"
      exports: ["propertyRegistry", "getPropertyComponent"]
    - path: "src/components/Properties/PropertyPanel.tsx"
      provides: "PropertyPanel component with registry lookup"
      contains: "propertyRegistry.get"
  key_links:
    - from: "src/components/Properties/PropertyPanel.tsx"
      to: "src/components/Properties/index.ts"
      via: "imports propertyRegistry"
      pattern: "import.*propertyRegistry.*from"
    - from: "src/components/Properties/index.ts"
      to: "src/components/Properties/*Properties.tsx"
      via: "imports all property components"
      pattern: "import.*Properties.*from"
---

<objective>
Replace the conditional chain in PropertyPanel.tsx with a Map-based property component registry for O(1) lookup.

Purpose: The current PropertyPanel has 26 conditional checks (isKnob, isSlider, etc.) that grow linearly with element types. A Map-based registry provides constant-time lookup and cleaner extensibility.

Output: Updated Properties/index.ts with registry Map, refactored PropertyPanel.tsx using registry lookup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-architecture-refactoring/19-RESEARCH.md
@src/components/Properties/PropertyPanel.tsx
@src/types/elements.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create property component registry in index.ts</name>
  <files>src/components/Properties/index.ts</files>
  <action>
Update src/components/Properties/index.ts to include a property component registry.

First, read the current file to see existing exports, then add the registry:

```typescript
/**
 * Property Panel Components
 *
 * Shared input components and property component registry.
 */

// Shared input components
export { NumberInput } from './NumberInput'
export { TextInput } from './TextInput'
export { ColorInput } from './ColorInput'
export { PropertySection } from './PropertySection'

// Property panel components
import React from 'react'
import type { ElementConfig } from '../../types/elements'
import { KnobProperties } from './KnobProperties'
import { SliderProperties } from './SliderProperties'
import { ButtonProperties } from './ButtonProperties'
import { LabelProperties } from './LabelProperties'
import { MeterProperties } from './MeterProperties'
import { ImageProperties } from './ImageProperties'
import { DropdownProperties } from './DropdownProperties'
import { CheckboxProperties } from './CheckboxProperties'
import { RadioGroupProperties } from './RadioGroupProperties'
import { ModulationMatrixProperties } from './ModulationMatrixProperties'
import { RangeSliderProperties } from './RangeSliderProperties'
import { RectangleProperties } from './RectangleProperties'
import { LineProperties } from './LineProperties'
import { PanelProperties } from './PanelProperties'
import { FrameProperties } from './FrameProperties'
import { GroupBoxProperties } from './GroupBoxProperties'
import { DbDisplayProperties } from './DbDisplayProperties'
import { FrequencyDisplayProperties } from './FrequencyDisplayProperties'
import { GainReductionMeterProperties } from './GainReductionMeterProperties'
import { PresetBrowserProperties } from './PresetBrowserProperties'
import { WaveformProperties } from './WaveformProperties'
import { OscilloscopeProperties } from './OscilloscopeProperties'
import { TextFieldProperties } from './TextFieldProperties'
import { CollapsibleProperties } from './CollapsibleProperties'
import { SvgGraphicProperties } from './SvgGraphicProperties'

/**
 * Property component props interface.
 * All property components receive the element and an update callback.
 */
export interface PropertyComponentProps<T extends ElementConfig = ElementConfig> {
  element: T
  onUpdate: (updates: Partial<ElementConfig>) => void
}

// Property component type
export type PropertyComponent = React.ComponentType<PropertyComponentProps>

/**
 * Registry mapping element type strings to their property components.
 * Use Map for O(1) lookup performance.
 */
export const propertyRegistry = new Map<ElementConfig['type'], PropertyComponent>([
  // Controls
  ['knob', KnobProperties as PropertyComponent],
  ['slider', SliderProperties as PropertyComponent],
  ['button', ButtonProperties as PropertyComponent],
  ['rangeslider', RangeSliderProperties as PropertyComponent],
  ['dropdown', DropdownProperties as PropertyComponent],
  ['checkbox', CheckboxProperties as PropertyComponent],
  ['radiogroup', RadioGroupProperties as PropertyComponent],
  ['textfield', TextFieldProperties as PropertyComponent],

  // Displays
  ['label', LabelProperties as PropertyComponent],
  ['meter', MeterProperties as PropertyComponent],
  ['dbdisplay', DbDisplayProperties as PropertyComponent],
  ['frequencydisplay', FrequencyDisplayProperties as PropertyComponent],
  ['gainreductionmeter', GainReductionMeterProperties as PropertyComponent],
  ['waveform', WaveformProperties as PropertyComponent],
  ['oscilloscope', OscilloscopeProperties as PropertyComponent],
  ['presetbrowser', PresetBrowserProperties as PropertyComponent],
  ['modulationmatrix', ModulationMatrixProperties as PropertyComponent],

  // Containers
  ['panel', PanelProperties as PropertyComponent],
  ['frame', FrameProperties as PropertyComponent],
  ['groupbox', GroupBoxProperties as PropertyComponent],
  ['collapsible', CollapsibleProperties as PropertyComponent],

  // Decorative
  ['image', ImageProperties as PropertyComponent],
  ['svggraphic', SvgGraphicProperties as PropertyComponent],
  ['rectangle', RectangleProperties as PropertyComponent],
  ['line', LineProperties as PropertyComponent],
])

/**
 * Get property component for an element type.
 * Returns undefined if type not found (element has no type-specific properties).
 */
export function getPropertyComponent(type: ElementConfig['type']): PropertyComponent | undefined {
  return propertyRegistry.get(type)
}

// Re-export property components for direct import if needed
export { KnobProperties } from './KnobProperties'
export { SliderProperties } from './SliderProperties'
export { ButtonProperties } from './ButtonProperties'
export { LabelProperties } from './LabelProperties'
export { MeterProperties } from './MeterProperties'
export { ImageProperties } from './ImageProperties'
export { DropdownProperties } from './DropdownProperties'
export { CheckboxProperties } from './CheckboxProperties'
export { RadioGroupProperties } from './RadioGroupProperties'
export { ModulationMatrixProperties } from './ModulationMatrixProperties'
export { RangeSliderProperties } from './RangeSliderProperties'
export { RectangleProperties } from './RectangleProperties'
export { LineProperties } from './LineProperties'
export { PanelProperties } from './PanelProperties'
export { FrameProperties } from './FrameProperties'
export { GroupBoxProperties } from './GroupBoxProperties'
export { DbDisplayProperties } from './DbDisplayProperties'
export { FrequencyDisplayProperties } from './FrequencyDisplayProperties'
export { GainReductionMeterProperties } from './GainReductionMeterProperties'
export { PresetBrowserProperties } from './PresetBrowserProperties'
export { WaveformProperties } from './WaveformProperties'
export { OscilloscopeProperties } from './OscilloscopeProperties'
export { TextFieldProperties } from './TextFieldProperties'
export { CollapsibleProperties } from './CollapsibleProperties'
export { SvgGraphicProperties } from './SvgGraphicProperties'
```
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>Property registry created with all 25 element types mapped</done>
</task>

<task type="auto">
  <name>Task 2: Refactor PropertyPanel.tsx to use registry</name>
  <files>src/components/Properties/PropertyPanel.tsx</files>
  <action>
Replace the conditional chain in PropertyPanel.tsx with registry lookup.

```typescript
import { useStore } from '../../store'
import { ElementConfig } from '../../types/elements'
import { NumberInput, TextInput, PropertySection, getPropertyComponent } from './'

export function PropertyPanel() {
  const selectedIds = useStore((state) => state.selectedIds)
  const elements = useStore((state) => state.elements)
  const updateElement = useStore((state) => state.updateElement)
  const liveDragValues = useStore((state) => state.liveDragValues)

  // Get the selected element by finding it in the elements array
  const getElement = (id: string) => elements.find((el) => el.id === id)

  // Handle no selection
  if (selectedIds.length === 0) {
    return (
      <div className="text-center text-gray-400 py-8">
        <p className="text-sm">No element selected</p>
        <p className="text-xs mt-2">Click an element on the canvas to edit its properties</p>
      </div>
    )
  }

  // Handle multi-selection
  if (selectedIds.length > 1) {
    return (
      <div className="text-center text-gray-400 py-8">
        <p className="text-sm">Multiple elements selected</p>
        <p className="text-xs mt-2">{selectedIds.length} elements</p>
        <p className="text-xs mt-2 text-gray-500">Multi-edit coming in Phase 6</p>
      </div>
    )
  }

  // Single element selected
  const element = getElement(selectedIds[0]!)
  if (!element) {
    return (
      <div className="text-center text-gray-400 py-8">
        <p className="text-sm">Element not found</p>
      </div>
    )
  }

  // Update helper
  const update = (updates: Partial<ElementConfig>) => {
    updateElement(element.id, updates)
  }

  // Merge live values if available (live values take precedence during drag/resize)
  const liveValues = liveDragValues?.[element.id]
  const displayX = liveValues?.x ?? element.x
  const displayY = liveValues?.y ?? element.y
  const displayWidth = liveValues?.width ?? element.width
  const displayHeight = liveValues?.height ?? element.height

  // Get type-specific property component from registry
  const TypeSpecificProperties = getPropertyComponent(element.type)

  return (
    <div className="space-y-6">
      {/* Position & Size */}
      <PropertySection title="Position & Size">
        <div className="grid grid-cols-2 gap-3">
          <NumberInput
            label="X"
            value={displayX}
            onChange={(x) => update({ x })}
          />
          <NumberInput
            label="Y"
            value={displayY}
            onChange={(y) => update({ y })}
          />
          <NumberInput
            label="Width"
            value={displayWidth}
            onChange={(width) => update({ width })}
            min={20}
          />
          <NumberInput
            label="Height"
            value={displayHeight}
            onChange={(height) => update({ height })}
            min={20}
          />
        </div>
      </PropertySection>

      {/* Identity */}
      <PropertySection title="Identity">
        <TextInput
          label="Name"
          value={element.name}
          onChange={(name) => update({ name })}
        />
        <TextInput
          label="Parameter ID"
          value={element.parameterId || ''}
          onChange={(parameterId) =>
            update({ parameterId: parameterId || undefined })
          }
          placeholder="Optional JUCE parameter binding"
        />
      </PropertySection>

      {/* Lock */}
      <PropertySection title="Lock">
        <label className="flex items-center gap-2 text-sm">
          <input
            type="checkbox"
            checked={element.locked}
            onChange={(e) => update({ locked: e.target.checked })}
            className="rounded border-gray-600 bg-gray-700 text-blue-500 focus:ring-blue-500"
          />
          <span className="text-gray-300">Lock element</span>
        </label>
        <p className="text-xs text-gray-500 mt-1">
          Locked elements cannot be moved or resized
        </p>
      </PropertySection>

      {/* Type-specific properties via registry */}
      {TypeSpecificProperties && (
        <TypeSpecificProperties element={element} onUpdate={update} />
      )}
    </div>
  )
}
```

Key changes:
1. Remove all 25 individual property component imports - now handled by registry
2. Remove all 26 type guard imports (isKnob, isSlider, etc.)
3. Remove all 26 conditional checks
4. Single registry lookup: `getPropertyComponent(element.type)`
5. Render type-specific component if found
  </action>
  <verify>
Run build and verify property panels work:
```bash
npm run build
npm run dev
# Manually verify: select knob, slider, button - property panels show correct fields
```
  </verify>
  <done>PropertyPanel.tsx uses registry lookup; conditional chain removed</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npm run dev` - application starts
3. Test property panels: select each element type, verify correct property fields appear
4. Verify PropertyPanel.tsx no longer contains isKnob, isSlider conditional checks
5. Verify Properties/index.ts contains registry with all 25 types
</verification>

<success_criteria>
- [ ] Properties/index.ts exports propertyRegistry Map with 25 entries
- [ ] PropertyPanel.tsx uses getPropertyComponent() instead of conditional chain
- [ ] PropertyPanel.tsx file size reduced (from ~207 LOC to ~100 LOC)
- [ ] All element types show correct property panels when selected
- [ ] Build passes without TypeScript errors
- [ ] No changes to individual property component files required
</success_criteria>

<output>
After completion, create `.planning/phases/19-architecture-refactoring/19-03-SUMMARY.md`
</output>
