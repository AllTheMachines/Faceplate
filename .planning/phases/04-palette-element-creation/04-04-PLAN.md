---
phase: 04-palette-element-creation
plan: 04
type: execute
wave: 2
depends_on: ["04-02"]
files_modified:
  - package.json
  - src/utils/svgImport.ts
  - src/components/Palette/CustomSVGUpload.tsx
  - src/components/Palette/Palette.tsx
autonomous: true

must_haves:
  truths:
    - "User can import custom SVG files through the palette"
    - "SVG layer names are detected (indicator, thumb, track, fill)"
    - "Detected layers are shown in a preview before adding to canvas"
  artifacts:
    - path: "src/utils/svgImport.ts"
      provides: "SVG parsing and layer detection utility"
      exports: ["parseSVGFile", "SVGLayer"]
    - path: "src/components/Palette/CustomSVGUpload.tsx"
      provides: "File upload component with layer preview"
      exports: ["CustomSVGUpload"]
  key_links:
    - from: "src/components/Palette/CustomSVGUpload.tsx"
      to: "src/utils/svgImport.ts"
      via: "parseSVGFile function"
      pattern: "parseSVGFile"
    - from: "src/components/Palette/CustomSVGUpload.tsx"
      to: "react-dropzone"
      via: "useDropzone hook"
      pattern: "useDropzone"
---

<objective>
Implement custom SVG import with layer name detection

Purpose: Allow advanced users to import their own SVG artwork with automatic layer detection (indicator, thumb, track, fill)
Output: SVG upload component with layer preview, parses and displays detected layers before adding as image element
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-palette-element-creation/04-02-SUMMARY.md
@src/components/Palette/Palette.tsx
@src/types/elements.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install svgson and react-dropzone</name>
  <files>package.json</files>
  <action>
Install SVG parsing and file upload libraries:

```bash
npm install svgson react-dropzone
```

- svgson: Parses SVG to JSON for easy traversal (2.4KB gzipped)
- react-dropzone: Accessible file upload with drag-drop (touch support, validation)
  </action>
  <verify>Run `npm ls svgson react-dropzone` shows both installed</verify>
  <done>svgson and react-dropzone are in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create SVG parsing utility</name>
  <files>src/utils/svgImport.ts</files>
  <action>
Create utility for parsing SVG files and detecting layers:

```typescript
import { parse, INode } from 'svgson';

export interface SVGLayer {
  name: string;
  type: 'indicator' | 'thumb' | 'track' | 'fill' | 'glow' | 'unknown';
  element: INode;
}

export interface ParsedSVG {
  layers: SVGLayer[];
  viewBox: string | null;
  width: number;
  height: number;
  svgString: string;
}

/**
 * Detect layer type from name using naming conventions
 * Matches: indicator, pointer (knobs), thumb/handle (sliders), track/background, fill/progress, glow/highlight
 */
function detectLayerType(name: string): SVGLayer['type'] {
  const lowerName = name.toLowerCase();

  if (lowerName.includes('indicator') || lowerName.includes('pointer')) {
    return 'indicator';
  }
  if (lowerName.includes('thumb') || lowerName.includes('handle')) {
    return 'thumb';
  }
  if (lowerName.includes('track') || lowerName.includes('background')) {
    return 'track';
  }
  if (lowerName.includes('fill') || lowerName.includes('progress')) {
    return 'fill';
  }
  if (lowerName.includes('glow') || lowerName.includes('highlight')) {
    return 'glow';
  }

  return 'unknown';
}

/**
 * Traverse SVG tree and extract named layers
 */
function extractLayers(node: INode, layers: SVGLayer[]): void {
  // Check for layer indicators (id or inkscape:label)
  const id = node.attributes?.id || '';
  const inkscapeLabel = node.attributes?.['inkscape:label'] || '';
  const layerName = inkscapeLabel || id;

  if (layerName) {
    const type = detectLayerType(layerName);
    if (type !== 'unknown') {
      layers.push({ name: layerName, type, element: node });
    }
  }

  // Recurse into children
  if (node.children) {
    for (const child of node.children) {
      extractLayers(child, layers);
    }
  }
}

/**
 * Parse SVG file string and extract layer information
 */
export async function parseSVGFile(svgString: string): Promise<ParsedSVG> {
  const parsed = await parse(svgString);

  // Extract viewBox
  const viewBox = parsed.attributes?.viewBox || null;

  // Extract dimensions (from viewBox or explicit width/height)
  let width = 100;
  let height = 100;

  if (viewBox) {
    const parts = viewBox.split(/\s+/);
    if (parts.length >= 4) {
      width = parseFloat(parts[2]) || 100;
      height = parseFloat(parts[3]) || 100;
    }
  } else {
    width = parseFloat(parsed.attributes?.width || '100');
    height = parseFloat(parsed.attributes?.height || '100');
  }

  // Extract layers
  const layers: SVGLayer[] = [];
  extractLayers(parsed, layers);

  return {
    layers,
    viewBox,
    width,
    height,
    svgString,
  };
}

/**
 * Convert SVG string to data URL for use as image src
 */
export function svgToDataUrl(svgString: string): string {
  const encoded = encodeURIComponent(svgString);
  return `data:image/svg+xml,${encoded}`;
}
```
  </action>
  <verify>
Create a simple test by importing and calling parseSVGFile with a test SVG string.
Or run `npm run build` to ensure TypeScript types are correct.
  </verify>
  <done>
svgImport.ts exports parseSVGFile, svgToDataUrl, SVGLayer, ParsedSVG.
Layer detection works for indicator, thumb, track, fill, glow.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CustomSVGUpload component</name>
  <files>
    src/components/Palette/CustomSVGUpload.tsx
    src/components/Palette/Palette.tsx
  </files>
  <action>
Create SVG upload component with layer preview:

**src/components/Palette/CustomSVGUpload.tsx:**
```typescript
import { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { parseSVGFile, svgToDataUrl, ParsedSVG } from '../../utils/svgImport';
import { useStore } from '../../store';
import { createImage } from '../../types/elements';

export function CustomSVGUpload() {
  const [parsedSVG, setParsedSVG] = useState<ParsedSVG | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isOpen, setIsOpen] = useState(false);

  const addElement = useStore((state) => state.addElement);

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    try {
      const svgString = await file.text();
      const result = await parseSVGFile(svgString);
      setParsedSVG(result);
      setError(null);
    } catch (err) {
      setError('Failed to parse SVG file');
      console.error(err);
    }
  }, []);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/svg+xml': ['.svg'],
    },
    maxFiles: 1,
  });

  const handleAddToCanvas = () => {
    if (!parsedSVG) return;

    // Create image element with SVG as data URL
    const dataUrl = svgToDataUrl(parsedSVG.svgString);
    const element = createImage({
      x: 100, // Default position (will be centered later or dropped)
      y: 100,
      width: parsedSVG.width,
      height: parsedSVG.height,
      src: dataUrl,
      name: 'Custom SVG',
    });

    addElement(element);
    setParsedSVG(null);
    setIsOpen(false);
  };

  const handleCancel = () => {
    setParsedSVG(null);
    setError(null);
    setIsOpen(false);
  };

  if (!isOpen) {
    return (
      <button
        onClick={() => setIsOpen(true)}
        className="w-full mt-4 px-4 py-2 border border-dashed border-gray-600 rounded text-gray-400 hover:border-gray-500 hover:text-gray-300 transition-colors"
      >
        + Import Custom SVG
      </button>
    );
  }

  return (
    <div className="mt-4 p-4 bg-gray-750 rounded border border-gray-700">
      <div className="flex justify-between items-center mb-3">
        <h3 className="text-sm font-medium text-gray-200">Import Custom SVG</h3>
        <button
          onClick={handleCancel}
          className="text-gray-400 hover:text-gray-300"
        >
          ×
        </button>
      </div>

      {!parsedSVG ? (
        <div
          {...getRootProps()}
          className={`
            border-2 border-dashed rounded-lg p-6 text-center cursor-pointer
            ${isDragActive ? 'border-blue-500 bg-blue-500/10' : 'border-gray-600 hover:border-gray-500'}
          `}
        >
          <input {...getInputProps()} />
          {isDragActive ? (
            <p className="text-sm text-blue-400">Drop SVG file here...</p>
          ) : (
            <p className="text-sm text-gray-400">Drag SVG file here or click to browse</p>
          )}
        </div>
      ) : (
        <div>
          {/* Preview */}
          <div className="mb-3 flex justify-center">
            <img
              src={svgToDataUrl(parsedSVG.svgString)}
              alt="SVG Preview"
              className="max-w-full max-h-24 border border-gray-600 rounded"
            />
          </div>

          {/* Dimensions */}
          <p className="text-xs text-gray-400 mb-2">
            Size: {parsedSVG.width} × {parsedSVG.height}
          </p>

          {/* Detected Layers */}
          {parsedSVG.layers.length > 0 ? (
            <div className="mb-3">
              <p className="text-xs font-medium text-gray-300 mb-1">Detected Layers:</p>
              <ul className="text-xs text-gray-400 space-y-1">
                {parsedSVG.layers.map((layer, i) => (
                  <li key={i} className="flex items-center gap-2">
                    <span className={`
                      px-1.5 py-0.5 rounded text-xs
                      ${layer.type === 'indicator' ? 'bg-blue-900 text-blue-300' : ''}
                      ${layer.type === 'thumb' ? 'bg-green-900 text-green-300' : ''}
                      ${layer.type === 'track' ? 'bg-gray-600 text-gray-300' : ''}
                      ${layer.type === 'fill' ? 'bg-purple-900 text-purple-300' : ''}
                      ${layer.type === 'glow' ? 'bg-yellow-900 text-yellow-300' : ''}
                    `}>
                      {layer.type}
                    </span>
                    <span>{layer.name}</span>
                  </li>
                ))}
              </ul>
            </div>
          ) : (
            <p className="text-xs text-gray-500 mb-3">
              No named layers detected. SVG will be added as static image.
            </p>
          )}

          {/* Actions */}
          <div className="flex gap-2">
            <button
              onClick={handleAddToCanvas}
              className="flex-1 px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded transition-colors"
            >
              Add to Canvas
            </button>
            <button
              onClick={handleCancel}
              className="px-3 py-1.5 text-gray-400 hover:text-gray-300 text-sm transition-colors"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {error && <p className="text-red-400 text-xs mt-2">{error}</p>}
    </div>
  );
}
```

**Update src/components/Palette/Palette.tsx:**
- Import CustomSVGUpload
- Add CustomSVGUpload at the bottom of the palette, after all categories

```typescript
import { CustomSVGUpload } from './CustomSVGUpload';

// In the Palette component JSX, after categories:
<CustomSVGUpload />
```
  </action>
  <verify>
Run `npm run dev`:
1. Click "+ Import Custom SVG" button in palette
2. Drop an SVG file - preview shows
3. If SVG has named layers (indicator, thumb, etc.), they appear in list
4. Click "Add to Canvas" - image element added
  </verify>
  <done>
CustomSVGUpload component shows upload zone.
Layer detection displays found layers with type badges.
"Add to Canvas" creates image element with SVG data URL.
Palette includes CustomSVGUpload button.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `npm run build` - passes without errors
2. Run `npm run dev` - app loads
3. Click "+ Import Custom SVG" in palette
4. Drop SVG file - shows preview and dimensions
5. If SVG has layers named "indicator", "track", etc. - they appear with type badges
6. Click "Add to Canvas" - image element appears at default position
7. Cancel button dismisses the upload panel
</verification>

<success_criteria>
- svgson and react-dropzone installed
- parseSVGFile extracts layers with type detection
- CustomSVGUpload shows dropzone, preview, layer list
- Layer types detected: indicator, thumb, track, fill, glow
- SVG added to canvas as image element with data URL src
</success_criteria>

<output>
After completion, create `.planning/phases/04-palette-element-creation/04-04-SUMMARY.md`
</output>
