---
phase: 04-palette-element-creation
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Palette/Palette.tsx
  - src/components/Palette/PaletteCategory.tsx
  - src/components/Palette/PaletteItem.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can drag an element from the palette and drop it onto the canvas"
    - "All 9 palette items (Knob, Arc Knob, V Slider, H Slider, Momentary, Toggle, Label, Meter, Image) create elements when dropped"
  artifacts:
    - path: "src/components/Palette/Palette.tsx"
      provides: "Palette items with base type and variant object"
      contains: "type: 'knob'"
    - path: "src/components/Palette/PaletteCategory.tsx"
      provides: "Passes elementType from type field to PaletteItem"
      contains: "elementType={item.type}"
    - path: "src/components/Palette/PaletteItem.tsx"
      provides: "Receives and merges variant from palette items"
      contains: "variant: { ...item.variant, ...variant }"
  key_links:
    - from: "src/components/Palette/Palette.tsx"
      to: "src/App.tsx handleDragEnd"
      via: "elementType uses base type (knob, slider, button) not variant type (knob-arc, slider-vertical)"
      pattern: "type: '(knob|slider|button|label|meter|image)'"
---

<objective>
Fix element type mismatch in drag-drop by normalizing palette items to use base types with variant objects.

Purpose: Enable all 9 palette items to successfully create elements when dropped on canvas. Currently only 3/9 work due to elementType mismatch.

Output: Palette items use base types (knob, slider, button) in `type` field with configuration in `variant` object, matching App.tsx handleDragEnd switch statement.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-palette-element-creation/04-VERIFICATION.md

Key files:
@src/components/Palette/Palette.tsx
@src/components/Palette/PaletteCategory.tsx
@src/components/Palette/PaletteItem.tsx
@src/App.tsx (read-only reference - do not modify)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Normalize palette items to base types with variant objects</name>
  <files>src/components/Palette/Palette.tsx</files>
  <action>
Update the paletteCategories array to use base types in the `type` field with configuration in `variant` object:

Current broken pattern:
```typescript
{ id: 'knob-arc', type: 'knob-arc', name: 'Arc Knob' }
```

New working pattern:
```typescript
{ id: 'knob-arc', type: 'knob', name: 'Arc Knob', variant: { style: 'arc' } }
```

Update ALL items in paletteCategories:

1. Rotary Controls:
   - `{ id: 'knob-standard', type: 'knob', name: 'Knob' }` (unchanged, no variant needed)
   - `{ id: 'knob-arc', type: 'knob', name: 'Arc Knob', variant: { style: 'arc' } }`

2. Linear Controls:
   - `{ id: 'slider-vertical', type: 'slider', name: 'V Slider', variant: { orientation: 'vertical' } }`
   - `{ id: 'slider-horizontal', type: 'slider', name: 'H Slider', variant: { orientation: 'horizontal' } }`

3. Buttons & Switches:
   - `{ id: 'button-momentary', type: 'button', name: 'Momentary', variant: { mode: 'momentary' } }`
   - `{ id: 'button-toggle', type: 'button', name: 'Toggle', variant: { mode: 'toggle' } }`

4. Value Displays:
   - `{ id: 'label', type: 'label', name: 'Label' }` (unchanged)

5. Meters:
   - `{ id: 'meter-vertical', type: 'meter', name: 'Meter', variant: { orientation: 'vertical' } }`

6. Images & Decorative:
   - `{ id: 'image', type: 'image', name: 'Image' }` (unchanged)
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>All palette items use base types (knob, slider, button, label, meter, image) in the type field</done>
</task>

<task type="auto">
  <name>Task 2: Update PaletteCategory to pass variant and elementType correctly</name>
  <files>src/components/Palette/PaletteCategory.tsx</files>
  <action>
The PaletteCategory component passes item data to PaletteItem. Ensure it passes:
- `elementType` from `item.type` (the base type)
- `variant` from `item.variant` (the configuration object, may be undefined)

Read the current implementation and update the PaletteItem call to use:
```tsx
<PaletteItem
  key={item.id}
  id={item.id}
  elementType={item.type}  // Use item.type, not item.id
  name={item.name}
  variant={item.variant}   // Pass the variant object
/>
```

The current implementation may already pass `variant={variant}` where `variant` comes from category level - this needs to be changed to `variant={item.variant}` so each item carries its own variant config.
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>PaletteCategory passes item.type as elementType and item.variant as variant to PaletteItem</done>
</task>

<task type="auto">
  <name>Task 3: Update PaletteItem to handle variant from item</name>
  <files>src/components/Palette/PaletteItem.tsx</files>
  <action>
Update the PaletteItem component to:

1. Use the variant from props (passed from Palette items) for both:
   - Preview rendering (createPreviewElement)
   - Drag data payload

2. The switch statement in createPreviewElement needs to continue working with old-style type strings ('knob-arc', 'slider-vertical', etc.) for the preview rendering, but now receive base type ('knob', 'slider') plus variant object.

Since elementType is now a base type, update createPreviewElement to use the base type and merge in the variant:

For knob elements:
```typescript
case 'knob':
  return createKnob({
    ...baseOverrides,
    diameter: 40,
    width: 40,
    height: 40,
    ...variant, // variant contains { style: 'arc' } for arc knobs
  })
```

Remove the duplicate 'knob-arc' case (it's now handled by 'knob' + variant).

For slider elements:
```typescript
case 'slider':
  return createSlider({
    ...baseOverrides,
    width: variant?.orientation === 'horizontal' ? 60 : 20,
    height: variant?.orientation === 'horizontal' ? 20 : 60,
    thumbWidth: 12,
    thumbHeight: 12,
    ...variant, // variant contains { orientation: 'vertical' | 'horizontal' }
  })
```

Remove the duplicate 'slider-vertical' and 'slider-horizontal' cases.

For button elements:
```typescript
case 'button':
  return createButton({
    ...baseOverrides,
    width: 60,
    height: 30,
    label: variant?.mode === 'toggle' ? 'TGL' : 'BTN',
    ...variant, // variant contains { mode: 'momentary' | 'toggle' }
  })
```

Remove the duplicate 'button-momentary' and 'button-toggle' cases.

For meter elements:
```typescript
case 'meter':
  return createMeter({
    ...baseOverrides,
    width: 16,
    height: 60,
    ...variant, // variant contains { orientation: 'vertical' }
  })
```

Remove the duplicate 'meter-vertical' case.

Keep label and image cases unchanged (they don't have variants).

The drag data payload should remain as: `data: { elementType, variant }` which now correctly passes base type + variant to App.tsx handleDragEnd.
  </action>
  <verify>
1. TypeScript compiles: `npm run build`
2. Start dev server: `npm run dev`
3. Verify ALL 9 palette items show correct previews (not broken)
  </verify>
  <done>PaletteItem uses base types with variant merging, all 9 palette items render correct previews and drag with correct data</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Build check:** `npm run build` passes without errors
2. **Manual drag-drop test:**
   - Run `npm run dev`
   - Drag each of the 9 palette items onto canvas
   - Verify each creates an element (no items fail silently)
3. **Element type check:**
   - Arc Knob should create a knob with arc style
   - V Slider should create vertical slider
   - H Slider should create horizontal slider
   - Momentary should create momentary button
   - Toggle should create toggle button
   - Meter should create vertical meter
</verification>

<success_criteria>
- All 9 palette items successfully create elements when dropped on canvas
- Palette items use base types (knob, slider, button) not variant types (knob-arc, slider-vertical)
- Variant configuration (style, orientation, mode) is passed through to element factory functions
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-palette-element-creation/04-05-SUMMARY.md`
</output>
