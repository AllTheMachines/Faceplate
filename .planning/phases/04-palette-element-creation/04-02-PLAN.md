---
phase: 04-palette-element-creation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/App.tsx
  - src/components/Canvas/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag an element from the palette and drop it onto the canvas"
    - "Dropped elements appear at the correct canvas position (accounting for zoom/pan)"
    - "Elements cannot be dropped outside the canvas area"
  artifacts:
    - path: "src/App.tsx"
      provides: "DndContext wrapper with handleDragEnd"
      contains: "DndContext"
    - path: "src/components/Canvas/Canvas.tsx"
      provides: "Droppable canvas area"
      contains: "useDroppable"
  key_links:
    - from: "src/App.tsx"
      to: "src/store/index.ts"
      via: "addElement action"
      pattern: "addElement"
    - from: "src/App.tsx"
      to: "src/types/elements.ts"
      via: "factory functions"
      pattern: "create(Knob|Slider|Button|Label|Meter|Image)"
---

<objective>
Enable drag-drop from palette to canvas with correct coordinate transforms

Purpose: Complete the palette-to-canvas workflow so users can instantiate elements by dragging
Output: Elements appear at correct canvas coordinates when dropped, accounting for zoom/pan
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-palette-element-creation/04-01-SUMMARY.md
@src/App.tsx
@src/components/Canvas/Canvas.tsx
@src/store/index.ts
@src/store/viewportSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap App with DndContext</name>
  <files>src/App.tsx</files>
  <action>
Wrap the app content with DndContext from @dnd-kit/core:

1. Import from @dnd-kit/core: DndContext, DragEndEvent, PointerSensor, useSensor, useSensors, DragOverlay

2. Configure sensors with activation constraint:
```typescript
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: {
      distance: 8, // 8px drag threshold prevents accidental drags
    },
  })
);
```

3. Get store state and actions needed:
- scale, offsetX, offsetY from viewport state
- addElement action
- getCanvasViewportOffset function (see below)

4. Create handleDragEnd function:
```typescript
const handleDragEnd = (event: DragEndEvent) => {
  const { active, over } = event;

  // Only handle drops over canvas
  if (!over || over.id !== 'canvas-droppable') {
    return;
  }

  // Get element type and variant from draggable data
  const { elementType, variant } = active.data.current || {};
  if (!elementType) return;

  // Get the canvas viewport element to calculate offset
  const canvasViewport = document.querySelector('.canvas-viewport');
  if (!canvasViewport) return;
  const viewportRect = canvasViewport.getBoundingClientRect();

  // Get drop position from the pointer event
  // Use delta to calculate final position from initial pointer position
  const pointerEvent = event.activatorEvent as PointerEvent;
  const finalX = pointerEvent.clientX + (event.delta?.x || 0);
  const finalY = pointerEvent.clientY + (event.delta?.y || 0);

  // Transform screen coordinates to canvas coordinates:
  // 1. Subtract viewport offset to get relative position in viewport
  // 2. Subtract offsetX/Y to account for pan
  // 3. Divide by scale to account for zoom
  const canvasX = (finalX - viewportRect.left - offsetX) / scale;
  const canvasY = (finalY - viewportRect.top - offsetY) / scale;

  // Create element using factory function based on type
  let newElement;
  switch (elementType) {
    case 'knob':
      newElement = createKnob({ x: canvasX, y: canvasY, ...variant });
      break;
    case 'slider':
      newElement = createSlider({ x: canvasX, y: canvasY, ...variant });
      break;
    case 'button':
      newElement = createButton({ x: canvasX, y: canvasY, ...variant });
      break;
    case 'label':
      newElement = createLabel({ x: canvasX, y: canvasY, ...variant });
      break;
    case 'meter':
      newElement = createMeter({ x: canvasX, y: canvasY, ...variant });
      break;
    case 'image':
      newElement = createImage({ x: canvasX, y: canvasY, ...variant });
      break;
    default:
      return;
  }

  addElement(newElement);
};
```

5. Wrap ThreePanelLayout with DndContext:
```tsx
<DndContext sensors={sensors} onDragEnd={handleDragEnd}>
  <ThreePanelLayout>
    <CanvasStage />
  </ThreePanelLayout>
</DndContext>
```

6. Remove demo elements from useEffect - with palette working, users add their own elements.
  </action>
  <verify>
Run `npm run build` - no TypeScript errors.
  </verify>
  <done>
App.tsx wraps content with DndContext.
handleDragEnd transforms screen coordinates to canvas coordinates.
Factory functions create elements at drop position.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make Canvas droppable</name>
  <files>src/components/Canvas/Canvas.tsx</files>
  <action>
Add useDroppable to Canvas component:

1. Import useDroppable from @dnd-kit/core

2. Call useDroppable in Canvas component:
```typescript
const { setNodeRef: setDroppableRef, isOver } = useDroppable({
  id: 'canvas-droppable',
});
```

3. Apply ref to the canvas-background div (the actual drop target):
- Merge refs: canvasBackgroundRef and setDroppableRef
- Use a callback ref or refs utility to combine them:
```typescript
const combinedRef = useCallback((node: HTMLDivElement | null) => {
  canvasBackgroundRef.current = node;
  setDroppableRef(node);
}, [setDroppableRef]);
```

4. Add visual feedback when dragging over canvas:
- Apply ring-2 ring-blue-500 ring-opacity-50 when isOver is true
- This shows the user a valid drop zone

5. The droppable area should be the canvas-background (not the viewport) so drops outside the canvas bounds are rejected.
  </action>
  <verify>
Run `npm run dev`:
1. Drag a palette item - canvas shows blue ring when hovering over it
2. Drop outside canvas - element is NOT created
3. Drop inside canvas - element appears at cursor position
  </verify>
  <done>
Canvas.tsx uses useDroppable with id 'canvas-droppable'.
Visual feedback shows when dragging over canvas.
Ref properly attached to canvas-background div.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test coordinate transform at different zoom levels</name>
  <files>None (verification only)</files>
  <action>
Manually verify coordinate transform works correctly:

1. At 100% zoom, no pan:
   - Drop an element - should appear at cursor position

2. At 200% zoom (scroll to zoom in):
   - Drop an element - should appear at cursor position (not doubled)

3. At 50% zoom (scroll to zoom out):
   - Drop an element - should appear at cursor position (not halved)

4. After panning (spacebar + drag to pan):
   - Drop an element - should appear at cursor position (not offset)

5. Combined zoom + pan:
   - Zoom to 150%, pan to the right
   - Drop element - should appear exactly at cursor

If elements appear at incorrect positions, debug the coordinate transform formula.
The correct formula is: (screenPos - viewportRect - offset) / scale
  </action>
  <verify>
Run `npm run dev` and test:
1. Drop element at 100% zoom - correct position
2. Drop element at 200% zoom - correct position
3. Drop element at 50% zoom - correct position
4. Drop element after pan - correct position
5. Drop element after zoom + pan - correct position
  </verify>
  <done>
Elements drop at correct canvas coordinates at all zoom levels and pan offsets.
No visual offset between cursor and dropped element position.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `npm run build` - passes without errors
2. Run `npm run dev` - app loads with empty canvas
3. Drag palette item to canvas - element created at cursor position
4. Test at 200% zoom - position correct
5. Test at 50% zoom - position correct
6. Test after panning - position correct
7. Drop outside canvas - no element created
</verification>

<success_criteria>
- DndContext wraps app with PointerSensor (8px activation)
- Canvas uses useDroppable with id 'canvas-droppable'
- handleDragEnd creates elements using factory functions
- Coordinate transform: (screen - viewportRect - offset) / scale
- Elements appear at correct position at all zoom/pan states
</success_criteria>

<output>
After completion, create `.planning/phases/04-palette-element-creation/04-02-SUMMARY.md`
</output>
