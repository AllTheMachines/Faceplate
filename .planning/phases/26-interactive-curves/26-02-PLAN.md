---
phase: 26-interactive-curves
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx
  - src/components/elements/renderers/displays/curves/FilterResponseRenderer.tsx
  - src/components/elements/renderers/displays/index.ts
  - src/components/elements/renderers/index.ts
autonomous: true

must_haves:
  truths:
    - "EQ Curve displays composite frequency response from all bands"
    - "EQ Curve shows handles at band frequency/gain positions"
    - "EQ Curve handles highlight on hover"
    - "Filter Response displays single filter curve with cutoff handle"
    - "Both elements use logarithmic frequency scale"
  artifacts:
    - path: "src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx"
      provides: "Canvas renderer for EQ frequency response curves"
      min_lines: 100
    - path: "src/components/elements/renderers/displays/curves/FilterResponseRenderer.tsx"
      provides: "Canvas renderer for filter frequency response"
      min_lines: 80
  key_links:
    - from: "src/components/elements/renderers/index.ts"
      to: "EQCurveRenderer"
      via: "rendererRegistry entry"
      pattern: "eqcurve.*EQCurveRenderer"
    - from: "src/components/elements/renderers/index.ts"
      to: "FilterResponseRenderer"
      via: "rendererRegistry entry"
      pattern: "filterresponse.*FilterResponseRenderer"
---

<objective>
Create Canvas renderers for EQ Curve and Filter Response elements

Purpose: Enable frequency response visualization with logarithmic frequency scale, biquad filter calculations, and interactive handles
Output: EQCurveRenderer.tsx, FilterResponseRenderer.tsx, registered in rendererRegistry
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-interactive-curves/26-CONTEXT.md
@.planning/phases/26-interactive-curves/26-RESEARCH.md
@src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx
@src/hooks/useCanvasSetup.ts
@src/utils/audioMath.ts
@src/utils/curveRendering.ts
@src/types/elements/curves.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EQ Curve renderer</name>
  <files>src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx</files>
  <action>
Create src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx:

Follow SpectrumAnalyzerRenderer.tsx pattern:
- Import useCanvasSetup hook
- Import curve types from types/elements/curves
- Import audioMath utilities (frequencyToX, dbToY, calculateBiquadResponse)
- Import curveRendering utilities (drawSmoothCurve, drawHandle, isPointInHandle, drawFrequencyGrid, generateMockEQBands)

Renderer implementation:
1. Use useCanvasSetup(width, height, canvasScale) for HiDPI Canvas
2. Generate static mock bands with useMemo: generateMockEQBands(config.bandCount)
3. Track hoveredBand state with useState for handle hover effects

useLayoutEffect drawing logic:
1. Clear canvas with backgroundColor
2. If showGrid, draw frequency grid with drawFrequencyGrid()
3. Calculate composite frequency response:
   - Loop 200 samples across width
   - For each x, convert to frequency with xToFrequency
   - Sum all band contributions using calculateBiquadResponse
   - Convert total dB to y coordinate with dbToY
   - Collect points array
4. If showIndividualBands, draw each band's curve with reduced opacity (0.3)
5. Draw composite curve with drawSmoothCurve()
6. If showFill, include fill parameters
7. Draw handles at each band position:
   - Calculate x = frequencyToX(band.frequency)
   - Calculate y = dbToY(band.gain)
   - Draw with drawHandle(ctx, x, y, hoveredBand === i, handleColor, handleHoverColor)

Mouse event handlers:
- onMouseMove: Check each handle with isPointInHandle, update hoveredBand state
- onMouseLeave: Clear hoveredBand state

Canvas cursor: 'pointer' when hoveredBand !== null, 'default' otherwise

Static preview per CONTEXT.md - handles shown at fixed positions, not draggable.
  </action>
  <verify>File exists and TypeScript compiles with npx tsc --noEmit</verify>
  <done>EQ Curve renderer displays composite frequency response with hoverable handles at band positions</done>
</task>

<task type="auto">
  <name>Task 2: Create Filter Response renderer and register both</name>
  <files>src/components/elements/renderers/displays/curves/FilterResponseRenderer.tsx, src/components/elements/renderers/displays/curves/index.ts, src/components/elements/renderers/displays/index.ts, src/components/elements/renderers/index.ts</files>
  <action>
Create src/components/elements/renderers/displays/curves/FilterResponseRenderer.tsx:

Similar to EQ Curve but simpler (single filter):
- Import useCanvasSetup, curve types, audioMath utilities, curveRendering utilities
- Track hoveredHandle state (single handle for cutoff)

useLayoutEffect drawing logic:
1. Clear canvas with backgroundColor
2. If showGrid, draw frequency grid with drawFrequencyGrid()
3. Calculate filter frequency response:
   - Loop 200 samples across width
   - For each x, convert to frequency with xToFrequency
   - Calculate response using calculateFilterResponse(freq, filterType, cutoffFrequency, resonance, gain)
   - Convert dB to y coordinate with dbToY
   - Collect points array
4. Draw curve with drawSmoothCurve()
5. If showFill, include fill parameters
6. Draw single handle at cutoff position:
   - x = frequencyToX(cutoffFrequency)
   - y = dbToY(0 or response at cutoff) - for visual placement at curve
   - Draw with drawHandle()

Mouse event handlers:
- onMouseMove: Check single handle with isPointInHandle, update hoveredHandle
- onMouseLeave: Clear hoveredHandle

Create src/components/elements/renderers/displays/curves/index.ts:
```typescript
export { EQCurveRenderer } from './EQCurveRenderer'
export { FilterResponseRenderer } from './FilterResponseRenderer'
```

Update src/components/elements/renderers/displays/index.ts:
- Add export for curves: `export * from './curves'`

Update src/components/elements/renderers/index.ts:
- Import EQCurveRenderer, FilterResponseRenderer from './displays'
- Add to rendererRegistry:
  - ['eqcurve', EQCurveRenderer as RendererComponent]
  - ['filterresponse', FilterResponseRenderer as RendererComponent]
- Add to re-exports
  </action>
  <verify>npx tsc --noEmit passes, rendererRegistry includes both new types</verify>
  <done>Filter Response renderer displays single filter curve, both renderers registered in rendererRegistry</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. EQCurveRenderer.tsx exists in src/components/elements/renderers/displays/curves/
3. FilterResponseRenderer.tsx exists in src/components/elements/renderers/displays/curves/
4. Both renderers exported from displays/index.ts
5. rendererRegistry includes 'eqcurve' and 'filterresponse' entries
</verification>

<success_criteria>
- EQ Curve displays composite frequency response curve with logarithmic frequency scale
- EQ Curve shows square handles (8px, 10px hover) at each band position
- Filter Response displays single filter curve for any supported filter type
- Both use HiDPI Canvas scaling with useCanvasSetup hook
- Both follow Phase 25 static preview pattern (frozen snapshot, no animation)
- Handles highlight on hover with color change and size increase
</success_criteria>

<output>
After completion, create `.planning/phases/26-interactive-curves/26-02-SUMMARY.md`
</output>
