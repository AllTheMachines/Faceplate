---
phase: 26-interactive-curves
plan: 05
type: execute
wave: 3
depends_on: ["26-02", "26-03", "26-04"]
files_modified:
  - src/services/export/cssGenerator.ts
  - src/services/export/htmlGenerator.ts
autonomous: true

must_haves:
  truths:
    - "EQ Curve exports with Canvas and JavaScript draw function"
    - "Compressor Curve exports with transfer function visualization"
    - "Envelope Display exports with ADSR curve and stage rendering"
    - "LFO Display exports with waveform shape rendering"
    - "Filter Response exports with frequency response curve"
    - "All exports include HiDPI Canvas scaling"
    - "JUCE event listeners registered for curve data updates"
  artifacts:
    - path: "src/services/export/cssGenerator.ts"
      provides: "CSS generation for curve element containers"
      contains: "eqcurve"
    - path: "src/services/export/htmlGenerator.ts"
      provides: "HTML generation with Canvas and JavaScript draw functions"
      contains: "generateEQCurveHTML"
  key_links:
    - from: "src/services/export/htmlGenerator.ts"
      to: "eqcurve element"
      via: "switch case handler"
      pattern: "case.*eqcurve"
    - from: "src/services/export/cssGenerator.ts"
      to: "curve elements"
      via: "generateCurveCSS helper"
      pattern: "generateCurveCSS|eqcurve|compressorcurve"
---

<objective>
Add export support for all 5 curve element types

Purpose: Enable JUCE WebView2 integration with Canvas-based curve visualizations and JavaScript draw functions
Output: CSS and HTML generators updated with curve element support, JUCE event listeners for real-time updates
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-interactive-curves/26-CONTEXT.md
@.planning/phases/26-interactive-curves/26-RESEARCH.md
@.planning/phases/25-real-time-visualizations/25-05-SUMMARY.md
@src/services/export/cssGenerator.ts
@src/services/export/htmlGenerator.ts
@src/types/elements/curves.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CSS generation for curve elements</name>
  <files>src/services/export/cssGenerator.ts</files>
  <action>
Update src/services/export/cssGenerator.ts following Phase 25 visualization export pattern:

1. Import curve types from types/elements/curves:
```typescript
import type {
  EQCurveElementConfig,
  CompressorCurveElementConfig,
  EnvelopeDisplayElementConfig,
  LFODisplayElementConfig,
  FilterResponseElementConfig,
} from '../../types/elements/curves'
import {
  isEQCurve,
  isCompressorCurve,
  isEnvelopeDisplay,
  isLFODisplay,
  isFilterResponse,
} from '../../types/elements/curves'
```

2. Add generateCurveCSS helper function:
```typescript
function generateCurveCSS(element: ElementConfig): string {
  // Common Canvas container styles
  const baseStyles = `
  position: absolute;
  left: ${element.x}px;
  top: ${element.y}px;
  width: ${element.width}px;
  height: ${element.height}px;
  overflow: hidden;
  `

  if (isEQCurve(element)) {
    return `#${element.id} {${baseStyles}
  background-color: ${element.backgroundColor};
}

#${element.id} canvas {
  display: block;
  width: 100%;
  height: 100%;
}`
  }

  // Similar for other curve types...
  // All curve types use same Canvas container pattern
}
```

3. Add switch cases in main generateCSS function for all 5 curve types:
- case 'eqcurve': return generateCurveCSS(element)
- case 'compressorcurve': return generateCurveCSS(element)
- case 'envelopedisplay': return generateCurveCSS(element)
- case 'lfodisplay': return generateCurveCSS(element)
- case 'filterresponse': return generateCurveCSS(element)

CSS pattern is identical for all curve types (Canvas container with background).
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>CSS generator handles all 5 curve element types with Canvas container styles</done>
</task>

<task type="auto">
  <name>Task 2: Add HTML generation with JavaScript draw functions</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Update src/services/export/htmlGenerator.ts following Phase 25 visualization export pattern:

1. Import curve types and utility functions from audioMath and curveRendering (as inline JS):

2. Add HTML generator functions for each curve type:

**generateEQCurveHTML(config: EQCurveElementConfig):**
```typescript
function generateEQCurveHTML(config: EQCurveElementConfig): string {
  const id = config.id
  return `
<div id="${id}" class="curve-element">
  <canvas id="${id}-canvas"></canvas>
  <script>
    (function() {
      const canvas = document.getElementById('${id}-canvas');
      const dpr = window.devicePixelRatio || 1;
      canvas.width = ${config.width} * dpr;
      canvas.height = ${config.height} * dpr;
      canvas.style.width = '${config.width}px';
      canvas.style.height = '${config.height}px';
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);

      // Inline audio math functions
      function frequencyToX(freq, width, minFreq, maxFreq) {
        const minLog = Math.log10(minFreq);
        const maxLog = Math.log10(maxFreq);
        return ((Math.log10(freq) - minLog) / (maxLog - minLog)) * width;
      }

      function xToFrequency(x, width, minFreq, maxFreq) {
        const minLog = Math.log10(minFreq);
        const maxLog = Math.log10(maxFreq);
        return Math.pow(10, minLog + (x / width) * (maxLog - minLog));
      }

      function dbToY(db, height, minDb, maxDb) {
        return height - ((db - minDb) / (maxDb - minDb)) * height;
      }

      function calculateBiquadResponse(freq, centerFreq, gain, Q, sr) {
        // Audio EQ Cookbook formula (simplified)
        const A = Math.pow(10, gain / 40);
        const omega = (2 * Math.PI * freq) / sr;
        const centerOmega = (2 * Math.PI * centerFreq) / sr;
        const alpha = Math.sin(centerOmega) / (2 * Q);
        // ... rest of biquad calculation
        return gain * Math.exp(-Math.pow((Math.log10(freq) - Math.log10(centerFreq)) * Q, 2) / 2);
      }

      // Update function for JUCE to call
      window.updateEQCurve_${id.replace(/-/g, '_')} = function(bands) {
        ctx.clearRect(0, 0, ${config.width}, ${config.height});
        ctx.fillStyle = '${config.backgroundColor}';
        ctx.fillRect(0, 0, ${config.width}, ${config.height});

        ${config.showGrid ? `// Draw grid
        ctx.strokeStyle = '${config.gridColor}';
        ctx.lineWidth = 0.5;
        // Frequency grid lines (logarithmic)
        [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000].forEach(freq => {
          const x = frequencyToX(freq, ${config.width}, ${config.minFreq}, ${config.maxFreq});
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, ${config.height});
          ctx.stroke();
        });` : ''}

        // Calculate composite response
        const points = [];
        for (let i = 0; i <= 200; i++) {
          const x = (i / 200) * ${config.width};
          const freq = xToFrequency(x, ${config.width}, ${config.minFreq}, ${config.maxFreq});
          let totalDb = 0;
          bands.forEach(band => {
            totalDb += calculateBiquadResponse(freq, band.frequency, band.gain, band.Q, 44100);
          });
          const y = dbToY(totalDb, ${config.height}, ${config.minDb}, ${config.maxDb});
          points.push({x, y});
        }

        // Draw curve
        ctx.strokeStyle = '${config.curveColor}';
        ctx.lineWidth = ${config.lineWidth};
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();

        ${config.showFill ? `// Fill under curve
        ctx.fillStyle = '${config.fillColor}';
        ctx.globalAlpha = ${config.fillOpacity || 0.3};
        ctx.lineTo(${config.width}, ${config.height});
        ctx.lineTo(0, ${config.height});
        ctx.fill();
        ctx.globalAlpha = 1;` : ''}

        // Draw handles
        bands.forEach((band, i) => {
          const hx = frequencyToX(band.frequency, ${config.width}, ${config.minFreq}, ${config.maxFreq});
          const hy = dbToY(band.gain, ${config.height}, ${config.minDb}, ${config.maxDb});
          ctx.fillStyle = '${config.handleColor}';
          ctx.fillRect(hx - 4, hy - 4, 8, 8);
          ctx.strokeStyle = '#ffffff';
          ctx.strokeRect(hx - 4, hy - 4, 8, 8);
        });
      };

      // JUCE event listener
      window.addEventListener('eqData_${id}', function(e) {
        window.updateEQCurve_${id.replace(/-/g, '_')}(e.detail.bands);
      });

      // Initial draw with default bands
      window.updateEQCurve_${id.replace(/-/g, '_')}(${JSON.stringify(config.bands || [])});
    })();
  </script>
</div>`
}
```

Create similar functions for:
- **generateCompressorCurveHTML** - Transfer curve with threshold/ratio/knee, JUCE event: compressorData_${id}
- **generateEnvelopeDisplayHTML** - ADSR curve with stage rendering, JUCE event: envelopeData_${id}
- **generateLFODisplayHTML** - Waveform shape rendering, JUCE event: lfoData_${id}
- **generateFilterResponseHTML** - Filter response curve, JUCE event: filterData_${id}

3. Add switch cases in main generateHTML function for all 5 types.

JUCE event naming convention (per Phase 25 pattern):
- eqData_{id}
- compressorData_{id}
- envelopeData_{id}
- lfoData_{id}
- filterData_{id}
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>HTML generator creates Canvas elements with JavaScript draw functions and JUCE event listeners for all 5 curve types</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. cssGenerator.ts handles eqcurve, compressorcurve, envelopedisplay, lfodisplay, filterresponse
3. htmlGenerator.ts has generateEQCurveHTML, generateCompressorCurveHTML, generateEnvelopeDisplayHTML, generateLFODisplayHTML, generateFilterResponseHTML
4. Exported HTML includes inline JavaScript with HiDPI scaling
5. JUCE event listeners registered with consistent naming pattern
</verification>

<success_criteria>
- All 5 curve elements export as HTML Canvas with inline JavaScript
- JavaScript includes HiDPI scaling (devicePixelRatio)
- Update functions exposed globally for JUCE to call
- JUCE event listeners registered for real-time data updates
- Grid and fill options respected in exported JavaScript
- Handles drawn at control point positions
- CSS provides proper Canvas container styling
</success_criteria>

<output>
After completion, create `.planning/phases/26-interactive-curves/26-05-SUMMARY.md`
</output>
