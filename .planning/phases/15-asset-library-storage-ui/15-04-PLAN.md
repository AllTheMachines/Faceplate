---
phase: 15-asset-library-storage-ui
plan: 04
type: execute
wave: 4
depends_on: ["15-03"]
files_modified:
  - src/components/AssetLibrary/AssetThumbnail.tsx
  - src/components/AssetLibrary/AssetLibraryPanel.tsx
  - src/components/AssetLibrary/DeleteAssetDialog.tsx
  - src/components/AssetLibrary/InlineEditName.tsx
  - src/components/AssetLibrary/index.ts
  - src/App.tsx
  - src/types/elements.ts
autonomous: true

must_haves:
  truths:
    - "User can rename asset by clicking on name (inline edit)"
    - "User can delete asset via right-click context menu or Delete key"
    - "Deleting in-use asset shows warning with element list"
    - "User can drag asset from library to canvas to create element"
    - "Dragged asset creates new image element referencing asset ID"
  artifacts:
    - path: "src/components/AssetLibrary/DeleteAssetDialog.tsx"
      provides: "Confirmation dialog with usage warning"
      min_lines: 60
    - path: "src/components/AssetLibrary/InlineEditName.tsx"
      provides: "Click-to-edit name component"
      min_lines: 40
    - path: "src/App.tsx"
      provides: "Extended handleDragEnd for library-to-canvas drops"
      contains: "library-asset"
  key_links:
    - from: "src/components/AssetLibrary/AssetThumbnail.tsx"
      to: "@dnd-kit/core"
      via: "useDraggable hook"
      pattern: "useDraggable"
    - from: "src/App.tsx"
      to: "src/store/assetsSlice.ts"
      via: "getAsset for creating element from asset"
      pattern: "getAsset"
    - from: "src/components/AssetLibrary/DeleteAssetDialog.tsx"
      to: "src/store/elementsSlice.ts"
      via: "useStore elements for usage tracking"
      pattern: "elements.*assetId"
---

<objective>
Add asset interactions: inline rename, delete with usage warning, and drag-to-canvas.

Purpose: Complete the asset library workflow by enabling users to manage assets (rename, delete) and use them on the canvas. Implements ASSET-05 (delete with warning), ASSET-08 (drag to canvas), and inline renaming from CONTEXT.md.

Output: InlineEditName, DeleteAssetDialog, draggable thumbnails, and updated App.tsx drag handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/15-asset-library-storage-ui/15-CONTEXT.md
@.planning/phases/15-asset-library-storage-ui/15-RESEARCH.md
@src/App.tsx
@src/components/Palette/PaletteItem.tsx
@src/types/elements.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InlineEditName and DeleteAssetDialog components</name>
  <files>src/components/AssetLibrary/InlineEditName.tsx, src/components/AssetLibrary/DeleteAssetDialog.tsx, src/components/AssetLibrary/index.ts</files>
  <action>
**InlineEditName** - Click-to-edit pattern from RESEARCH.md:

Props:
```typescript
interface InlineEditNameProps {
  value: string
  onSave: (newValue: string) => void
}
```

State:
- `isEditing: boolean` - Toggle view/edit modes
- `editValue: string` - Current input value

Behavior:
- Click on name text -> enter edit mode
- Input auto-focuses and selects all text on edit start
- Enter key -> save and exit edit mode
- Escape key -> cancel and revert to original value
- Click outside (blur) -> save and exit edit mode
- Prevent saving empty names (revert to original)

UI:
- View mode: span with hover:underline cursor-pointer
- Edit mode: input matching theme (gray-700 bg, white text)

**DeleteAssetDialog** - Confirmation with usage warning:

Props:
```typescript
interface DeleteAssetDialogProps {
  asset: Asset
  isOpen: boolean
  onClose: () => void
  onConfirm: () => void
}
```

Usage tracking hook (in component or separate):
```typescript
function useAssetUsage(assetId: string) {
  const elements = useStore(state => state.elements)

  const usedByElements = useMemo(() => {
    return elements.filter(el =>
      el.type === 'image' && (el as ImageElement).assetId === assetId
    )
  }, [elements, assetId])

  return {
    usageCount: usedByElements.length,
    elementNames: usedByElements.map(el => el.name || el.id)
  }
}
```

UI (modal matching project style):
- Header: "Delete Asset?"
- If usageCount === 0:
  - Simple confirmation: "Delete [asset name]?"
- If usageCount > 0:
  - Warning text: "This asset is used by {count} element(s):"
  - List of element names using this asset
  - "These elements will lose their SVG content. Delete anyway?"
- Footer: Cancel and Delete buttons
  - Delete button red (bg-red-600)

Update index.ts with new exports.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>InlineEditName and DeleteAssetDialog components created with usage tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add assetId field to ImageElement type</name>
  <files>src/types/elements.ts</files>
  <action>
Update ImageElement interface to support asset references:

Find ImageElement interface and add optional assetId field:
```typescript
export interface ImageElement extends BaseElement {
  type: 'image'
  src: string           // Keep for backward compatibility (external URLs, data URLs)
  assetId?: string      // NEW: Reference to Asset in AssetsSlice
  alt: string
  objectFit: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down'
}
```

Update createImage factory function:
```typescript
export function createImage(overrides: Partial<ImageElement> = {}): ImageElement {
  return {
    ...createBaseElement('image', 100, 100),
    src: '',             // Empty by default
    assetId: undefined,  // NEW: Optional asset reference
    alt: 'Image',
    objectFit: 'contain',
    ...overrides,
  }
}
```

This allows elements to reference assets by ID instead of embedding SVG data directly.
When assetId is set, rendering should look up the asset for svgContent.
  </action>
  <verify>`npx tsc --noEmit` passes; existing image functionality unaffected</verify>
  <done>ImageElement has optional assetId field for asset references</done>
</task>

<task type="auto">
  <name>Task 3: Make AssetThumbnail draggable and wire up delete/rename</name>
  <files>src/components/AssetLibrary/AssetThumbnail.tsx, src/components/AssetLibrary/AssetLibraryPanel.tsx</files>
  <action>
**Update AssetThumbnail** - Add dnd-kit draggable:

```typescript
import { useDraggable } from '@dnd-kit/core'

function AssetThumbnail({ asset, isSelected, onClick }: AssetThumbnailProps) {
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({
    id: `asset-${asset.id}`,
    data: {
      type: 'library-asset',  // Distinguish from palette items
      assetId: asset.id
    }
  })

  const style = transform
    ? { transform: `translate3d(${transform.x}px, ${transform.y}px, 0)` }
    : undefined

  return (
    <div
      ref={setNodeRef}
      {...listeners}
      {...attributes}
      style={style}
      className={`... ${isDragging ? 'opacity-50' : ''}`}
    >
      {/* thumbnail content */}
    </div>
  )
}
```

Add to AssetThumbnail:
- InlineEditName for asset name (below thumbnail)
- Right-click context menu with "Delete" option
- Handle keyboard Delete key when selected

**Update AssetLibraryPanel** - Wire up interactions:

Add state:
- `deleteDialogAsset: Asset | null` - Asset pending deletion
- `selectedAssetId: string | null` - For keyboard delete handling

Add handlers:
- `handleRename(assetId, newName)` -> calls updateAsset
- `handleDeleteClick(asset)` -> opens DeleteAssetDialog
- `handleDeleteConfirm()` -> calls removeAsset, closes dialog
- Keyboard listener for Delete key when asset selected

Context menu implementation (simple approach):
```typescript
const handleContextMenu = (e: React.MouseEvent, asset: Asset) => {
  e.preventDefault()
  // Show delete option (could use state to position a menu, or native confirm)
  // For simplicity, directly open delete dialog
  setDeleteDialogAsset(asset)
}
```
  </action>
  <verify>`npm run dev` - thumbnails can be dragged, context menu shows delete option</verify>
  <done>AssetThumbnail is draggable with dnd-kit, rename and delete wired up</done>
</task>

<task type="auto">
  <name>Task 4: Extend App.tsx handleDragEnd for library-to-canvas drops</name>
  <files>src/App.tsx</files>
  <action>
Update handleDragEnd in App.tsx to handle library asset drops:

Add to imports:
```typescript
import { createImage } from './types/elements'
```

Get getAsset from store:
```typescript
const getAsset = useStore((state) => state.getAsset)
```

In handleDragEnd, after existing element move handling, add library-asset case:

```typescript
const handleDragEnd = (event: DragEndEvent) => {
  const { active, over, delta } = event

  // ... existing element move handling ...

  // Check for library-asset drag
  const dragType = active.data.current?.type
  if (dragType === 'library-asset') {
    // Only handle drops over canvas
    if (!over || over.id !== 'canvas-droppable') {
      setActiveDragData(null)
      return
    }

    const assetId = active.data.current?.assetId
    if (!assetId) return

    const asset = getAsset(assetId)
    if (!asset) return

    // Calculate canvas position (same logic as palette drops)
    const canvasViewport = document.querySelector('.canvas-viewport')
    if (!canvasViewport) return
    const viewportRect = canvasViewport.getBoundingClientRect()

    let finalX: number, finalY: number
    const trackedPosition = lastPointerPositionRef.current
    if (trackedPosition) {
      finalX = trackedPosition.x
      finalY = trackedPosition.y
    } else {
      const pointerEvent = event.activatorEvent as PointerEvent
      finalX = pointerEvent.clientX + (event.delta?.x || 0)
      finalY = pointerEvent.clientY + (event.delta?.y || 0)
    }

    const canvasX = (finalX - viewportRect.left - offsetX) / scale
    const canvasY = (finalY - viewportRect.top - offsetY) / scale

    // Create image element with asset reference
    const newElement = createImage({
      x: canvasX,
      y: canvasY,
      assetId: assetId,
      src: '',  // Empty since we're using assetId
      name: asset.name,
    })

    // Center on drop position
    newElement.x = canvasX - newElement.width / 2
    newElement.y = canvasY - newElement.height / 2

    addElement(newElement)
    setActiveDragData(null)
    return
  }

  // ... existing palette drag handling ...
}
```

Also update handleDragStart to handle library-asset preview:
```typescript
if (active.data.current?.type === 'library-asset') {
  const assetId = active.data.current.assetId
  const asset = getAsset(assetId)
  if (asset) {
    setActiveDragData({ elementType: 'image', variant: { name: asset.name } })
  }
}
```
  </action>
  <verify>`npm run dev` - drag asset from library to canvas creates image element with assetId</verify>
  <done>Dragging asset from library to canvas creates image element referencing asset by ID</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Dev server starts: `npm run dev`
3. Inline rename: click asset name -> edit -> Enter saves
4. Context menu: right-click asset -> shows delete option
5. Delete dialog: shows usage warning if asset is used by elements
6. Drag to canvas: drag asset thumbnail -> drop on canvas -> creates image element
7. Created element has assetId field referencing the dropped asset
</verification>

<success_criteria>
- Inline edit: click name to rename, Enter/Escape/blur handling
- Delete key or context menu triggers delete confirmation
- Delete dialog shows element usage warning when applicable
- Thumbnails are draggable with dnd-kit
- Drop on canvas creates image element with assetId
- DragOverlay shows preview during library-to-canvas drag
</success_criteria>

<output>
After completion, create `.planning/phases/15-asset-library-storage-ui/15-04-SUMMARY.md`
</output>
