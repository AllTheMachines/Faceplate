---
phase: 37-font-management-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/fonts/fontStorage.ts
  - src/services/fonts/fontParser.ts
  - src/services/fonts/fontScanner.ts
  - src/services/fonts/fontManager.ts
autonomous: true

must_haves:
  truths:
    - "App can store and retrieve font data from IndexedDB"
    - "App can parse font metadata from TTF/OTF/WOFF/WOFF2 files"
    - "App can scan a directory recursively for font files"
    - "Directory handle persists across browser sessions"
  artifacts:
    - path: "src/services/fonts/fontStorage.ts"
      provides: "IndexedDB operations for fonts and directory handles"
      exports: ["openFontsDB", "storeFont", "getAllFonts", "clearFonts", "storeDirectoryHandle", "getDirectoryHandle"]
    - path: "src/services/fonts/fontParser.ts"
      provides: "Font metadata extraction using opentype.js"
      exports: ["parseFontMetadata", "FontMetadata"]
    - path: "src/services/fonts/fontScanner.ts"
      provides: "Directory scanning for font files"
      exports: ["scanFontsDirectory"]
    - path: "src/services/fonts/fontManager.ts"
      provides: "Orchestration of font operations"
      exports: ["FontManager"]
  key_links:
    - from: "src/services/fonts/fontManager.ts"
      to: "src/services/fonts/fontStorage.ts"
      via: "imports storage functions"
      pattern: "import.*fontStorage"
    - from: "src/services/fonts/fontManager.ts"
      to: "src/services/fonts/fontParser.ts"
      via: "imports parser"
      pattern: "import.*fontParser"
    - from: "src/services/fonts/fontManager.ts"
      to: "src/services/fonts/fontScanner.ts"
      via: "imports scanner"
      pattern: "import.*fontScanner"
---

<objective>
Create the font management service layer for Phase 37.

Purpose: Build the foundational services that handle font file operations - storing in IndexedDB, parsing metadata with opentype.js, scanning directories, and orchestrating the overall font management workflow. These services will be consumed by the Zustand store and UI components.

Output: Four service files that handle all font-related operations independent of UI or state management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-font-management-system/37-RESEARCH.md

# Existing font infrastructure
@src/services/fonts/fontRegistry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install opentype.js and create font storage service</name>
  <files>
    - package.json
    - src/services/fonts/fontStorage.ts
  </files>
  <action>
1. Install opentype.js dependency:
   ```bash
   npm install opentype.js
   npm install -D @types/opentype.js
   ```

2. Create `src/services/fonts/fontStorage.ts` with IndexedDB operations:

**Types:**
```typescript
export interface StoredFont {
  family: string           // CSS font-family value (unique key)
  data: ArrayBuffer        // Raw font data for embedding
  metadata: FontMetadata   // Parsed metadata (name, format, etc.)
  addedAt: number          // Timestamp for sorting
}
```

**Functions:**
- `openFontsDB(): Promise<IDBDatabase>` - Opens/creates 'vst-ui-fonts' database v1 with:
  - 'fonts' object store (keyPath: 'family')
  - 'handles' object store for directory handle

- `storeFont(font: StoredFont): Promise<void>` - Upsert font into 'fonts' store

- `getAllFonts(): Promise<StoredFont[]>` - Get all fonts, sorted by addedAt

- `getFont(family: string): Promise<StoredFont | undefined>` - Get single font by family

- `clearFonts(): Promise<void>` - Clear all fonts (for rescan)

- `storeDirectoryHandle(handle: FileSystemDirectoryHandle): Promise<void>` - Store handle in 'handles' store with key 'fonts-directory'

- `getDirectoryHandle(): Promise<FileSystemDirectoryHandle | null>` - Retrieve stored handle

- `clearDirectoryHandle(): Promise<void>` - Remove stored handle

**Implementation notes:**
- Use native IndexedDB API (no idb wrapper needed for this simple use case)
- All functions are async/await with proper error handling
- Database version is 1 - upgrade creates both object stores
- Import FontMetadata type from fontParser.ts (create interface first)
  </action>
  <verify>
    - `npm ls opentype.js` shows package installed
    - `npx tsc --noEmit src/services/fonts/fontStorage.ts` compiles without errors
  </verify>
  <done>
    - opentype.js installed as dependency
    - fontStorage.ts exports all 7 functions with correct TypeScript types
    - IndexedDB database schema defined for fonts and handles
  </done>
</task>

<task type="auto">
  <name>Task 2: Create font parser and scanner services</name>
  <files>
    - src/services/fonts/fontParser.ts
    - src/services/fonts/fontScanner.ts
  </files>
  <action>
1. Create `src/services/fonts/fontParser.ts`:

**Types:**
```typescript
export interface FontMetadata {
  family: string           // CSS font-family name (from name table)
  fullName: string         // Full font name
  postScriptName: string   // PostScript name
  version?: string         // Font version
  format: 'ttf' | 'otf' | 'woff' | 'woff2'
  fileName: string         // Original file name
}
```

**Functions:**
- `parseFontMetadata(file: File): Promise<FontMetadata | null>` - Parse font file using opentype.js:
  - Read file as ArrayBuffer using `file.arrayBuffer()`
  - Parse with `opentype.parse(arrayBuffer)`
  - Extract names.fontFamily.en, names.fullName.en, names.postScriptName.en, names.version?.en
  - Handle preferredFamily as fallback for family
  - Wrap in try/catch, return null on parse failure (log warning)
  - Determine format from file extension

- `detectFontFormat(fileName: string): 'ttf' | 'otf' | 'woff' | 'woff2'` - Helper to detect format from extension

2. Create `src/services/fonts/fontScanner.ts`:

**Functions:**
- `scanFontsDirectory(dirHandle: FileSystemDirectoryHandle): Promise<File[]>` - Recursively scan directory for font files:
  - Define FONT_EXTENSIONS = ['.ttf', '.otf', '.woff', '.woff2']
  - Create async generator `getFilesRecursively` that yields FileSystemFileHandle
  - For each entry in dirHandle.values():
    - If 'file' kind, yield the handle
    - If 'directory' kind, yield* recursively
  - Filter to files matching extensions (case-insensitive)
  - Convert handles to File objects with `handle.getFile()`
  - Return array of File objects

**Implementation notes:**
- Import opentype from 'opentype.js' (default import)
- Scanner should be tolerant of permission errors on subdirectories (skip with warning)
- Handle fonts with missing name table fields gracefully
  </action>
  <verify>
    - `npx tsc --noEmit src/services/fonts/fontParser.ts` compiles
    - `npx tsc --noEmit src/services/fonts/fontScanner.ts` compiles
  </verify>
  <done>
    - fontParser.ts exports FontMetadata type and parseFontMetadata function
    - fontScanner.ts exports scanFontsDirectory function
    - Both handle errors gracefully without crashing
  </done>
</task>

<task type="auto">
  <name>Task 3: Create font manager orchestration service</name>
  <files>
    - src/services/fonts/fontManager.ts
    - src/services/fonts/index.ts
  </files>
  <action>
1. Create `src/services/fonts/fontManager.ts`:

**Class: FontManager**
A singleton that orchestrates font operations and manages the FontFace registry.

```typescript
export class FontManager {
  private loadedFamilies: Set<string> = new Set()

  // Request directory selection via File System Access API
  async selectFontsDirectory(): Promise<{ handle: FileSystemDirectoryHandle; path: string } | null>

  // Restore directory access from stored handle
  async restoreDirectoryAccess(): Promise<{ handle: FileSystemDirectoryHandle; path: string } | null>

  // Scan directory and process fonts
  async scanAndStoreFonts(dirHandle: FileSystemDirectoryHandle): Promise<{ scanned: number; loaded: number; errors: string[] }>

  // Load fonts into document.fonts for use in dropdowns
  async loadFontsIntoDocument(fonts: StoredFont[]): Promise<void>

  // Clean up FontFace objects before rescan
  clearLoadedFonts(): void

  // Get combined list of built-in + custom fonts
  getAvailableFonts(): Promise<FontDefinition[]>
}

export const fontManager = new FontManager() // Singleton export
```

**Implementation details:**

`selectFontsDirectory`:
- Use browser-fs-access `directoryOpen({ id: 'vst-ui-fonts', mode: 'read', recursive: true })`
- Store handle via fontStorage.storeDirectoryHandle()
- Return handle and path (dirHandle.name or 'Selected Folder')

`restoreDirectoryAccess`:
- Get handle from fontStorage.getDirectoryHandle()
- If exists, call handle.queryPermission({ mode: 'read' })
- If 'granted', return handle
- If 'prompt', call handle.requestPermission({ mode: 'read' })
- If granted after request, return handle
- Otherwise return null

`scanAndStoreFonts`:
- Clear existing fonts with fontStorage.clearFonts()
- Clear loaded FontFace objects with clearLoadedFonts()
- Scan directory with fontScanner.scanFontsDirectory()
- For each file, parse metadata with fontParser.parseFontMetadata()
- If metadata valid, read arrayBuffer and store with fontStorage.storeFont()
- Track errors for files that fail to parse
- Return stats: { scanned: total files found, loaded: successfully stored, errors: error messages }

`loadFontsIntoDocument`:
- For each font not already in loadedFamilies:
  - Create FontFace object: `new FontFace(font.family, font.data, { display: 'swap' })`
  - Call fontFace.load()
  - Add to document.fonts
  - Add family to loadedFamilies Set
- Prevents duplicate loading

`clearLoadedFonts`:
- For each family in loadedFamilies:
  - Find and delete from document.fonts
- Clear loadedFamilies Set

`getAvailableFonts`:
- Get built-in fonts from AVAILABLE_FONTS (fontRegistry.ts)
- Get custom fonts from fontStorage.getAllFonts()
- Merge, with custom fonts having `file: 'custom'` marker
- Sort: built-in first, then custom alphabetically

2. Update `src/services/fonts/index.ts` to export all modules:
```typescript
export * from './fontRegistry'
export * from './fontStorage'
export * from './fontParser'
export * from './fontScanner'
export * from './fontManager'
```
  </action>
  <verify>
    - `npx tsc --noEmit src/services/fonts/fontManager.ts` compiles
    - `npx tsc --noEmit src/services/fonts/index.ts` compiles
  </verify>
  <done>
    - FontManager class exported with all methods
    - fontManager singleton instance exported
    - index.ts re-exports all font service modules
    - Service layer complete and ready for store integration
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` completes without errors
2. All font service files exist and export correctly
3. TypeScript compilation passes for all new files
4. opentype.js is in package.json dependencies
</verification>

<success_criteria>
- opentype.js installed and typed
- fontStorage.ts handles IndexedDB operations for fonts and directory handles
- fontParser.ts extracts metadata from font files using opentype.js
- fontScanner.ts recursively scans directories for font files
- fontManager.ts orchestrates all font operations with singleton pattern
- All services are error-tolerant (don't crash on bad fonts or permission issues)
</success_criteria>

<output>
After completion, create `.planning/phases/37-font-management-system/37-01-SUMMARY.md`
</output>
