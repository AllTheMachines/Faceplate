---
phase: 37-font-management-system
plan: 05
type: execute
wave: 3
depends_on: ["37-01", "37-02", "37-03", "37-04"]
files_modified:
  - src/services/export/cssGenerator.ts
  - src/services/export/fontExporter.ts
autonomous: true

must_haves:
  truths:
    - "Export only bundles fonts actually used in project elements"
    - "Custom fonts are embedded as base64 in exported CSS"
    - "Built-in fonts continue to use file references"
    - "Export warns if embedding large fonts"
  artifacts:
    - path: "src/services/export/fontExporter.ts"
      provides: "Font collection and embedding utilities"
      exports: ["collectUsedFonts", "generateCustomFontFaces"]
    - path: "src/services/export/cssGenerator.ts"
      provides: "CSS generator with custom font support"
      contains: "generateCustomFontFaces"
  key_links:
    - from: "src/services/export/cssGenerator.ts"
      to: "src/services/export/fontExporter.ts"
      via: "imports font utilities"
      pattern: "import.*fontExporter"
    - from: "src/services/export/fontExporter.ts"
      to: "src/services/fonts/fontStorage.ts"
      via: "retrieves stored fonts"
      pattern: "getFont|getAllFonts"
---

<objective>
Add export support for custom fonts with smart bundling.

Purpose: When exporting a project, only include fonts that are actually used by elements. Custom fonts are embedded as base64 in the CSS, ensuring the exported bundle is self-contained and works offline in JUCE WebView2.

Output: Export system that detects used fonts and embeds only those, keeping exported bundles minimal.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-font-management-system/37-RESEARCH.md

# Prior plan summaries (when available)
# @.planning/phases/37-font-management-system/37-01-SUMMARY.md
# @.planning/phases/37-font-management-system/37-02-SUMMARY.md
# @.planning/phases/37-font-management-system/37-03-SUMMARY.md
# @.planning/phases/37-font-management-system/37-04-SUMMARY.md

# Existing export infrastructure (read first 200 lines for context)
# src/services/export/cssGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create font exporter utility</name>
  <files>
    - src/services/export/fontExporter.ts
  </files>
  <action>
Create `src/services/export/fontExporter.ts` with utilities for collecting and embedding custom fonts.

**Implementation:**
```typescript
import { getFont } from '../fonts/fontStorage'
import { AVAILABLE_FONTS, type FontDefinition } from '../fonts/fontRegistry'
import type { ElementConfig } from '../../types/elements'

/**
 * Collect all font families used by elements in the project
 */
export function collectUsedFonts(elements: ElementConfig[]): Set<string> {
  const usedFonts = new Set<string>()

  function collectFromElement(el: ElementConfig) {
    // Label elements
    if (el.type === 'label' && 'fontFamily' in el) {
      usedFonts.add(el.fontFamily)
    }

    // Display elements with fontFamily property
    if ('fontFamily' in el && typeof el.fontFamily === 'string') {
      usedFonts.add(el.fontFamily)
    }

    // Container children (recursive)
    if ('children' in el && Array.isArray(el.children)) {
      el.children.forEach(collectFromElement)
    }
  }

  elements.forEach(collectFromElement)
  return usedFonts
}

/**
 * Check if a font family is a custom font (not built-in)
 */
export function isCustomFont(family: string): boolean {
  return !AVAILABLE_FONTS.some(f => f.family === family || family.includes(f.family))
}

/**
 * Get built-in font definition if exists
 */
export function getBuiltInFont(family: string): FontDefinition | undefined {
  return AVAILABLE_FONTS.find(f => f.family === family || family.includes(f.family))
}

/**
 * Convert ArrayBuffer to base64 string
 */
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer)
  let binary = ''
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i])
  }
  return btoa(binary)
}

/**
 * Get MIME type for font format
 */
function getFontMimeType(format: string): string {
  const mimeTypes: Record<string, string> = {
    'ttf': 'font/ttf',
    'otf': 'font/otf',
    'woff': 'font/woff',
    'woff2': 'font/woff2',
  }
  return mimeTypes[format] || 'font/ttf'
}

/**
 * CSS format string for font format
 */
function getCSSFormat(format: string): string {
  const formats: Record<string, string> = {
    'ttf': 'truetype',
    'otf': 'opentype',
    'woff': 'woff',
    'woff2': 'woff2',
  }
  return formats[format] || 'truetype'
}

export interface CustomFontExport {
  css: string
  warnings: string[]
}

/**
 * Generate @font-face rules for custom fonts used in project
 * Returns CSS string and any warnings (e.g., large fonts)
 */
export async function generateCustomFontFaces(usedFonts: Set<string>): Promise<CustomFontExport> {
  const fontFaces: string[] = []
  const warnings: string[] = []

  const SIZE_WARNING_THRESHOLD = 500 * 1024 // 500KB per font
  const TOTAL_SIZE_THRESHOLD = 2 * 1024 * 1024 // 2MB total

  let totalSize = 0

  for (const family of usedFonts) {
    // Skip built-in fonts - they use file references
    if (!isCustomFont(family)) {
      continue
    }

    // Get custom font from storage
    const storedFont = await getFont(family)
    if (!storedFont) {
      warnings.push(`Custom font "${family}" not found in storage. It will not be embedded.`)
      continue
    }

    const fontData = storedFont.data
    const format = storedFont.metadata.format
    const size = fontData.byteLength

    // Size warnings
    if (size > SIZE_WARNING_THRESHOLD) {
      const sizeMB = (size / 1024 / 1024).toFixed(2)
      warnings.push(`Font "${family}" is ${sizeMB}MB. Consider using a smaller font for better export performance.`)
    }

    totalSize += size

    // Generate base64 embedded font-face
    const base64 = arrayBufferToBase64(fontData)
    const mimeType = getFontMimeType(format)
    const cssFormat = getCSSFormat(format)

    const fontFace = `@font-face {
  font-family: '${family}';
  src: url(data:${mimeType};base64,${base64}) format('${cssFormat}');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}`

    fontFaces.push(fontFace)
  }

  // Total size warning
  if (totalSize > TOTAL_SIZE_THRESHOLD) {
    const sizeMB = (totalSize / 1024 / 1024).toFixed(2)
    warnings.push(`Total embedded font size is ${sizeMB}MB. This may cause slow export loading.`)
  }

  return {
    css: fontFaces.length > 0 ? `/* Custom Fonts */\n${fontFaces.join('\n\n')}` : '',
    warnings,
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit src/services/export/fontExporter.ts` compiles
  </verify>
  <done>
    - fontExporter.ts created with collectUsedFonts, generateCustomFontFaces
    - Base64 embedding for custom fonts
    - Size warnings for large fonts
    - Proper MIME types and CSS format strings
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cssGenerator to use font exporter</name>
  <files>
    - src/services/export/cssGenerator.ts
  </files>
  <action>
Update `src/services/export/cssGenerator.ts` to include custom font embedding.

**Changes:**

1. Add import at top:
```typescript
import { collectUsedFonts, generateCustomFontFaces, isCustomFont, getBuiltInFont } from './fontExporter'
```

2. Find the `generateCssExport` function (main export function). Modify it to:
   - Call collectUsedFonts on elements
   - Call generateCustomFontFaces for custom fonts
   - Prepend custom font CSS to output
   - Return or log warnings

3. Locate the existing font-face generation code (around lines 88-119) in the `generateCssExport` function. The current logic:
   - Collects fonts from label elements
   - Uses getFontByFamily to find FontDefinitions
   - Generates @font-face rules for fonts with files

**Modify to:**
```typescript
// Collect all used fonts
const usedFonts = collectUsedFonts(elements)

// Add 7-segment font if used
const uses7Segment = elements.some(
  (el) => 'fontStyle' in el && el.fontStyle === '7segment'
)

// Generate built-in font-face rules (existing logic, but only for built-in fonts)
const builtInFontFaces = Array.from(usedFonts)
  .map(family => getBuiltInFont(family))
  .filter((f): f is FontDefinition => f !== undefined && f.file !== '')
  .map(generateFontFace)
  .join('\n\n')

// Generate custom font-face rules (NEW)
const customFontResult = await generateCustomFontFaces(usedFonts)

// Log warnings to console (or could add to export result)
if (customFontResult.warnings.length > 0) {
  console.warn('Font export warnings:', customFontResult.warnings)
}

// Combine font sections
const allFontFaces = [
  builtInFontFaces,
  customFontResult.css,
  uses7Segment ? dseg7Font : '',
].filter(Boolean).join('\n\n')
```

**Important:** The generateCssExport function may need to become async if it isn't already. Check the function signature and update callers if needed.

4. Update function signature if needed:
```typescript
export async function generateCssExport(elements: ElementConfig[], canvas: CanvasState): Promise<string>
```

5. Ensure callers of generateCssExport handle the Promise (likely already async based on other export functions).
  </action>
  <verify>
    - `npx tsc --noEmit src/services/export/cssGenerator.ts` compiles
    - `npm run build` completes without errors
  </verify>
  <done>
    - cssGenerator imports and uses fontExporter utilities
    - Custom fonts embedded as base64 in export
    - Built-in fonts still use file references
    - Warnings logged for large fonts
    - Function is async to handle font storage lookup
  </done>
</task>

<task type="auto">
  <name>Task 3: Update export callers for async CSS generation</name>
  <files>
    - src/services/export/codeGenerator.ts
    - src/services/export/previewExport.ts
  </files>
  <action>
If `generateCssExport` was made async in Task 2, update its callers to await the result.

**Check these files for generateCssExport usage:**

1. `src/services/export/codeGenerator.ts` - Main export generation
   - Find where generateCssExport is called
   - Add await if needed
   - Ensure calling function is async

2. `src/services/export/previewExport.ts` - Preview mode
   - Find where generateCssExport is called
   - Add await if needed
   - Ensure calling function is async

**Pattern to look for:**
```typescript
// Before (if sync)
const css = generateCssExport(elements, canvas)

// After (if now async)
const css = await generateCssExport(elements, canvas)
```

**If already async:** No changes needed, just verify the code compiles.

**If functions calling it need to become async:** Update their signatures and callers recursively until you reach event handlers or useEffect (which can call async functions).
  </action>
  <verify>
    - `npm run build` completes without errors
    - Export functionality still works
  </verify>
  <done>
    - All callers of generateCssExport properly await the result
    - Build passes without type errors
    - Export generates CSS with embedded custom fonts
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` completes without errors
2. Create a test project with a Label using a custom font
3. Export the project
4. Inspect exported CSS - custom font should be embedded as base64 @font-face
5. Built-in fonts still reference files (not embedded)
6. Console shows warnings for large fonts (if applicable)
</verification>

<success_criteria>
- Export only includes fonts actually used by elements
- Custom fonts embedded as base64 in CSS
- Built-in fonts use file references (not embedded)
- Size warnings for large fonts (>500KB individual, >2MB total)
- Export remains self-contained (works offline in JUCE)
</success_criteria>

<output>
After completion, create `.planning/phases/37-font-management-system/37-05-SUMMARY.md`
</output>
