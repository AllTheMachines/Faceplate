---
phase: 57-meter-styling
plan: 02
type: execute
wave: 2
depends_on: ["57-01"]
files_modified:
  - src/components/elements/renderers/displays/meters/StyledMeterRenderer.tsx
  - src/components/elements/renderers/displays/meters/RMSMeterRenderer.tsx
  - src/components/elements/renderers/displays/meters/VUMeterRenderer.tsx
  - src/components/elements/renderers/displays/meters/PPMType1Renderer.tsx
  - src/components/elements/renderers/displays/meters/PPMType2Renderer.tsx
  - src/components/elements/renderers/displays/meters/TruePeakRenderer.tsx
  - src/components/elements/renderers/displays/meters/KMeterRenderer.tsx
  - src/components/elements/renderers/displays/meters/LUFSMomentaryRenderer.tsx
  - src/components/elements/renderers/displays/meters/LUFSShorttermRenderer.tsx
  - src/components/elements/renderers/displays/meters/LUFSIntegratedRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "Meters with styleId render using SVG layers with clip-path animation"
    - "Meters without styleId render using existing CSS segmented display"
    - "Fill layers animate bottom-up for vertical meters (inverted clip-path)"
    - "Zone layers stack correctly (green base, yellow middle, red top)"
    - "Peak indicator positions at current value using SVG layer"
  artifacts:
    - path: "src/components/elements/renderers/displays/meters/StyledMeterRenderer.tsx"
      provides: "Shared SVG meter renderer with zone fills and peak indicator"
      exports: ["StyledMeterRenderer"]
      min_lines: 100
    - path: "src/components/elements/renderers/displays/meters/RMSMeterRenderer.tsx"
      provides: "RMS meter with default/styled delegation"
      contains: "StyledMeterRenderer"
  key_links:
    - from: "src/components/elements/renderers/displays/meters/StyledMeterRenderer.tsx"
      to: "src/services/elementLayers.ts"
      via: "extractElementLayer import"
      pattern: "extractElementLayer"
    - from: "src/components/elements/renderers/displays/meters/RMSMeterRenderer.tsx"
      to: "src/components/elements/renderers/displays/meters/StyledMeterRenderer.tsx"
      via: "delegation for styled rendering"
      pattern: "StyledMeterRenderer"
---

<objective>
Create StyledMeterRenderer with clip-path zone fill animation and update all professional meter renderers to delegate to it when styleId is set.

Purpose: Enable SVG-based meter rendering with multi-zone color fills that preserve gradients/textures, matching user decisions from CONTEXT.md.
Output: Working styled meter renderer used by all 24 professional meter types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/57-meter-styling/57-CONTEXT.md
@.planning/phases/57-meter-styling/57-RESEARCH.md
@.planning/phases/57-meter-styling/57-01-SUMMARY.md
@src/components/elements/renderers/controls/SliderRenderer.tsx
@src/components/elements/renderers/displays/meters/SegmentedMeter.tsx
@src/components/elements/renderers/displays/meters/RMSMeterRenderer.tsx
@src/utils/meterUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StyledMeterRenderer component</name>
  <files>src/components/elements/renderers/displays/meters/StyledMeterRenderer.tsx</files>
  <action>
Create a shared styled meter renderer following the SliderRenderer pattern. This component handles SVG-based rendering with clip-path animation for all professional meter types.

Key implementation details from CONTEXT.md and RESEARCH.md:

1. **Layer extraction** - Extract layers from SVG using extractElementLayer:
   - body/background - static background
   - fill-green, fill-yellow, fill-red - zone fill layers (stacked reveal)
   - fill - fallback single fill layer (if no zone layers exist)
   - scale - static ticks/markings (optional)
   - peak - peak hold indicator (positioned at value)

2. **Zone fill animation** - Use clip-path inset() for bottom-up fill:
   - Green: always shows from bottom to value position
   - Yellow: reveals above -18dB threshold (stacks on top of green)
   - Red: reveals above -6dB threshold (stacks on top of yellow)
   - Clip-path for vertical: `inset(${(1 - value) * 100}% 0 0 0)` (clips from top, reveals from bottom)

3. **Zone thresholds** - Use dbToNormalized from meterUtils:
   ```typescript
   const yellowThreshold = dbToNormalized(-18, config.minDb, config.maxDb)
   const redThreshold = dbToNormalized(-6, config.minDb, config.maxDb)
   ```

4. **Peak indicator** - Position at current value using absolute positioning:
   ```typescript
   // Vertical: bottom = value * 100%, translateY(50%) to center
   bottom: `${normalizedValue * 100}%`,
   transform: 'translateY(50%)'
   ```

5. **Horizontal orientation** - Apply CSS rotate(90deg) to entire container:
   ```typescript
   ...(config.orientation === 'horizontal' && {
     transform: 'rotate(90deg)',
     transformOrigin: 'center center',
   })
   ```

6. **Color overrides** - Apply via applyAllColorOverrides from knobLayers.ts

7. **Fallback** - If zone layers don't exist, use single 'fill' layer as green zone

Interface:
```typescript
interface StyledMeterRendererProps {
  config: BaseProfessionalMeterConfig & {
    styleId: string
    colorOverrides?: ColorOverrides
  }
}
```

Return "Style not found" placeholder if style doesn't exist (same pattern as StyledSliderRenderer).
  </action>
  <verify>File exists and exports StyledMeterRenderer; `npx tsc --noEmit` passes</verify>
  <done>StyledMeterRenderer renders SVG meter with zone fill clip-path animation, peak indicator positioning, and horizontal rotation support</done>
</task>

<task type="auto">
  <name>Task 2: Update professional meter renderers with delegation pattern</name>
  <files>
    src/components/elements/renderers/displays/meters/RMSMeterRenderer.tsx
    src/components/elements/renderers/displays/meters/VUMeterRenderer.tsx
    src/components/elements/renderers/displays/meters/PPMType1Renderer.tsx
    src/components/elements/renderers/displays/meters/PPMType2Renderer.tsx
    src/components/elements/renderers/displays/meters/TruePeakRenderer.tsx
    src/components/elements/renderers/displays/meters/KMeterRenderer.tsx
    src/components/elements/renderers/displays/meters/LUFSMomentaryRenderer.tsx
    src/components/elements/renderers/displays/meters/LUFSShorttermRenderer.tsx
    src/components/elements/renderers/displays/meters/LUFSIntegratedRenderer.tsx
  </files>
  <action>
Update each meter renderer to delegate to StyledMeterRenderer when styleId is set. Follow the SliderRenderer pattern exactly.

For each file:

1. Import StyledMeterRenderer:
```typescript
import { StyledMeterRenderer } from './StyledMeterRenderer'
```

2. Rename existing function to DefaultXXXRenderer (keep all existing code unchanged):
```typescript
function DefaultRMSMeterMonoRenderer({ config }: MonoProps) {
  // ... existing implementation unchanged ...
}
```

3. Create main renderer that delegates:
```typescript
export function RMSMeterMonoRenderer({ config }: MonoProps) {
  if (config.styleId) {
    return <StyledMeterRenderer config={config} />
  }
  return <DefaultRMSMeterMonoRenderer config={config} />
}
```

Apply same pattern to all renderer files:
- RMSMeterRenderer.tsx: RMSMeterMonoRenderer, RMSMeterStereoRenderer
- VUMeterRenderer.tsx: VUMeterMonoRenderer, VUMeterStereoRenderer
- PPMType1Renderer.tsx: PPMType1MonoRenderer, PPMType1StereoRenderer
- PPMType2Renderer.tsx: PPMType2MonoRenderer, PPMType2StereoRenderer
- TruePeakRenderer.tsx: TruePeakMeterMonoRenderer, TruePeakMeterStereoRenderer
- KMeterRenderer.tsx: K12MeterMonoRenderer, K12MeterStereoRenderer, K14MeterMonoRenderer, K14MeterStereoRenderer, K20MeterMonoRenderer, K20MeterStereoRenderer
- LUFSMomentaryRenderer.tsx: LUFSMomentaryMonoRenderer, LUFSMomentaryStereoRenderer
- LUFSShorttermRenderer.tsx: LUFSShorttermMonoRenderer, LUFSShorttermStereoRenderer
- LUFSIntegratedRenderer.tsx: LUFSIntegratedMonoRenderer, LUFSIntegratedStereoRenderer

**Stereo meters:** For stereo renderers, when styleId is set, render TWO StyledMeterRenderer instances side-by-side (one per channel) following existing pattern.
  </action>
  <verify>Run `npm run dev` and verify meters still render correctly without styleId; `npx tsc --noEmit` passes</verify>
  <done>All 24 professional meter types delegate to StyledMeterRenderer when styleId is set, while preserving existing CSS segmented rendering for default case</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run dev` starts without errors
3. Meters render normally in canvas (existing behavior preserved)
4. StyledMeterRenderer.tsx exists with extractElementLayer, applyAllColorOverrides, clip-path animation
5. Each meter renderer imports and uses StyledMeterRenderer when styleId is set
</verification>

<success_criteria>
- StyledMeterRenderer renders SVG meters with zone fill animation (clip-path)
- Fill direction is bottom-up for vertical meters (inverted clip-path)
- Zone layers stack correctly (green -> yellow -> red)
- Peak indicator positions at value using SVG layer
- Horizontal orientation applies 90deg rotation
- All 24 meter types delegate to StyledMeterRenderer when styleId is set
- Existing CSS segmented rendering unchanged when styleId is undefined
</success_criteria>

<output>
After completion, create `.planning/phases/57-meter-styling/57-02-SUMMARY.md`
</output>
