---
phase: 27.1-post-phase-bugfixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useCanvasSetup.ts
  - src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx
  - src/components/elements/renderers/displays/curves/CompressorCurveRenderer.tsx
  - src/components/elements/renderers/displays/curves/EnvelopeDisplayRenderer.tsx
  - src/components/elements/renderers/displays/curves/LFODisplayRenderer.tsx
  - src/components/elements/renderers/displays/curves/FilterResponseRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/SpectrogramRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/GoniometerRenderer.tsx
  - src/components/elements/renderers/displays/visualizations/VectorscopeRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "All 5 curve types render visible lines when dropped on canvas"
    - "All 5 visualization types render visible content when dropped on canvas"
    - "Canvas elements update correctly when properties change"
  artifacts:
    - path: "src/hooks/useCanvasSetup.ts"
      provides: "Canvas context that triggers re-render when ready"
      contains: "useState"
    - path: "src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx"
      provides: "EQ curve with visible lines"
      contains: "useCanvasSetup"
  key_links:
    - from: "src/hooks/useCanvasSetup.ts"
      to: "All canvas renderers"
      via: "ctx state triggers re-render"
      pattern: "setCtx"
---

<objective>
Fix BUG-08 and BUG-09: Canvas-based visualizations and curves not rendering visibly on canvas

**Root Cause Analysis:**
The `useCanvasSetup` hook returns `ctxRef.current` directly, which is `null` on first render. The `useLayoutEffect` inside the hook sets `ctxRef.current` after the component mounts, but this doesn't trigger a re-render. The renderers check `if (!ctx) return` early, so they never draw because `ctx` is always `null` during the render phase.

**Solution:**
Change `useCanvasSetup` to use `useState` for the context instead of a ref, so that when the context becomes available, it triggers a re-render and the drawing code executes.

Purpose: Enable all 10 Canvas-based element types to render visibly on designer canvas
Output: Working Canvas renderers that draw on first mount and update on property changes
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/useCanvasSetup.ts
@src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix useCanvasSetup hook to trigger re-renders</name>
  <files>src/hooks/useCanvasSetup.ts</files>
  <action>
Modify the `useCanvasSetup` hook to use `useState` instead of `useRef` for the canvas context:

1. Replace `const ctxRef = useRef<CanvasRenderingContext2D | null>(null)` with:
   `const [ctx, setCtx] = useState<CanvasRenderingContext2D | null>(null)`

2. In the `useLayoutEffect`, instead of setting `ctxRef.current = ctx`, call `setCtx(ctx)`

3. Return `{ canvasRef, ctx }` (ctx is now state, not ref.current)

This change ensures that when the canvas context becomes available, React re-renders the component and the drawing code in the useLayoutEffect of the renderer runs.

**Important:** Keep `useLayoutEffect` (not `useEffect`) for the canvas setup to avoid flicker.
  </action>
  <verify>TypeScript compiles without errors: `npm run build 2>&1 | head -50`</verify>
  <done>useCanvasSetup returns ctx as state value that triggers re-renders when set</done>
</task>

<task type="auto">
  <name>Task 2: Verify all Canvas renderers use the updated hook correctly</name>
  <files>
    src/components/elements/renderers/displays/curves/EQCurveRenderer.tsx
    src/components/elements/renderers/displays/curves/CompressorCurveRenderer.tsx
    src/components/elements/renderers/displays/curves/EnvelopeDisplayRenderer.tsx
    src/components/elements/renderers/displays/curves/LFODisplayRenderer.tsx
    src/components/elements/renderers/displays/curves/FilterResponseRenderer.tsx
    src/components/elements/renderers/displays/visualizations/ScrollingWaveformRenderer.tsx
    src/components/elements/renderers/displays/visualizations/SpectrumAnalyzerRenderer.tsx
    src/components/elements/renderers/displays/visualizations/SpectrogramRenderer.tsx
    src/components/elements/renderers/displays/visualizations/GoniometerRenderer.tsx
    src/components/elements/renderers/displays/visualizations/VectorscopeRenderer.tsx
  </files>
  <action>
Review all 10 Canvas-based renderers to ensure they:

1. Destructure `ctx` correctly from `useCanvasSetup` (they already do this)
2. Have `ctx` in their `useLayoutEffect` dependency array (they already do)
3. Return early if `ctx` is null to avoid drawing on unmounted canvas

The renderers should work correctly after the hook fix without needing changes, but verify by checking one or two files that the pattern is:
```tsx
const { canvasRef, ctx } = useCanvasSetup(width, height, canvasScale)

useLayoutEffect(() => {
  if (!ctx) return
  // drawing code
}, [ctx, /* other deps */])
```

If any renderer is missing `ctx` from dependencies, add it.
  </action>
  <verify>
Run the app and drag an EQ Curve and Scrolling Waveform to canvas:
1. `npm run dev` in background
2. Both element types should render visible content (not blank rectangles)
  </verify>
  <done>All 5 curve types and all 5 visualization types render visible content on canvas drop</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no TypeScript errors
2. Run `npm run dev`, open app in browser
3. Drag "EQ Curve" from Curves palette to canvas - verify visible grid and curve line
4. Drag "Scrolling Waveform" from Visualizations palette - verify visible waveform
5. Drag all 5 curve types - all show visible lines/grids
6. Drag all 5 visualization types - all show visible content
7. Select an EQ Curve, change `bandCount` property - verify curve updates
</verification>

<success_criteria>
- All 5 curve types (EQ Curve, Compressor Curve, Envelope Display, LFO Display, Filter Response) render visibly
- All 5 visualization types (Scrolling Waveform, Spectrum Analyzer, Spectrogram, Goniometer, Vectorscope) render visibly
- Canvas elements update when properties change in property panel
- No TypeScript errors
- No console errors related to canvas context
</success_criteria>

<output>
After completion, create `.planning/phases/27.1-post-phase-bugfixes/27.1-01-SUMMARY.md`
</output>
