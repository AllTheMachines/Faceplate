---
phase: 42-layers-panel
plan: 04
type: execute
wave: 3
depends_on: ["42-02"]
files_modified:
  - src/components/Layers/LayersPanel.tsx
  - src/components/Layers/LayerRow.tsx
  - src/components/Canvas/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "User can drag layers to reorder them in the panel"
    - "Default layer always stays at bottom and cannot be dragged"
    - "Layer order determines z-order on canvas"
    - "Top layer in panel renders on top of other layers' elements on canvas"
    - "Drop indicator shows where layer will land when dragging"
  artifacts:
    - path: "src/components/Layers/LayersPanel.tsx"
      provides: "Layer list with drag-drop reordering"
      contains: "onMove|reorderLayers"
    - path: "src/components/Canvas/Canvas.tsx"
      provides: "Canvas rendering elements sorted by layer order"
      contains: "getLayersInOrder|layer.order"
  key_links:
    - from: "src/components/Layers/LayersPanel.tsx"
      to: "src/store/layersSlice.ts"
      via: "reorderLayers action"
      pattern: "reorderLayers"
    - from: "src/components/Canvas/Canvas.tsx"
      to: "src/store/layersSlice.ts"
      via: "getLayersInOrder selector for z-order"
      pattern: "getLayersInOrder"
---

<objective>
Implement drag-to-reorder for layers and z-order synchronization.

Purpose: Users can reorganize layers by dragging, and layer order determines which elements render on top. This provides intuitive z-order control.
Output: Draggable layer list with react-arborist, canvas renders elements by layer order
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/42-layers-panel/42-CONTEXT.md
@.planning/phases/42-layers-panel/42-RESEARCH.md
@.planning/phases/42-layers-panel/42-02-SUMMARY.md

@src/components/Layers/LayersPanel.tsx (add drag-drop)
@src/components/Layers/LayerRow.tsx (drag handle)
@src/components/Canvas/Canvas.tsx (z-order rendering)
@src/store/layersSlice.ts (reorderLayers action)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement drag-drop reordering with react-arborist</name>
  <files>src/components/Layers/LayersPanel.tsx</files>
  <action>
Update `src/components/Layers/LayersPanel.tsx` to use react-arborist for drag-drop:

1. Import Tree from react-arborist:
   ```typescript
   import { Tree, NodeRendererProps } from 'react-arborist'
   ```

2. Get reorderLayers from store:
   ```typescript
   const reorderLayers = useStore((state) => state.reorderLayers)
   ```

3. Transform layers to arborist data format (flat, no nesting):
   ```typescript
   // Reverse so top layer (highest order) appears first
   const orderedLayers = getLayersInOrder().slice().reverse()

   const treeData = orderedLayers.map((layer) => ({
     id: layer.id,
     name: layer.name,
     layer: layer, // Attach full layer object for rendering
   }))
   ```

4. Configure Tree component:
   ```jsx
   <Tree
     data={treeData}
     openByDefault={false}
     disableDrag={(data) => data.layer.id === 'default'} // Can't drag default
     disableDrop={({ parentNode, dragNodes }) => {
       // No nesting allowed (flat list)
       if (parentNode) return true
       // Can't drop on default layer's position (keep it at bottom)
       // The default layer should always be last in visual order (lowest z)
       return false
     }}
     onMove={({ dragIds, parentId, index }) => {
       // Convert visual index to layer array index
       const dragId = dragIds[0]
       if (!dragId) return

       const layers = getLayersInOrder()
       const dragIndex = layers.findIndex(l => l.id === dragId)

       // Visual list is reversed, so convert index
       // index 0 in visual = highest order, index N in visual = lowest (default)
       const visualLength = layers.length
       const targetOrder = visualLength - 1 - index

       // Find the actual target index in the layers array (sorted by order)
       const targetIndex = Math.max(1, Math.min(targetOrder, layers.length - 1))
       // Don't allow dropping at index 0 (that's where default is)

       if (dragIndex !== -1 && dragIndex !== targetIndex) {
         reorderLayers(dragIndex, targetIndex)
       }
     }}
     rowHeight={40}
     width="100%"
     height={300}
     indent={0} // No indentation (flat list)
   >
     {LayerNode}
   </Tree>
   ```

5. Create LayerNode render component that wraps LayerRow:
   ```typescript
   function LayerNode({ node, style, dragHandle }: NodeRendererProps<any>) {
     return (
       <div style={style}>
         <LayerRow
           layer={node.data.layer}
           isSelected={selectedLayerId === node.data.layer.id}
           onSelect={selectLayer}
           dragHandle={dragHandle}
         />
       </div>
     )
   }
   ```

6. Add visual drop indicator styling via CSS or inline styles.

Note: The Tree component handles virtualization and keyboard navigation automatically.
  </action>
  <verify>
    - Layers can be dragged up/down in the list
    - Drop indicator shows during drag
    - Default layer cannot be dragged
    - Layers cannot be dropped below default layer
    - No nesting allowed (stays flat)
  </verify>
  <done>Layer list supports drag-drop reordering via react-arborist</done>
</task>

<task type="auto">
  <name>Task 2: Update LayerRow with drag handle styling</name>
  <files>src/components/Layers/LayerRow.tsx</files>
  <action>
Update `src/components/Layers/LayerRow.tsx` to support drag handle:

1. Update props to accept dragHandle:
   ```typescript
   interface LayerRowProps {
     layer: Layer
     isSelected: boolean
     onSelect: (id: string) => void
     dragHandle?: React.RefObject<HTMLDivElement>
   }
   ```

2. Apply dragHandle ref to the row container:
   ```jsx
   <div
     ref={dragHandle}
     className={`flex items-center gap-2 px-3 py-2 cursor-pointer ...`}
   >
   ```

3. Add drag handle visual indicator (6-dot grip icon) before the color dot:
   ```jsx
   {layer.id !== 'default' && (
     <div className="flex-shrink-0 text-gray-600 cursor-grab active:cursor-grabbing">
       <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
         <circle cx="9" cy="6" r="1.5" />
         <circle cx="15" cy="6" r="1.5" />
         <circle cx="9" cy="12" r="1.5" />
         <circle cx="15" cy="12" r="1.5" />
         <circle cx="9" cy="18" r="1.5" />
         <circle cx="15" cy="18" r="1.5" />
       </svg>
     </div>
   )}
   ```

4. For default layer, add some left padding to align with other layers:
   ```jsx
   {layer.id === 'default' && <div className="w-4" />}
   ```

5. Add hover state to show drag handle more prominently:
   ```jsx
   className="... group"
   // Then on grip icon:
   className="... text-gray-600 group-hover:text-gray-400"
   ```
  </action>
  <verify>Drag grip icon visible on non-default layers, cursor changes on hover</verify>
  <done>LayerRow has visual drag handle, default layer has no handle</done>
</task>

<task type="auto">
  <name>Task 3: Implement z-order rendering based on layer order</name>
  <files>src/components/Canvas/Canvas.tsx</files>
  <action>
Update `src/components/Canvas/Canvas.tsx` to render elements sorted by layer order:

1. Get getLayersInOrder from store:
   ```typescript
   const getLayersInOrder = useStore((state) => state.getLayersInOrder)
   ```

2. Create a sorting function for elements based on layer order:
   ```typescript
   // Sort elements by layer order for z-index rendering
   const sortElementsByLayerOrder = (elements: ElementConfig[]): ElementConfig[] => {
     const layers = getLayersInOrder() // Returns layers sorted by order (0 = bottom)
     const layerOrderMap = new Map(layers.map((l, idx) => [l.id, idx]))

     return [...elements].sort((a, b) => {
       const layerIdA = a.layerId || 'default'
       const layerIdB = b.layerId || 'default'

       const orderA = layerOrderMap.get(layerIdA) ?? 0
       const orderB = layerOrderMap.get(layerIdB) ?? 0

       // Elements in lower-order layers render first (back)
       // Elements in higher-order layers render later (front)
       if (orderA !== orderB) {
         return orderA - orderB
       }

       // Within same layer, maintain creation order (array position)
       return 0
     })
   }
   ```

3. Apply this sorting before rendering elements:
   ```typescript
   // Already filtered for visibility in previous task
   const visibleElements = elements.filter(...)

   // Sort by layer order for z-index
   const sortedElements = sortElementsByLayerOrder(visibleElements)

   // Render sortedElements
   ```

4. Important: In Konva/react-konva, render order IS z-order. Elements rendered first appear behind elements rendered later. So elements from layer order=0 (default) render first, then order=1, etc.

5. If the canvas uses explicit zIndex, update the calculation:
   ```typescript
   // Calculate effective z-index
   const getEffectiveZIndex = (element: ElementConfig): number => {
     const layers = getLayersInOrder()
     const layerId = element.layerId || 'default'
     const layerIndex = layers.findIndex(l => l.id === layerId)

     // Base z-index from layer order * 1000
     // This ensures all elements in higher layers are above all elements in lower layers
     const layerBase = (layerIndex >= 0 ? layerIndex : 0) * 1000

     // Within layer, use element's original zIndex or creation order
     return layerBase + (element.zIndex || 0)
   }
   ```

6. Elements should render in order of their effective z-index.
  </action>
  <verify>
    - Create two layers: "Top" and "Bottom"
    - Add red rectangle to Bottom layer
    - Add blue rectangle to Top layer, overlapping red
    - Blue renders on top of red
    - Drag "Bottom" layer above "Top" in panel
    - Red now renders on top of blue
  </verify>
  <done>Canvas renders elements sorted by layer order, higher-order layers render on top</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit`
2. Dev server: `npm run dev`
3. Functional tests:
   - Drag a layer (not default) up/down in list
   - Drop indicator shows where it will land
   - Releasing drop completes reorder
   - Default layer cannot be dragged (no grip icon)
   - Cannot drop any layer below default
   - Create overlapping elements in different layers
   - Reorder layers, element rendering order changes
   - Top layer in panel = elements render on top
</verification>

<success_criteria>
- Layers can be reordered via drag-drop in panel
- Default layer fixed at bottom (cannot be moved)
- Drop indicator provides visual feedback
- Layer order determines z-order on canvas
- Elements in higher-order layers render on top of elements in lower-order layers
</success_criteria>

<output>
After completion, create `.planning/phases/42-layers-panel/42-04-SUMMARY.md`
</output>
