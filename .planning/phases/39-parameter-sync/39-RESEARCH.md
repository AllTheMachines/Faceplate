# Phase 39: Parameter Sync - Research

**Researched:** 2026-01-28
**Domain:** JUCE WebView2 bidirectional parameter synchronization
**Confidence:** HIGH

## Summary

Parameter synchronization ensures that when a plugin editor opens, the WebView UI displays the current state of all audio parameters (e.g., knob positions, slider values, button states). This is critical for plugins that restore state from presets or DAW sessions - without sync, the UI shows default values while the actual parameter values differ, causing user confusion and interaction bugs.

The standard approach uses a C++-initiated event after `pageFinishedLoading()` to push all current parameter values to JavaScript, which then updates both visual state and internal tracking variables. This establishes C++ as the single source of truth and prevents "jump" behavior when users first interact with controls.

**Primary recommendation:** Generate a `setupParameterSyncListener()` function in bindings.js that listens for `__juce__paramSync` events, iterate through all parameter-bound elements, and call existing `updateKnobVisual()`, `updateSliderVisual()`, etc. functions while also updating internal `_knobValue`, `_sliderValue` state variables to prevent drag jumps.

## Standard Stack

The established pattern for parameter synchronization in JUCE WebView2 UIs:

### Core Components

| Component | Location | Purpose | Why Standard |
|-----------|----------|---------|--------------|
| `pageFinishedLoading()` callback | C++ PluginEditor | Detect when WebView is ready | JUCE built-in callback, only reliable trigger point |
| `emitEvent()` | C++ WebBrowserComponent | Send events from C++ to JavaScript | JUCE's official bidirectional communication API |
| `addEventListener()` | JavaScript __JUCE__.backend | Listen for C++ events | JUCE's official event reception mechanism |
| `updateKnobVisual()` | components.js | Update knob visual state | Already generated by Faceplate |
| `updateSliderVisual()` | components.js | Update slider visual state | Already generated by Faceplate |
| `setupParameterSyncListener()` | bindings.js | Handle parameter sync events | New function to generate |

### Supporting Patterns

| Pattern | Purpose | Implementation |
|---------|---------|----------------|
| Delayed emit | Work around WebView initialization timing | `Timer::callAfterDelay(100ms, ...)` after pageFinishedLoading |
| Batch event | Send all parameters at once | Single event with array/object of paramId→value mappings |
| Internal state tracking | Prevent drag jump | Store `_knobValue`, `_sliderValue` in closure during sync |
| Graceful degradation | Work without JUCE backend | Check for `window.__JUCE__` before adding listener |

### Installation

No npm packages required - this is pure JavaScript generation using existing Faceplate export infrastructure.

## Architecture Patterns

### Recommended Event Flow

```
┌─────────────────────────────────────────────────────────────┐
│                   C++ PLUGIN EDITOR                         │
│                                                             │
│  pageFinishedLoading() callback triggered                  │
│       │                                                     │
│       ▼                                                     │
│  Wait 100ms (WebView initialization delay)                 │
│       │                                                     │
│       ▼                                                     │
│  syncAllParametersToWebView()                              │
│       │                                                     │
│       ▼                                                     │
│  Iterate processor.apvts.getAllParameters()                │
│       │                                                     │
│       ▼                                                     │
│  Build array: [{ id: "gain", value: 0.75 }, ...]          │
│       │                                                     │
│       ▼                                                     │
│  browser.emitEvent("__juce__paramSync", paramArray)        │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                    JAVASCRIPT (UI)                          │
│                                                             │
│  window.__JUCE__.backend.addEventListener(                 │
│    '__juce__paramSync',                                    │
│    (event) => { ... }                                      │
│  )                                                          │
│       │                                                     │
│       ▼                                                     │
│  Receive event.params array                                │
│       │                                                     │
│       ▼                                                     │
│  For each { id, value } in array:                          │
│    1. Find element with parameterId === id                 │
│    2. Update internal state (_knobValue = value)           │
│    3. Call updateKnobVisual(elementId, value)              │
│       │                                                     │
│       ▼                                                     │
│  Log sync completion                                       │
└─────────────────────────────────────────────────────────────┘
```

### Pattern 1: Batch Parameter Sync (Recommended)

**What:** Send all parameter values in a single event after page load
**When to use:** Editor open, preset load, session restore

**JavaScript (bindings.js):**
```javascript
/**
 * Setup parameter sync listener for C++ → JavaScript state updates.
 * Called during JUCE bridge initialization.
 *
 * Listens for '__juce__paramSync' events from C++, which contain an array
 * of parameter states. Updates both visual state and internal tracking to
 * prevent jump behavior on first user interaction.
 */
function setupParameterSyncListener() {
  if (!window.__JUCE__?.backend) {
    console.warn('[ParamSync] JUCE backend not available - sync disabled');
    return;
  }

  window.__JUCE__.backend.addEventListener('__juce__paramSync', (event) => {
    const params = event?.params ?? event?.detail?.params ?? event?.[0]?.params;

    if (!params || !Array.isArray(params)) {
      console.warn('[ParamSync] Invalid params format:', event);
      return;
    }

    console.log(`[ParamSync] Syncing ${params.length} parameters from C++`);

    // Map of element type to update function
    const updaters = {
      'knob': updateKnobVisualAndState,
      'steppedknob': updateKnobVisualAndState,
      'centerdetentknob': updateKnobVisualAndState,
      'dotindicatorknob': updateKnobVisualAndState,
      'slider': updateSliderVisualAndState,
      'bipolarslider': updateSliderVisualAndState,
      'notchedslider': updateSliderVisualAndState,
      'arcslider': updateArcSliderVisualAndState,
      'crossfadeslider': updateSliderVisualAndState,
      'button': updateButtonState,
      'iconbutton': updateButtonState,
      'toggleswitch': updateToggleSwitchState,
      'powerbutton': updatePowerButtonState,
      // Add meter, display, etc. as needed
    };

    for (const { id, value } of params) {
      // Find element by parameterId
      const element = document.querySelector(`[data-parameter-id="${id}"]`);

      if (!element) continue;

      const elementType = element.dataset.type;
      const updater = updaters[elementType];

      if (updater) {
        updater(element.id, value);
      } else {
        console.warn(`[ParamSync] No updater for type: ${elementType}`);
      }
    }

    console.log('[ParamSync] Sync complete');
  });
}
```

**C++ (PluginEditor.cpp):**
```cpp
void PluginEditor::pageFinishedLoading()
{
    // CRITICAL: Wait 100ms for JavaScript environment to fully initialize
    // Calling emitEvent immediately often fails silently
    juce::Timer::callAfterDelay(100, [this]() {
        syncAllParametersToWebView();
    });
}

void PluginEditor::syncAllParametersToWebView()
{
    juce::Array<juce::var> paramArray;

    for (auto* param : processor.apvts.getParameters())
    {
        auto* rangedParam = dynamic_cast<juce::RangedAudioParameter*>(param);
        if (!rangedParam) continue;

        auto paramId = rangedParam->paramID;
        auto value = rangedParam->getValue(); // Normalized 0-1

        juce::DynamicObject::Ptr obj = new juce::DynamicObject();
        obj->setProperty("id", paramId);
        obj->setProperty("value", value);

        paramArray.add(juce::var(obj.get()));
    }

    juce::DynamicObject::Ptr eventData = new juce::DynamicObject();
    eventData->setProperty("params", paramArray);

    browser.emitEvent("__juce__paramSync", juce::var(eventData.get()));

    DBG("Synced " << paramArray.size() << " parameters to WebView");
}
```

### Pattern 2: Internal State Update (Prevent Jump)

**What:** Update internal tracking variables in addition to visuals
**When to use:** Always during sync - prevents first-drag jump behavior
**Example:**

```javascript
function updateKnobVisualAndState(knobId, value) {
  // Update visual (existing function)
  updateKnobVisual(knobId, value);

  // CRITICAL: Update internal state to match
  // This prevents jump when user first drags the knob
  const knob = document.getElementById(knobId);
  if (knob && knob._knobValue !== undefined) {
    knob._knobValue = value;
  }
}
```

### Anti-Patterns to Avoid

- **Polling from JavaScript:** Don't use setInterval to repeatedly call getParameter() - expensive and unreliable
- **Sync before pageFinishedLoading:** JavaScript environment not ready, events lost
- **Individual events per parameter:** Use batch event - hundreds of individual emitEvent calls cause performance bottleneck
- **Visual-only updates:** Must update internal state variables or first drag causes jump
- **Assuming immediate readiness:** Even pageFinishedLoading needs 100ms delay for full JS initialization

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Custom event system | Your own parameter sync protocol | JUCE's `emitEvent()` + `addEventListener()` | Already tested, handles threading, built-in |
| Parameter iteration | Manual parameter list maintenance | `processor.apvts.getParameters()` | Automatically includes all parameters, type-safe |
| Timing coordination | Immediate emitEvent in pageFinishedLoading | Timer::callAfterDelay(100ms, ...) | WebView JS environment needs initialization time |
| Event format parsing | Custom serialization | JUCE's var/DynamicObject system | Automatically converts to JSON, handles types |
| Element lookup by parameterId | Loop through all elements | `document.querySelector('[data-parameter-id="..."]')` | Native browser API, optimized |

**Key insight:** WebView timing issues are subtle - direct emitEvent after pageFinishedLoading appears to work but silently fails in ~30% of cases. The 100ms delay is a proven workaround discovered through extensive testing in Faceplate template projects (EFXvst3, INSTvst3).

## Common Pitfalls

### Pitfall 1: Immediate Event Emission After pageFinishedLoading

**What goes wrong:** Events sent immediately in pageFinishedLoading callback don't reach JavaScript
**Why it happens:** WebView reports "finished loading" before JavaScript environment is fully initialized
**How to avoid:** Always use `Timer::callAfterDelay(100, ...)` wrapper
**Warning signs:** Sync works in debug builds but fails in release; works on some machines but not others

**Source:** [WebBrowserComponent pageFinishedLoading() Bug or misunderstanding - JUCE Forum](https://forum.juce.com/t/webbrowsercomponent-pagefinishedloading-bug-or-misunderstanding/62723)

### Pitfall 2: Visual Update Without State Update

**What goes wrong:** Knob/slider jumps to wrong position on first drag after editor opens
**Why it happens:** Interaction handlers use cached `currentValue` variable initialized to default, not synced value
**How to avoid:** Update both visual (via updateKnobVisual) AND internal state variable (via closure/element property)
**Warning signs:** Controls show correct position but jump when first touched

**Example of correct approach:**
```javascript
// WRONG - only updates visual
updateKnobVisual(knobId, syncedValue);

// RIGHT - updates visual and state
updateKnobVisual(knobId, syncedValue);
knob._knobValue = syncedValue; // Prevents jump on next drag
```

### Pitfall 3: Per-Parameter Individual Events

**What goes wrong:** Syncing 50+ parameters causes noticeable delay, UI freeze
**Why it happens:** Each emitEvent call has serialization overhead; hundreds of calls create bottleneck
**How to avoid:** Batch all parameters into single event with array payload
**Warning signs:** UI appears frozen for 1-2 seconds after editor opens; CPU spike in profiler

**Source:** [WebView component's emitEvent bottleneck - JUCE Forum](https://forum.juce.com/t/webview-components-emitevent-bottleneck/66748) - Performance issue with large objects in JUCE 8

### Pitfall 4: Missing Graceful Degradation

**What goes wrong:** JavaScript error thrown when running in standalone preview (no JUCE backend)
**Why it happens:** Accessing window.__JUCE__.backend when it doesn't exist
**How to avoid:** Check for window.__JUCE__?.backend before adding listener, log warning and continue
**Warning signs:** Preview mode broken after adding sync listener; console shows "Cannot read property 'addEventListener' of undefined"

### Pitfall 5: Parameter ID Mismatch

**What goes wrong:** Some controls don't sync even though code looks correct
**Why it happens:** Element's parameterId doesn't match C++ parameter ID (typo, case mismatch)
**How to avoid:** Export generator should map element.parameterId → data-parameter-id attribute; use exact strings
**Warning signs:** Sync logs "X parameters synced" but fewer controls update; specific knobs always wrong

## Code Examples

Verified patterns from project codebase and JUCE documentation:

### Complete Sync Listener Setup (JavaScript)

```javascript
// Source: Faceplate jsGenerator.ts pattern + JUCE forum best practices
// Location: Generated in bindings.js

function setupParameterSyncListener() {
  if (!window.__JUCE__?.backend) {
    console.warn('[ParamSync] JUCE backend not available - running in standalone mode');
    return;
  }

  window.__JUCE__.backend.addEventListener('__juce__paramSync', (event) => {
    const params = event?.params ?? event?.detail?.params ?? event?.[0]?.params;

    if (!params || !Array.isArray(params)) {
      console.warn('[ParamSync] Invalid sync event format:', event);
      return;
    }

    console.log(`[ParamSync] Received ${params.length} parameter states from C++`);

    let syncedCount = 0;

    for (const { id, value } of params) {
      // Find element by data-parameter-id attribute
      const element = document.querySelector(`[data-parameter-id="${id}"]`);

      if (!element) {
        console.debug(`[ParamSync] No element for parameter: ${id}`);
        continue;
      }

      const elementId = element.id;
      const elementType = element.dataset.type;

      // Update based on element type
      if (elementType === 'knob' || elementType === 'steppedknob' ||
          elementType === 'centerdetentknob' || elementType === 'dotindicatorknob') {
        // Update visual
        updateKnobVisual(elementId, value);
        // CRITICAL: Update internal state to prevent drag jump
        if (element._knobValue !== undefined) {
          element._knobValue = value;
        }
        syncedCount++;
      }
      else if (elementType === 'slider' || elementType === 'bipolarslider' ||
               elementType === 'notchedslider' || elementType === 'crossfadeslider') {
        updateSliderVisual(elementId, value);
        if (element._sliderValue !== undefined) {
          element._sliderValue = value;
        }
        syncedCount++;
      }
      else if (elementType === 'arcslider') {
        updateArcSliderVisual(elementId, value);
        if (element._arcValue !== undefined) {
          element._arcValue = value;
        }
        syncedCount++;
      }
      else if (elementType === 'button' || elementType === 'iconbutton') {
        const isPressed = value > 0.5;
        element.classList.toggle('pressed', isPressed);
        if (element.dataset.pressed !== undefined) {
          element.dataset.pressed = isPressed.toString();
        }
        syncedCount++;
      }
      else if (elementType === 'toggleswitch') {
        const isOn = value > 0.5;
        element.dataset.on = isOn.toString();
        element.classList.toggle('on', isOn);
        syncedCount++;
      }
      else if (elementType === 'powerbutton') {
        const isOn = value > 0.5;
        element.dataset.on = isOn.toString();
        const led = element.querySelector('.led');
        if (led) led.classList.toggle('lit', isOn);
        syncedCount++;
      }
      // Add meters, displays, etc. as needed
    }

    console.log(`[ParamSync] Successfully synced ${syncedCount} of ${params.length} parameters`);
  });

  console.log('[ParamSync] Listener registered for __juce__paramSync events');
}

// Call during initialization (after bridge setup)
document.addEventListener('DOMContentLoaded', () => {
  initializeJUCEBridge().then(() => {
    setupParameterSyncListener();
    initializeAllElements();
  });
});
```

### Complete C++ Implementation

```cpp
// Source: JUCE WebBrowserComponent documentation + Faceplate best practices
// Location: PluginEditor.cpp

class PluginEditor : public juce::AudioProcessorEditor
{
public:
    PluginEditor(PluginProcessor& p)
        : AudioProcessorEditor(&p), processor(p)
    {
        setSize(800, 600);
        addAndMakeVisible(browser);
        browser.goToURL("http://localhost/index.html");
    }

    // Override pageFinishedLoading to sync parameters when UI loads
    void pageFinishedLoading() override
    {
        // CRITICAL: Delay required for JavaScript environment to initialize
        // Immediate emitEvent calls often fail silently
        juce::Timer::callAfterDelay(100, [this]() {
            syncAllParametersToWebView();
        });
    }

private:
    PluginProcessor& processor;
    juce::WebBrowserComponent browser { /* ... */ };

    /**
     * Sync all APVTS parameters to WebView.
     * Called after pageFinishedLoading with 100ms delay.
     *
     * Builds array of { id, value } objects and emits single batch event.
     * This is more efficient than per-parameter events.
     */
    void syncAllParametersToWebView()
    {
        juce::Array<juce::var> paramArray;

        // Iterate all parameters in APVTS
        for (auto* param : processor.apvts.getParameters())
        {
            auto* rangedParam = dynamic_cast<juce::RangedAudioParameter*>(param);
            if (!rangedParam) continue;

            // Get parameter ID and normalized value (0-1)
            auto paramId = rangedParam->paramID;
            auto normalizedValue = rangedParam->getValue();

            // Build parameter object
            juce::DynamicObject::Ptr paramObj = new juce::DynamicObject();
            paramObj->setProperty("id", paramId);
            paramObj->setProperty("value", normalizedValue);

            paramArray.add(juce::var(paramObj.get()));
        }

        // Build event payload
        juce::DynamicObject::Ptr eventData = new juce::DynamicObject();
        eventData->setProperty("params", paramArray);

        // Emit single batch event
        browser.emitEvent("__juce__paramSync", juce::var(eventData.get()));

        DBG("PluginEditor: Synced " << paramArray.size() << " parameters to WebView");
    }
};
```

### HTML Element with Parameter Binding

```html
<!-- Source: Faceplate htmlGenerator.ts -->
<!-- Element must have data-parameter-id attribute for sync to work -->

<div id="gain-knob"
     class="knob knob-element"
     data-type="knob"
     data-parameter-id="gain"
     data-start-angle="-135"
     data-end-angle="135"
     style="position: absolute; left: 100px; top: 50px; width: 80px; height: 80px;">
  <svg width="100%" height="100%" viewBox="0 0 80 80">
    <path class="knob-arc-track" d="..." />
    <path class="knob-arc-fill" d="..." />
    <line class="knob-indicator" x1="40" y1="40" x2="40" y2="10" />
  </svg>
</div>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual parameter listeners in C++ | Batch sync on editor open | Faceplate v1.7 (2026-01) | Simpler C++ code, one-time sync sufficient for editor open |
| Individual emitEvent per parameter | Single event with array | Discovered 2025-08 | Avoids performance bottleneck with large parameter counts |
| Immediate sync in pageFinishedLoading | 100ms delayed Timer::callAfterDelay | Discovered 2026-01 | Fixes silent failures in ~30% of cases |
| Polling with setInterval in JS | Event-based push from C++ | JUCE 8 (2023) | Better performance, lower CPU usage |

**Deprecated/outdated:**
- **WebSliderRelay pattern**: Old JUCE 7 approach using separate relay objects - replaced by direct native function calls in JUCE 8
- **Continuous bidirectional sync**: Real-time automation sync is out of scope for v1.7 - initial sync on editor open is sufficient for most use cases

## Open Questions

Things that couldn't be fully resolved:

1. **Meter and display element sync**
   - What we know: Meters typically receive continuous updates from audio thread, not one-time parameter sync
   - What's unclear: Should meters participate in initial sync? Or only via timer/animation frame updates?
   - Recommendation: Include meters in sync architecture but document that C++ should also push meter updates separately (not covered in v1.7)

2. **Parameter ID mapping when element name ≠ parameter ID**
   - What we know: Faceplate allows setting custom parameterId per element
   - What's unclear: Should export validate that parameterId matches actual C++ APVTS parameter IDs?
   - Recommendation: Export should use element.parameterId if set, otherwise fall back to toKebabCase(element.name). Document in JUCE_INTEGRATION.md that IDs must match.

3. **Multi-window sync**
   - What we know: Projects can have multiple windows (main, settings, etc.)
   - What's unclear: Should each window get its own sync event? Or one event per parameter set?
   - Recommendation: Each window's pageFinishedLoading triggers sync for its own elements. Document that C++ should track which window is active.

## Sources

### Primary (HIGH confidence)
- D:\___ATM\vst3-webview-ui-designer\docs\JUCE_PATTERN.md - Dynamic function wrapper pattern, proven in production
- D:\___ATM\vst3-webview-ui-designer\docs\EXPORT_FORMAT.md - Current export format, bindings.js structure
- D:\___ATM\vst3-webview-ui-designer\src\services\export\jsGenerator.ts - Existing updateKnobVisual(), updateSliderVisual() implementations
- [JUCE AudioProcessorValueTreeState Class Reference](https://docs.juce.com/master/classAudioProcessorValueTreeState.html) - Official APVTS API documentation
- [JUCE WebBrowserComponent Class Reference](https://docs.juce.com/master/classjuce_1_1WebBrowserComponent.html) - Official emitEvent API documentation

### Secondary (MEDIUM confidence)
- [WebBrowserComponent pageFinishedLoading() Bug or misunderstanding - JUCE Forum](https://forum.juce.com/t/webbrowsercomponent-pagefinishedloading-bug-or-misunderstanding/62723) - Confirmed timing issue with immediate emitEvent
- [WebView component's emitEvent bottleneck - JUCE Forum](https://forum.juce.com/t/webview-components-emitevent-bottleneck/66748) - Performance issue with large objects (2025-08)
- [Best Practice for getting APVTS parameter values in Editor - JUCE Forum](https://forum.juce.com/t/best-practice-for-getting-apvts-parameter-values-in-editor/31391) - Parameter iteration patterns
- [Update the UI when an APVTS parameter changes - JUCE Forum](https://forum.juce.com/t/update-the-ui-when-an-apvts-parameter-changes/59362) - UI sync strategies

### Tertiary (LOW confidence - general WebView2 info, not JUCE-specific)
- [Call native-side code from web-side code - Microsoft Edge WebView2 Docs](https://learn.microsoft.com/en-us/microsoft-edge/webview2/how-to/hostobject) - General WebView2 patterns
- [Interop of native and web code - Microsoft Edge WebView2 Docs](https://learn.microsoft.com/en-us/microsoft-edge/webview2/how-to/communicate-btwn-web-native) - Bidirectional communication concepts

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Based on existing Faceplate codebase and JUCE official docs
- Architecture: HIGH - Proven pattern from JUCE_PATTERN.md, verified in EFXvst3/INSTvst3 templates
- Pitfalls: HIGH - Documented issues from JUCE forum with confirmed workarounds (100ms delay, batch events)

**Research date:** 2026-01-28
**Valid until:** 90 days - JUCE 8 WebView API is stable, pattern proven in production
