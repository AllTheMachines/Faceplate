---
phase: 39-parameter-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/export/jsGenerator.ts
  - src/services/export/htmlGenerator.ts
  - docs/JUCE_INTEGRATION.md
  - docs/JUCE_PATTERN.md
autonomous: true

must_haves:
  truths:
    - "When plugin editor opens after loading preset, UI shows correct parameter values"
    - "When DAW session is restored, UI shows correct parameter values"
    - "First drag interaction does not cause value to jump"
    - "UI works gracefully when JUCE backend unavailable (preview mode)"
  artifacts:
    - path: "src/services/export/jsGenerator.ts"
      provides: "setupParameterSyncListener() function generation"
      contains: "setupParameterSyncListener"
    - path: "src/services/export/htmlGenerator.ts"
      provides: "data-parameter-id attribute on elements"
      contains: "data-parameter-id"
    - path: "docs/JUCE_INTEGRATION.md"
      provides: "C++ implementation guide"
      contains: "syncAllParametersToWebView"
  key_links:
    - from: "bindings.js (generated)"
      to: "C++ emitEvent"
      via: "addEventListener('__juce__paramSync')"
      pattern: "__juce__paramSync"
    - from: "setupParameterSyncListener"
      to: "updateKnobVisual/updateSliderVisual"
      via: "element type dispatch"
      pattern: "updateKnobVisual|updateSliderVisual"
---

<objective>
Implement parameter synchronization for exported JUCE bundles

Purpose: When a plugin editor opens (after preset load, DAW session restore, or initial creation), the WebView UI must display the current C++ parameter values, not hardcoded defaults. This prevents user confusion and "jump" behavior on first interaction.

Output: Updated export generators and comprehensive JUCE integration documentation
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
@./.claude/workflows/execute-plan.md
@./.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/39-parameter-sync/39-RESEARCH.md
@docs/JUCE_PATTERN.md
@docs/EXPORT_FORMAT.md
@src/services/export/jsGenerator.ts
@src/services/export/htmlGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add data-parameter-id attribute to HTML export</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Update HTML generation to include `data-parameter-id` attribute on all parameter-bound elements.

For each element type that supports parameter binding, add the attribute when `parameterId` is set:
- Knobs (knob, steppedknob, centerdetentknob, dotindicatorknob)
- Sliders (slider, bipolarslider, notchedslider, crossfadeslider, arcslider, rangeslider, multislider)
- Buttons (button, iconbutton, kickbutton, toggleswitch, powerbutton)
- Switches (rockerswitch, rotaryswitch, segmentbutton)
- Navigation (stepper, tabbar, dropdown, multiselectdropdown, combobox)

Pattern to implement in each generator function:
```typescript
const paramAttr = config.parameterId ? ` data-parameter-id="${config.parameterId}"` : ''
// Then include ${paramAttr} in the HTML template
```

Update these functions:
1. `generateKnobHTML` - Add paramAttr after data-type="knob"
2. `generateSteppedKnobHTML` - Add paramAttr
3. `generateCenterDetentKnobHTML` - Add paramAttr
4. `generateDotIndicatorKnobHTML` - Add paramAttr
5. `generateSliderHTML` - Add paramAttr
6. `generateBipolarSliderHTML` - Add paramAttr
7. `generateNotchedSliderHTML` - Add paramAttr
8. `generateCrossfadeSliderHTML` - Add paramAttr
9. `generateArcSliderHTML` - Add paramAttr
10. `generateRangeSliderHTML` - Add paramAttr
11. `generateMultiSliderHTML` - Add paramAttr
12. Button element case (inline) - Add paramAttr
13. All switch/navigation cases in switch statement

IMPORTANT: Use `toKebabCase(element.name)` as fallback if `parameterId` is not set, matching the existing JS generator pattern.
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors.
Grep for `data-parameter-id` in htmlGenerator.ts to confirm additions.
  </verify>
  <done>
All parameter-bound elements export with `data-parameter-id` attribute when parameterId is set or inferred from element name.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate setupParameterSyncListener in bindings.js</name>
  <files>src/services/export/jsGenerator.ts</files>
  <action>
Add `setupParameterSyncListener()` function to the generated bindings.js output.

1. Add the function definition in the template string (after the JUCE bridge section, before interaction setup functions):

```javascript
// ============================================================================
// Parameter Sync - C++ to JavaScript state synchronization
// ============================================================================

/**
 * Setup parameter sync listener for C++ -> JavaScript state updates.
 * Called after JUCE bridge initialization.
 *
 * When the plugin editor opens (after preset load, DAW session restore),
 * C++ calls emitEvent('__juce__paramSync', { params: [...] }) to push
 * all current parameter values to JavaScript.
 *
 * This function:
 * 1. Listens for '__juce__paramSync' events from C++
 * 2. Updates visual state (updateKnobVisual, updateSliderVisual, etc.)
 * 3. Updates internal tracking state (prevents first-drag jump)
 */
function setupParameterSyncListener() {
  if (!window.__JUCE__?.backend) {
    console.warn('[ParamSync] JUCE backend not available - sync disabled');
    return;
  }

  window.__JUCE__.backend.addEventListener('__juce__paramSync', (event) => {
    // Handle various event formats JUCE might send
    const params = event?.params ?? event?.detail?.params ?? event?.[0]?.params;

    if (!params || !Array.isArray(params)) {
      console.warn('[ParamSync] Invalid sync event format:', event);
      return;
    }

    console.log('[ParamSync] Received ' + params.length + ' parameter states from C++');
    let syncedCount = 0;

    for (const { id, value } of params) {
      // Find element by data-parameter-id attribute
      const element = document.querySelector('[data-parameter-id="' + id + '"]');
      if (!element) continue;

      const elementId = element.id;
      const elementType = element.dataset.type;

      // Update based on element type
      if (elementType === 'knob' || elementType === 'steppedknob' ||
          elementType === 'centerdetentknob' || elementType === 'dotindicatorknob') {
        updateKnobVisual(elementId, value);
        // CRITICAL: Update internal state to prevent drag jump
        if (element._knobValue !== undefined) element._knobValue = value;
        syncedCount++;
      }
      else if (elementType === 'slider' || elementType === 'bipolarslider' ||
               elementType === 'notchedslider' || elementType === 'crossfadeslider') {
        updateSliderVisual(elementId, value);
        if (element._sliderValue !== undefined) element._sliderValue = value;
        syncedCount++;
      }
      else if (elementType === 'arcslider') {
        updateArcSliderVisual(elementId, value);
        if (element._arcValue !== undefined) element._arcValue = value;
        syncedCount++;
      }
      else if (elementType === 'button' || elementType === 'iconbutton' ||
               elementType === 'kickbutton') {
        const isPressed = value > 0.5;
        element.classList.toggle('pressed', isPressed);
        syncedCount++;
      }
      else if (elementType === 'toggleswitch' || elementType === 'powerbutton') {
        const isOn = value > 0.5;
        element.dataset.on = isOn.toString();
        element.classList.toggle('on', isOn);
        syncedCount++;
      }
      else if (elementType === 'rockerswitch') {
        // Rocker has 3 positions: 0=down, 0.5=center, 1=up
        const position = value < 0.33 ? 'down' : (value > 0.66 ? 'up' : 'center');
        element.dataset.position = position;
        syncedCount++;
      }
      else if (elementType === 'rotaryswitch' || elementType === 'segmentbutton') {
        // Discrete selection - value is normalized index
        const count = parseInt(element.dataset.count || '4');
        const index = Math.round(value * (count - 1));
        element.dataset.selected = index.toString();
        syncedCount++;
      }
    }

    console.log('[ParamSync] Synced ' + syncedCount + ' of ' + params.length + ' parameters');
  });

  console.log('[ParamSync] Listener registered for __juce__paramSync events');
}
```

2. Call `setupParameterSyncListener()` in `initializeJUCEBridge()` after bridge is created:
   - Add it after `bridge = createJUCEFunctionWrappers();` (around line 345)
   - Add comment: `// Setup parameter sync listener for C++ -> JS updates`

3. Add inline comments explaining the sync system at the top of bindings.js:
```javascript
// AUTO-GENERATED by vst3-webview-ui-designer
// JUCE WebView2 Event-Based Parameter Bindings
//
// PARAMETER SYNC:
// When the plugin editor opens, C++ should call:
//   browser.emitEvent("__juce__paramSync", { params: [...] })
// to push all current parameter values to JavaScript.
// See JUCE_INTEGRATION.md for C++ implementation.
```
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors.
Export a test project and inspect bindings.js for:
- setupParameterSyncListener function exists
- Function is called after bridge creation
- Comments explain sync purpose
  </verify>
  <done>
Generated bindings.js includes setupParameterSyncListener() that handles __juce__paramSync events, updates visual state, and updates internal tracking state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create JUCE_INTEGRATION.md documentation</name>
  <files>docs/JUCE_INTEGRATION.md</files>
  <action>
Create comprehensive JUCE integration documentation with C++ implementation examples.

Content structure:

```markdown
# JUCE Integration Guide

Complete guide to integrating Faceplate-exported WebView UIs with JUCE plugins.

## Quick Start

1. Copy exported files to your project's Resources folder
2. Add WebBrowserComponent with native function registration
3. Implement parameter sync in pageFinishedLoading()

## Parameter Sync Architecture

```
                C++ (Source of Truth)
                        |
                        | pageFinishedLoading()
                        | + 100ms delay
                        v
              emitEvent("__juce__paramSync")
                        |
                        v
                JavaScript (UI)
                        |
                        | setupParameterSyncListener()
                        v
              updateKnobVisual(), etc.
```

### Why Parameter Sync?

When a plugin editor opens, the WebView UI initializes with default values defined in the design. However, the actual parameter values in C++ may differ:
- User loaded a preset
- DAW restored session state
- Automation recorded different values

Without sync, the UI shows wrong values, and the first user interaction causes a "jump" to the displayed value.

### Timing Considerations

CRITICAL: Do not call emitEvent immediately in pageFinishedLoading(). The JavaScript environment needs ~100ms to fully initialize. Use Timer::callAfterDelay.

## C++ Implementation

### PluginEditor.h

```cpp
#include <juce_gui_extra/juce_gui_extra.h>

class PluginEditor : public juce::AudioProcessorEditor
{
public:
    PluginEditor(PluginProcessor& p);
    ~PluginEditor() override;

    void resized() override;
    void pageFinishedLoading();  // Called when WebView is ready

private:
    PluginProcessor& processor;
    juce::WebBrowserComponent browser;

    void syncAllParametersToWebView();
};
```

### PluginEditor.cpp

```cpp
PluginEditor::PluginEditor(PluginProcessor& p)
    : AudioProcessorEditor(&p), processor(p),
      browser(juce::WebBrowserComponent::Options()
          .withBackend(juce::WebBrowserComponent::Options::Backend::webview2)
          .withResourceProvider([this](const auto& url) { return getResource(url); })
          // Register native functions for JS -> C++ communication
          .withNativeFunction("setParameter", [this](auto& args, auto complete) {
              // ... (see JUCE_PATTERN.md)
          })
          // ... other native functions
      )
{
    setSize(800, 600);  // Match your design canvas size
    addAndMakeVisible(browser);
    browser.goToURL("http://localhost/index.html");
}

void PluginEditor::pageFinishedLoading()
{
    // CRITICAL: Wait 100ms for JavaScript environment to initialize
    // Calling emitEvent immediately often fails silently
    juce::Timer::callAfterDelay(100, [this]() {
        syncAllParametersToWebView();
    });
}

void PluginEditor::syncAllParametersToWebView()
{
    juce::Array<juce::var> paramArray;

    // Iterate all parameters in APVTS
    for (auto* param : processor.apvts.getParameters())
    {
        auto* rangedParam = dynamic_cast<juce::RangedAudioParameter*>(param);
        if (!rangedParam) continue;

        // Get parameter ID and normalized value (0-1)
        auto paramId = rangedParam->paramID;
        auto normalizedValue = rangedParam->getValue();

        // Build parameter object
        juce::DynamicObject::Ptr paramObj = new juce::DynamicObject();
        paramObj->setProperty("id", paramId);
        paramObj->setProperty("value", normalizedValue);

        paramArray.add(juce::var(paramObj.get()));
    }

    // Build event payload
    juce::DynamicObject::Ptr eventData = new juce::DynamicObject();
    eventData->setProperty("params", paramArray);

    // Emit single batch event
    browser.emitEvent("__juce__paramSync", juce::var(eventData.get()));

    DBG("Synced " << paramArray.size() << " parameters to WebView");
}
```

## Parameter ID Mapping

Faceplate maps element IDs to parameter IDs as follows:

| If | Then Parameter ID is |
|----|---------------------|
| `parameterId` property set | Use that value |
| `parameterId` not set | Use `toKebabCase(element.name)` |

Examples:
- Element "Gain Knob" with no parameterId → "gain-knob"
- Element "Mix" with parameterId="wetDryMix" → "wetDryMix"

Ensure your C++ APVTS parameter IDs match exactly (case-sensitive).

## Multi-Window Considerations

For projects with multiple windows:
- Each window has its own pageFinishedLoading callback
- Sync only parameters relevant to that window
- Or sync all parameters (simpler, slightly more overhead)

## Troubleshooting

### UI doesn't update after sync
1. Check browser console for "[ParamSync]" log messages
2. Verify data-parameter-id attributes in HTML match C++ parameter IDs
3. Ensure 100ms delay is used (not immediate emit)

### Controls jump on first interaction
- This indicates internal state wasn't updated during sync
- Verify setupParameterSyncListener is called
- Check that element._knobValue (etc.) is being set

### Sync works in some hosts but not others
- Some hosts restore state before editor creation
- Use Timer::callAfterDelay to ensure consistent timing

## Related Documentation

- [JUCE_PATTERN.md](./JUCE_PATTERN.md) - JS <-> C++ communication pattern
- [EXPORT_FORMAT.md](./EXPORT_FORMAT.md) - Generated file structure
```
  </action>
  <verify>
File exists at docs/JUCE_INTEGRATION.md and contains:
- pageFinishedLoading example
- syncAllParametersToWebView example
- 100ms timing note
- Parameter ID mapping explanation
  </verify>
  <done>
JUCE_INTEGRATION.md provides complete C++ implementation examples for parameter sync.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no TypeScript errors
2. Export a test project with knobs/sliders that have parameterId set
3. Verify generated HTML has `data-parameter-id` attributes
4. Verify generated bindings.js has `setupParameterSyncListener` function
5. Verify bindings.js has sync listener call in initializeJUCEBridge
6. Verify docs/JUCE_INTEGRATION.md exists with C++ examples
</verification>

<success_criteria>
1. HTML export includes `data-parameter-id="..."` on all parameter-bound elements
2. bindings.js export includes `setupParameterSyncListener()` function
3. setupParameterSyncListener handles `__juce__paramSync` event correctly
4. Listener updates both visual state AND internal tracking state
5. Graceful warning when JUCE backend unavailable (no errors)
6. JUCE_INTEGRATION.md documents C++ implementation with examples
7. Generated code includes inline comments explaining sync purpose
8. Requirements SYNC-01 through SYNC-08 and DOC-01 through DOC-04 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/39-parameter-sync/39-01-SUMMARY.md`
</output>
