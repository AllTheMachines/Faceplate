---
phase: 24-navigation-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements/controls.ts
  - src/components/elements/renderers/controls/StepperRenderer.tsx
  - src/components/elements/renderers/controls/BreadcrumbRenderer.tsx
  - src/components/elements/renderers/controls/index.ts
autonomous: true

must_haves:
  truths:
    - "Stepper element increments/decrements with +/- buttons"
    - "Stepper supports min/max/step configuration for JUCE parameter binding"
    - "Breadcrumb renders clickable path segments with separators"
    - "Both elements render on canvas with proper styling"
  artifacts:
    - path: "src/types/elements/controls.ts"
      provides: "StepperElementConfig and BreadcrumbElementConfig types"
      contains: "StepperElementConfig|BreadcrumbElementConfig"
    - path: "src/components/elements/renderers/controls/StepperRenderer.tsx"
      provides: "Stepper renderer with +/- buttons and value display"
      exports: ["StepperRenderer"]
    - path: "src/components/elements/renderers/controls/BreadcrumbRenderer.tsx"
      provides: "Breadcrumb renderer with clickable segments"
      exports: ["BreadcrumbRenderer"]
  key_links:
    - from: "StepperRenderer.tsx"
      to: "controls.ts"
      via: "type import"
      pattern: "import.*StepperElementConfig"
    - from: "BreadcrumbRenderer.tsx"
      to: "controls.ts"
      via: "type import"
      pattern: "import.*BreadcrumbElementConfig"
---

<objective>
Create type definitions and renderers for Stepper and Breadcrumb elements - the simplest navigation components.

Purpose: Stepper is a core parameter control (+/- buttons for integer/discrete values) ready for JUCE binding. Breadcrumb provides hierarchy navigation for preset browsers and file paths.

Output: Two new element types with canvas renderers, following established patterns from Phase 20-23.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-navigation-selection/24-CONTEXT.md
@.planning/phases/24-navigation-selection/24-RESEARCH.md
@src/types/elements/controls.ts
@src/components/elements/renderers/controls/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Stepper and Breadcrumb type definitions</name>
  <files>src/types/elements/controls.ts</files>
  <action>
Add StepperElementConfig and BreadcrumbElementConfig interfaces to controls.ts.

**StepperElementConfig:**
```typescript
export interface StepperElementConfig extends BaseElementConfig {
  type: 'stepper'

  // Value (for JUCE parameter binding)
  value: number
  min: number
  max: number
  step: number

  // Visual style
  buttonColor: string
  buttonHoverColor: string
  textColor: string
  backgroundColor: string
  borderColor: string
  borderRadius: number

  // Display
  showValue: boolean
  valueFormat: 'numeric' | 'custom'
  valueSuffix: string
  decimalPlaces: number

  // Layout
  orientation: 'horizontal' | 'vertical'
  buttonSize: number // Size of +/- buttons in px
}
```

**BreadcrumbElementConfig:**
```typescript
export interface BreadcrumbItem {
  id: string
  label: string
}

export interface BreadcrumbElementConfig extends BaseElementConfig {
  type: 'breadcrumb'

  // Path items
  items: BreadcrumbItem[]

  // Separator
  separator: string // Default '/'

  // Visual style
  linkColor: string
  currentColor: string
  separatorColor: string
  hoverColor: string
  fontSize: number

  // Layout
  maxVisibleItems: number // 0 = show all, >0 = truncate with ellipsis
}
```

Add to ControlElement union type.

Add type guards:
```typescript
export function isStepper(element: { type: string }): element is StepperElementConfig {
  return element.type === 'stepper'
}

export function isBreadcrumb(element: { type: string }): element is BreadcrumbElementConfig {
  return element.type === 'breadcrumb'
}
```

Add factory functions:
```typescript
export function createStepper(overrides?: Partial<StepperElementConfig>): StepperElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'stepper',
    name: 'Stepper',
    x: 0,
    y: 0,
    width: 120,
    height: 32,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    value: 0,
    min: 0,
    max: 100,
    step: 1,
    buttonColor: '#374151',
    buttonHoverColor: '#4b5563',
    textColor: '#ffffff',
    backgroundColor: '#1f2937',
    borderColor: '#6b7280',
    borderRadius: 4,
    showValue: true,
    valueFormat: 'numeric',
    valueSuffix: '',
    decimalPlaces: 0,
    orientation: 'horizontal',
    buttonSize: 24,
    ...overrides,
  }
}

export function createBreadcrumb(overrides?: Partial<BreadcrumbElementConfig>): BreadcrumbElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'breadcrumb',
    name: 'Breadcrumb',
    x: 0,
    y: 0,
    width: 200,
    height: 24,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    items: [
      { id: '1', label: 'Root' },
      { id: '2', label: 'Folder' },
      { id: '3', label: 'Current' },
    ],
    separator: '/',
    linkColor: '#3b82f6',
    currentColor: '#ffffff',
    separatorColor: '#6b7280',
    hoverColor: '#60a5fa',
    fontSize: 12,
    maxVisibleItems: 0,
    ...overrides,
  }
}
```
  </action>
  <verify>grep -c "StepperElementConfig\|BreadcrumbElementConfig" src/types/elements/controls.ts shows 2+ matches</verify>
  <done>StepperElementConfig and BreadcrumbElementConfig types added with type guards and factory functions</done>
</task>

<task type="auto">
  <name>Task 2: Create Stepper and Breadcrumb renderers</name>
  <files>
    src/components/elements/renderers/controls/StepperRenderer.tsx
    src/components/elements/renderers/controls/BreadcrumbRenderer.tsx
    src/components/elements/renderers/controls/index.ts
  </files>
  <action>
**StepperRenderer.tsx:**
Create stepper with +/- buttons on sides (horizontal) or top/bottom (vertical). Flat/minimal appearance per CONTEXT.md - no visible border until hover/focus.

```typescript
import React, { useState } from 'react'
import { StepperElementConfig } from '../../../../types/elements/controls'

interface StepperRendererProps {
  config: StepperElementConfig
}

export function StepperRenderer({ config }: StepperRendererProps) {
  const [value, setValue] = useState(config.value)
  const isHorizontal = config.orientation === 'horizontal'

  const increment = () => {
    setValue(prev => Math.min(config.max, prev + config.step))
  }

  const decrement = () => {
    setValue(prev => Math.max(config.min, prev - config.step))
  }

  const formatValue = () => {
    const displayValue = config.decimalPlaces > 0
      ? value.toFixed(config.decimalPlaces)
      : Math.round(value).toString()
    return config.showValue
      ? displayValue + config.valueSuffix
      : ''
  }

  const buttonStyle: React.CSSProperties = {
    width: isHorizontal ? config.buttonSize : '100%',
    height: isHorizontal ? '100%' : config.buttonSize,
    backgroundColor: config.buttonColor,
    color: config.textColor,
    border: 'none',
    borderRadius: config.borderRadius,
    cursor: 'pointer',
    fontSize: 16,
    fontWeight: 'bold',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'none', // Instant feedback per Phase 21 standard
  }

  return (
    <div
      style={{
        width: config.width,
        height: config.height,
        display: 'flex',
        flexDirection: isHorizontal ? 'row' : 'column',
        backgroundColor: config.backgroundColor,
        borderRadius: config.borderRadius,
        overflow: 'hidden',
      }}
      data-value={value}
      data-min={config.min}
      data-max={config.max}
      data-step={config.step}
    >
      <button
        style={buttonStyle}
        onClick={decrement}
        disabled={value <= config.min}
      >
        -
      </button>

      {config.showValue && (
        <div
          style={{
            flex: 1,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            color: config.textColor,
            fontSize: 14,
            fontFamily: 'Inter, system-ui, sans-serif',
          }}
        >
          {formatValue()}
        </div>
      )}

      <button
        style={buttonStyle}
        onClick={increment}
        disabled={value >= config.max}
      >
        +
      </button>
    </div>
  )
}
```

**BreadcrumbRenderer.tsx:**
Render path items with clickable links and separator. Last item is current (non-link).

```typescript
import React from 'react'
import { BreadcrumbElementConfig } from '../../../../types/elements/controls'

interface BreadcrumbRendererProps {
  config: BreadcrumbElementConfig
}

export function BreadcrumbRenderer({ config }: BreadcrumbRendererProps) {
  const { items, separator, linkColor, currentColor, separatorColor, fontSize, maxVisibleItems } = config

  // Truncate items if maxVisibleItems > 0
  let displayItems = items
  let showEllipsis = false

  if (maxVisibleItems > 0 && items.length > maxVisibleItems) {
    // Show first, ellipsis, then last (maxVisibleItems - 1)
    const keepEnd = maxVisibleItems - 1
    displayItems = [
      items[0],
      { id: 'ellipsis', label: '...' },
      ...items.slice(-keepEnd),
    ]
    showEllipsis = true
  }

  return (
    <nav
      aria-label="breadcrumb"
      style={{
        width: config.width,
        height: config.height,
        display: 'flex',
        alignItems: 'center',
        overflow: 'hidden',
      }}
    >
      <ol
        style={{
          display: 'flex',
          listStyle: 'none',
          padding: 0,
          margin: 0,
          alignItems: 'center',
          whiteSpace: 'nowrap',
        }}
      >
        {displayItems.map((item, index) => {
          const isLast = index === displayItems.length - 1
          const isEllipsis = item.id === 'ellipsis'

          return (
            <li key={item.id} style={{ display: 'flex', alignItems: 'center' }}>
              {isEllipsis ? (
                <span style={{ color: separatorColor, fontSize }}>{item.label}</span>
              ) : isLast ? (
                <span
                  aria-current="page"
                  style={{ color: currentColor, fontSize }}
                >
                  {item.label}
                </span>
              ) : (
                <a
                  href="#"
                  onClick={(e) => e.preventDefault()}
                  style={{
                    color: linkColor,
                    fontSize,
                    textDecoration: 'none',
                  }}
                >
                  {item.label}
                </a>
              )}

              {!isLast && (
                <span
                  style={{
                    margin: '0 6px',
                    color: separatorColor,
                    fontSize,
                  }}
                  aria-hidden="true"
                >
                  {separator}
                </span>
              )}
            </li>
          )
        })}
      </ol>
    </nav>
  )
}
```

**Update controls/index.ts:**
Add exports for both renderers:
```typescript
export { StepperRenderer } from './StepperRenderer'
export { BreadcrumbRenderer } from './BreadcrumbRenderer'
```
  </action>
  <verify>ls src/components/elements/renderers/controls/StepperRenderer.tsx src/components/elements/renderers/controls/BreadcrumbRenderer.tsx both exist</verify>
  <done>StepperRenderer and BreadcrumbRenderer created with proper styling and data attributes for JUCE binding</done>
</task>

<task type="auto">
  <name>Task 3: Register renderers in registry</name>
  <files>src/components/elements/renderers/index.ts</files>
  <action>
Update the renderer registry to include Stepper and Breadcrumb renderers.

1. Add imports at the top with other control imports:
```typescript
import {
  // ... existing imports ...
  StepperRenderer,
  BreadcrumbRenderer,
} from './controls'
```

2. Add to rendererRegistry Map (in the Controls section):
```typescript
['stepper', StepperRenderer as RendererComponent],
['breadcrumb', BreadcrumbRenderer as RendererComponent],
```

3. Add to re-exports at the bottom:
```typescript
export {
  // ... existing exports ...
  StepperRenderer,
  BreadcrumbRenderer,
  // ...
}
```
  </action>
  <verify>grep -c "stepper\|breadcrumb" src/components/elements/renderers/index.ts shows 4+ matches (2 registry + 2 exports)</verify>
  <done>Stepper and Breadcrumb renderers registered in rendererRegistry for canvas rendering</done>
</task>

</tasks>

<verification>
1. `grep "StepperElementConfig" src/types/elements/controls.ts` - Type exists
2. `grep "BreadcrumbElementConfig" src/types/elements/controls.ts` - Type exists
3. `ls src/components/elements/renderers/controls/StepperRenderer.tsx` - File exists
4. `ls src/components/elements/renderers/controls/BreadcrumbRenderer.tsx` - File exists
5. `grep "stepper" src/components/elements/renderers/index.ts` - Registry entry exists
6. TypeScript compilation: `npx tsc --noEmit` (may have pre-existing errors, check for new errors only)
</verification>

<success_criteria>
- StepperElementConfig has value, min, max, step properties for JUCE parameter binding
- BreadcrumbElementConfig has items array with id/label structure
- StepperRenderer shows +/- buttons with value display between them
- BreadcrumbRenderer shows clickable path with separators
- Both renderers use transition: none for instant feedback
- Both renderers include data attributes for JUCE integration
- Renderers registered in rendererRegistry
</success_criteria>

<output>
After completion, create `.planning/phases/24-navigation-selection/24-01-SUMMARY.md`
</output>
