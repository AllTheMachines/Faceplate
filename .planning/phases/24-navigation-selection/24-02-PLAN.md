---
phase: 24-navigation-selection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements/controls.ts
  - src/components/elements/renderers/controls/MultiSelectDropdownRenderer.tsx
  - src/components/elements/renderers/controls/ComboBoxRenderer.tsx
  - src/components/elements/renderers/controls/MenuButtonRenderer.tsx
  - src/components/elements/renderers/controls/index.ts
  - src/components/elements/renderers/index.ts
autonomous: true

must_haves:
  truths:
    - "Multi-Select Dropdown shows checkboxes for multiple selections"
    - "Multi-Select displays comma-separated text with ellipsis when closed"
    - "Combo Box combines text input with filterable dropdown"
    - "Menu Button opens context menu on click"
    - "All dropdowns have 100-150ms fade animation on open/close"
    - "All components have full keyboard support (arrow keys, Enter, Escape)"
  artifacts:
    - path: "src/types/elements/controls.ts"
      provides: "MultiSelectDropdownElementConfig, ComboBoxElementConfig, MenuButtonElementConfig types"
      contains: "MultiSelectDropdownElementConfig|ComboBoxElementConfig|MenuButtonElementConfig"
    - path: "src/components/elements/renderers/controls/MultiSelectDropdownRenderer.tsx"
      provides: "Multi-select dropdown with checkboxes"
      exports: ["MultiSelectDropdownRenderer"]
    - path: "src/components/elements/renderers/controls/ComboBoxRenderer.tsx"
      provides: "Combo box with text filtering"
      exports: ["ComboBoxRenderer"]
    - path: "src/components/elements/renderers/controls/MenuButtonRenderer.tsx"
      provides: "Button that opens context menu"
      exports: ["MenuButtonRenderer"]
  key_links:
    - from: "MultiSelectDropdownRenderer.tsx"
      to: "controls.ts"
      via: "type import"
      pattern: "import.*MultiSelectDropdownElementConfig"
    - from: "renderers/index.ts"
      to: "controls/index.ts"
      via: "import"
      pattern: "MultiSelectDropdownRenderer|ComboBoxRenderer|MenuButtonRenderer"
---

<objective>
Create type definitions and renderers for dropdown-style navigation components: Multi-Select Dropdown, Combo Box, and Menu Button.

Purpose: These components share similar interaction patterns (dropdown menus, click-outside handling, keyboard navigation) and are grouped for efficient implementation.

Output: Three new element types with renderers that implement proper keyboard navigation, CSS fade animations, and click-outside handling per CONTEXT.md decisions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-navigation-selection/24-CONTEXT.md
@.planning/phases/24-navigation-selection/24-RESEARCH.md
@src/types/elements/controls.ts
@src/components/elements/renderers/controls/DropdownRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Multi-Select, Combo Box, and Menu Button type definitions</name>
  <files>src/types/elements/controls.ts</files>
  <action>
Add three new element config interfaces to controls.ts.

**MultiSelectDropdownElementConfig:**
```typescript
export interface MultiSelectDropdownElementConfig extends BaseElementConfig {
  type: 'multiselectdropdown'

  // Options
  options: string[]
  selectedIndices: number[]

  // Selection limits
  maxSelections: number // 0 = unlimited

  // Visual style
  backgroundColor: string
  textColor: string
  borderColor: string
  borderRadius: number
  dropdownBackgroundColor: string
  selectedItemColor: string
  hoverItemColor: string

  // Layout
  dropdownMaxHeight: number // Max height of dropdown list in px
}
```

**ComboBoxElementConfig:**
```typescript
export interface ComboBoxElementConfig extends BaseElementConfig {
  type: 'combobox'

  // Options
  options: string[]
  selectedValue: string

  // Input
  placeholder: string

  // Visual style
  backgroundColor: string
  textColor: string
  borderColor: string
  borderRadius: number
  dropdownBackgroundColor: string
  selectedItemColor: string
  hoverItemColor: string

  // Layout
  dropdownMaxHeight: number
}
```

**MenuButtonElementConfig:**
```typescript
export interface MenuItem {
  id: string
  label: string
  disabled?: boolean
  divider?: boolean
}

export interface MenuButtonElementConfig extends BaseElementConfig {
  type: 'menubutton'

  // Button
  label: string

  // Menu items
  menuItems: MenuItem[]

  // Visual style
  backgroundColor: string
  textColor: string
  borderColor: string
  borderRadius: number
  menuBackgroundColor: string
  menuItemHoverColor: string
  menuTextColor: string
}
```

Add to ControlElement union type.

Add type guards:
```typescript
export function isMultiSelectDropdown(element: { type: string }): element is MultiSelectDropdownElementConfig {
  return element.type === 'multiselectdropdown'
}

export function isComboBox(element: { type: string }): element is ComboBoxElementConfig {
  return element.type === 'combobox'
}

export function isMenuButton(element: { type: string }): element is MenuButtonElementConfig {
  return element.type === 'menubutton'
}
```

Add factory functions:
```typescript
export function createMultiSelectDropdown(overrides?: Partial<MultiSelectDropdownElementConfig>): MultiSelectDropdownElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'multiselectdropdown',
    name: 'Multi-Select',
    x: 0,
    y: 0,
    width: 180,
    height: 32,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    options: ['Option 1', 'Option 2', 'Option 3', 'Option 4'],
    selectedIndices: [0],
    maxSelections: 0,
    backgroundColor: '#1f2937',
    textColor: '#ffffff',
    borderColor: '#374151',
    borderRadius: 4,
    dropdownBackgroundColor: '#1f2937',
    selectedItemColor: '#374151',
    hoverItemColor: '#4b5563',
    dropdownMaxHeight: 200,
    ...overrides,
  }
}

export function createComboBox(overrides?: Partial<ComboBoxElementConfig>): ComboBoxElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'combobox',
    name: 'Combo Box',
    x: 0,
    y: 0,
    width: 180,
    height: 32,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    options: ['Option 1', 'Option 2', 'Option 3', 'Option 4'],
    selectedValue: '',
    placeholder: 'Search or select...',
    backgroundColor: '#1f2937',
    textColor: '#ffffff',
    borderColor: '#374151',
    borderRadius: 4,
    dropdownBackgroundColor: '#1f2937',
    selectedItemColor: '#374151',
    hoverItemColor: '#4b5563',
    dropdownMaxHeight: 200,
    ...overrides,
  }
}

export function createMenuButton(overrides?: Partial<MenuButtonElementConfig>): MenuButtonElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'menubutton',
    name: 'Menu Button',
    x: 0,
    y: 0,
    width: 100,
    height: 32,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    label: 'Menu',
    menuItems: [
      { id: '1', label: 'Item 1' },
      { id: '2', label: 'Item 2' },
      { id: '3', divider: true, label: '' },
      { id: '4', label: 'Item 3' },
    ],
    backgroundColor: '#374151',
    textColor: '#ffffff',
    borderColor: '#6b7280',
    borderRadius: 4,
    menuBackgroundColor: '#1f2937',
    menuItemHoverColor: '#4b5563',
    menuTextColor: '#ffffff',
    ...overrides,
  }
}
```
  </action>
  <verify>grep -c "MultiSelectDropdownElementConfig\|ComboBoxElementConfig\|MenuButtonElementConfig" src/types/elements/controls.ts shows 3+ matches</verify>
  <done>MultiSelectDropdownElementConfig, ComboBoxElementConfig, and MenuButtonElementConfig types added with type guards and factory functions</done>
</task>

<task type="auto">
  <name>Task 2: Create MultiSelectDropdown, ComboBox, and MenuButton renderers</name>
  <files>
    src/components/elements/renderers/controls/MultiSelectDropdownRenderer.tsx
    src/components/elements/renderers/controls/ComboBoxRenderer.tsx
    src/components/elements/renderers/controls/MenuButtonRenderer.tsx
    src/components/elements/renderers/controls/index.ts
  </files>
  <action>
Create three renderers with shared patterns: click-outside handling, keyboard navigation, CSS fade animation (100-150ms).

**MultiSelectDropdownRenderer.tsx:**
```typescript
import React, { useState, useRef, useEffect } from 'react'
import { MultiSelectDropdownElementConfig } from '../../../../types/elements/controls'

interface MultiSelectDropdownRendererProps {
  config: MultiSelectDropdownElementConfig
}

export function MultiSelectDropdownRenderer({ config }: MultiSelectDropdownRendererProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [selections, setSelections] = useState<number[]>(config.selectedIndices)
  const [focusedIndex, setFocusedIndex] = useState(-1)
  const dropdownRef = useRef<HTMLDivElement>(null)

  // Click-outside handler
  useEffect(() => {
    if (!isOpen) return

    const handleClickOutside = (e: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside, true)
    return () => document.removeEventListener('mousedown', handleClickOutside, true)
  }, [isOpen])

  // Keyboard navigation
  useEffect(() => {
    if (!isOpen) return

    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault()
          setFocusedIndex(prev => Math.min(prev + 1, config.options.length - 1))
          break
        case 'ArrowUp':
          e.preventDefault()
          setFocusedIndex(prev => Math.max(prev - 1, 0))
          break
        case 'Enter':
        case ' ':
          e.preventDefault()
          if (focusedIndex >= 0) toggleSelection(focusedIndex)
          break
        case 'Escape':
          e.preventDefault()
          setIsOpen(false)
          break
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, focusedIndex, config.options.length])

  const toggleSelection = (index: number) => {
    setSelections(prev => {
      if (prev.includes(index)) {
        return prev.filter(i => i !== index)
      } else if (config.maxSelections === 0 || prev.length < config.maxSelections) {
        return [...prev, index]
      }
      return prev
    })
  }

  const selectedText = selections.length > 0
    ? selections.map(i => config.options[i]).join(', ')
    : 'Select...'

  return (
    <div
      ref={dropdownRef}
      style={{
        position: 'relative',
        width: config.width,
        height: config.height,
      }}
    >
      <button
        onClick={() => setIsOpen(!isOpen)}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
        style={{
          width: '100%',
          height: '100%',
          backgroundColor: config.backgroundColor,
          color: config.textColor,
          border: `1px solid ${config.borderColor}`,
          borderRadius: config.borderRadius,
          padding: '0 8px',
          textAlign: 'left',
          cursor: 'pointer',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap',
        }}
      >
        {selectedText}
      </button>

      <div
        role="listbox"
        aria-multiselectable="true"
        style={{
          position: 'absolute',
          top: '100%',
          left: 0,
          width: '100%',
          maxHeight: config.dropdownMaxHeight,
          overflowY: 'auto',
          backgroundColor: config.dropdownBackgroundColor,
          border: `1px solid ${config.borderColor}`,
          borderRadius: config.borderRadius,
          marginTop: 4,
          zIndex: 1000,
          opacity: isOpen ? 1 : 0,
          pointerEvents: isOpen ? 'auto' : 'none',
          transition: isOpen ? 'opacity 100ms ease-out' : 'opacity 150ms ease-in',
        }}
      >
        {config.options.map((option, index) => (
          <div
            key={index}
            role="option"
            aria-selected={selections.includes(index)}
            onClick={() => toggleSelection(index)}
            style={{
              display: 'flex',
              alignItems: 'center',
              padding: '8px',
              cursor: 'pointer',
              backgroundColor: focusedIndex === index
                ? config.hoverItemColor
                : selections.includes(index)
                  ? config.selectedItemColor
                  : 'transparent',
              color: config.textColor,
            }}
          >
            <input
              type="checkbox"
              checked={selections.includes(index)}
              onChange={() => {}}
              style={{ marginRight: 8 }}
            />
            {option}
          </div>
        ))}
      </div>
    </div>
  )
}
```

**ComboBoxRenderer.tsx:**
```typescript
import React, { useState, useRef, useEffect, useMemo } from 'react'
import { ComboBoxElementConfig } from '../../../../types/elements/controls'

interface ComboBoxRendererProps {
  config: ComboBoxElementConfig
}

export function ComboBoxRenderer({ config }: ComboBoxRendererProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [inputValue, setInputValue] = useState(config.selectedValue)
  const [focusedIndex, setFocusedIndex] = useState(-1)
  const comboRef = useRef<HTMLDivElement>(null)

  // Filter options based on input
  const filteredOptions = useMemo(() => {
    if (!inputValue) return config.options
    return config.options.filter(opt =>
      opt.toLowerCase().includes(inputValue.toLowerCase())
    )
  }, [config.options, inputValue])

  // Click-outside handler
  useEffect(() => {
    if (!isOpen) return

    const handleClickOutside = (e: MouseEvent) => {
      if (comboRef.current && !comboRef.current.contains(e.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside, true)
    return () => document.removeEventListener('mousedown', handleClickOutside, true)
  }, [isOpen])

  // Keyboard navigation
  useEffect(() => {
    if (!isOpen) return

    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault()
          setFocusedIndex(prev => Math.min(prev + 1, filteredOptions.length - 1))
          break
        case 'ArrowUp':
          e.preventDefault()
          setFocusedIndex(prev => Math.max(prev - 1, 0))
          break
        case 'Enter':
          e.preventDefault()
          if (focusedIndex >= 0 && filteredOptions[focusedIndex]) {
            setInputValue(filteredOptions[focusedIndex])
            setIsOpen(false)
          }
          break
        case 'Escape':
          e.preventDefault()
          setIsOpen(false)
          break
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, focusedIndex, filteredOptions])

  return (
    <div
      ref={comboRef}
      role="combobox"
      aria-expanded={isOpen}
      aria-controls="combo-listbox"
      style={{
        position: 'relative',
        width: config.width,
        height: config.height,
      }}
    >
      <input
        type="text"
        value={inputValue}
        placeholder={config.placeholder}
        onChange={e => {
          setInputValue(e.target.value)
          setIsOpen(true)
          setFocusedIndex(-1)
        }}
        onFocus={() => setIsOpen(true)}
        aria-autocomplete="list"
        style={{
          width: '100%',
          height: '100%',
          backgroundColor: config.backgroundColor,
          color: config.textColor,
          border: `1px solid ${config.borderColor}`,
          borderRadius: config.borderRadius,
          padding: '0 8px',
          boxSizing: 'border-box',
        }}
      />

      <ul
        id="combo-listbox"
        role="listbox"
        style={{
          position: 'absolute',
          top: '100%',
          left: 0,
          width: '100%',
          maxHeight: config.dropdownMaxHeight,
          overflowY: 'auto',
          backgroundColor: config.dropdownBackgroundColor,
          border: `1px solid ${config.borderColor}`,
          borderRadius: config.borderRadius,
          marginTop: 4,
          padding: 0,
          listStyle: 'none',
          zIndex: 1000,
          opacity: isOpen ? 1 : 0,
          pointerEvents: isOpen ? 'auto' : 'none',
          transition: isOpen ? 'opacity 100ms ease-out' : 'opacity 150ms ease-in',
        }}
      >
        {filteredOptions.map((option, index) => (
          <li
            key={option}
            role="option"
            aria-selected={index === focusedIndex}
            onClick={() => {
              setInputValue(option)
              setIsOpen(false)
            }}
            style={{
              padding: '8px',
              cursor: 'pointer',
              backgroundColor: index === focusedIndex ? config.hoverItemColor : 'transparent',
              color: config.textColor,
            }}
          >
            {option}
          </li>
        ))}
        {filteredOptions.length === 0 && (
          <li style={{ padding: '8px', color: config.textColor, opacity: 0.5 }}>
            No matches
          </li>
        )}
      </ul>
    </div>
  )
}
```

**MenuButtonRenderer.tsx:**
```typescript
import React, { useState, useRef, useEffect } from 'react'
import { MenuButtonElementConfig } from '../../../../types/elements/controls'

interface MenuButtonRendererProps {
  config: MenuButtonElementConfig
}

export function MenuButtonRenderer({ config }: MenuButtonRendererProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [focusedIndex, setFocusedIndex] = useState(-1)
  const menuRef = useRef<HTMLDivElement>(null)

  // Click-outside handler
  useEffect(() => {
    if (!isOpen) return

    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setIsOpen(false)
      }
    }

    document.addEventListener('mousedown', handleClickOutside, true)
    return () => document.removeEventListener('mousedown', handleClickOutside, true)
  }, [isOpen])

  // Keyboard navigation
  useEffect(() => {
    if (!isOpen) return

    const selectableItems = config.menuItems.filter(item => !item.divider && !item.disabled)

    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault()
          setFocusedIndex(prev => Math.min(prev + 1, selectableItems.length - 1))
          break
        case 'ArrowUp':
          e.preventDefault()
          setFocusedIndex(prev => Math.max(prev - 1, 0))
          break
        case 'Enter':
          e.preventDefault()
          if (focusedIndex >= 0) setIsOpen(false)
          break
        case 'Escape':
          e.preventDefault()
          setIsOpen(false)
          break
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, focusedIndex, config.menuItems])

  return (
    <div
      ref={menuRef}
      style={{
        position: 'relative',
        width: config.width,
        height: config.height,
      }}
    >
      <button
        onClick={() => setIsOpen(!isOpen)}
        aria-haspopup="menu"
        aria-expanded={isOpen}
        style={{
          width: '100%',
          height: '100%',
          backgroundColor: config.backgroundColor,
          color: config.textColor,
          border: `1px solid ${config.borderColor}`,
          borderRadius: config.borderRadius,
          cursor: 'pointer',
        }}
      >
        {config.label}
      </button>

      <div
        role="menu"
        style={{
          position: 'absolute',
          top: '100%',
          left: 0,
          minWidth: '100%',
          backgroundColor: config.menuBackgroundColor,
          border: `1px solid ${config.borderColor}`,
          borderRadius: config.borderRadius,
          marginTop: 4,
          boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
          zIndex: 1000,
          opacity: isOpen ? 1 : 0,
          pointerEvents: isOpen ? 'auto' : 'none',
          transition: isOpen ? 'opacity 100ms ease-out' : 'opacity 150ms ease-in',
        }}
      >
        {config.menuItems.map((item, index) => {
          if (item.divider) {
            return (
              <div
                key={item.id}
                style={{
                  height: 1,
                  backgroundColor: config.borderColor,
                  margin: '4px 0',
                }}
              />
            )
          }

          const selectableIndex = config.menuItems
            .filter((i, idx) => idx < index && !i.divider && !i.disabled)
            .length

          return (
            <button
              key={item.id}
              role="menuitem"
              disabled={item.disabled}
              onClick={() => setIsOpen(false)}
              style={{
                display: 'block',
                width: '100%',
                padding: '8px 16px',
                textAlign: 'left',
                border: 'none',
                backgroundColor: selectableIndex === focusedIndex
                  ? config.menuItemHoverColor
                  : 'transparent',
                color: item.disabled ? '#6b7280' : config.menuTextColor,
                cursor: item.disabled ? 'not-allowed' : 'pointer',
              }}
            >
              {item.label}
            </button>
          )
        })}
      </div>
    </div>
  )
}
```

**Update controls/index.ts:**
Add exports for all three renderers.
  </action>
  <verify>ls src/components/elements/renderers/controls/MultiSelectDropdownRenderer.tsx src/components/elements/renderers/controls/ComboBoxRenderer.tsx src/components/elements/renderers/controls/MenuButtonRenderer.tsx all exist</verify>
  <done>Three dropdown-style renderers created with click-outside handling, keyboard navigation, and CSS fade animations</done>
</task>

<task type="auto">
  <name>Task 3: Register renderers in registry</name>
  <files>src/components/elements/renderers/index.ts</files>
  <action>
Update the renderer registry to include all three new renderers.

1. Add imports from controls:
```typescript
import {
  // ... existing imports ...
  MultiSelectDropdownRenderer,
  ComboBoxRenderer,
  MenuButtonRenderer,
} from './controls'
```

2. Add to rendererRegistry Map (in Controls section):
```typescript
['multiselectdropdown', MultiSelectDropdownRenderer as RendererComponent],
['combobox', ComboBoxRenderer as RendererComponent],
['menubutton', MenuButtonRenderer as RendererComponent],
```

3. Add to re-exports:
```typescript
export {
  // ... existing exports ...
  MultiSelectDropdownRenderer,
  ComboBoxRenderer,
  MenuButtonRenderer,
  // ...
}
```
  </action>
  <verify>grep -c "multiselectdropdown\|combobox\|menubutton" src/components/elements/renderers/index.ts shows 6+ matches</verify>
  <done>MultiSelectDropdown, ComboBox, and MenuButton renderers registered in rendererRegistry</done>
</task>

</tasks>

<verification>
1. `grep "MultiSelectDropdownElementConfig" src/types/elements/controls.ts` - Type exists
2. `grep "ComboBoxElementConfig" src/types/elements/controls.ts` - Type exists
3. `grep "MenuButtonElementConfig" src/types/elements/controls.ts` - Type exists
4. `ls src/components/elements/renderers/controls/MultiSelectDropdownRenderer.tsx` - File exists
5. `ls src/components/elements/renderers/controls/ComboBoxRenderer.tsx` - File exists
6. `ls src/components/elements/renderers/controls/MenuButtonRenderer.tsx` - File exists
7. `grep "opacity 100ms\|opacity 150ms" src/components/elements/renderers/controls/MultiSelectDropdownRenderer.tsx` - Fade animation present
8. TypeScript compilation: `npx tsc --noEmit`
</verification>

<success_criteria>
- MultiSelectDropdownElementConfig has maxSelections property for configurable limits
- ComboBoxElementConfig has placeholder and filtering support
- MenuButtonElementConfig has menuItems with divider support
- All renderers implement click-outside with useEffect + document.addEventListener
- All renderers implement keyboard navigation (ArrowUp/Down, Enter, Escape)
- All dropdowns have 100-150ms CSS fade animation per CONTEXT.md
- All renderers use transition: none for selection state changes
- Renderers registered in rendererRegistry
</success_criteria>

<output>
After completion, create `.planning/phases/24-navigation-selection/24-02-SUMMARY.md`
</output>
