---
phase: 56-button-switch-styling
plan: 05
type: execute
wave: 2
depends_on: ["56-01"]
files_modified:
  - src/components/elements/renderers/controls/SegmentButtonRenderer.tsx
  - src/components/Properties/SegmentButtonProperties.tsx
autonomous: true

must_haves:
  truths:
    - "Segment Button renders with segment SVG layers for multi-option selection"
    - "Selection highlight layer shows active segment"
    - "Style selector appears in Segment Button property panel"
  artifacts:
    - path: "src/components/elements/renderers/controls/SegmentButtonRenderer.tsx"
      provides: "StyledSegmentButtonRenderer with highlight layer"
      contains: "StyledSegmentButtonRenderer"
    - path: "src/components/Properties/SegmentButtonProperties.tsx"
      provides: "Style dropdown and color overrides"
      contains: "getStylesByCategory"
  key_links:
    - from: "SegmentButtonRenderer.tsx"
      to: "extractElementLayer"
      via: "import"
      pattern: "import.*extractElementLayer"
---

<objective>
Add SVG styling support to Segment Button with highlight layer for selection indication.

Purpose: Enable user-customizable segment button artwork with visual selection indicator.
Output: StyledSegmentButtonRenderer using highlight layer approach (decided in RESEARCH.md).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/56-button-switch-styling/56-CONTEXT.md
@.planning/phases/56-button-switch-styling/56-RESEARCH.md
@.planning/phases/56-button-switch-styling/56-01-SUMMARY.md
@src/components/elements/renderers/controls/SegmentButtonRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add StyledSegmentButtonRenderer with highlight layer</name>
  <files>src/components/elements/renderers/controls/SegmentButtonRenderer.tsx</files>
  <action>
The RESEARCH.md recommended highlight layer approach: base layer (all segments) + highlight layer (positioned per selected segment). This is simpler than per-segment state layers and scales to N segments.

1. Add imports at top:
```typescript
import { useMemo } from 'react'
import { SafeSVG } from '../../../SafeSVG'
import { extractElementLayer } from '../../../../services/elementLayers'
import { applyAllColorOverrides } from '../../../../services/knobLayers'
```

2. Rename current SegmentButtonRenderer to DefaultSegmentButtonRenderer (keep ALL existing code)

3. Create StyledSegmentButtonRenderer:
```typescript
function StyledSegmentButtonRenderer({ config }: SegmentButtonRendererProps) {
  const getElementStyle = useStore((state) => state.getElementStyle)
  const style = config.styleId ? getElementStyle(config.styleId) : undefined

  if (style && style.category !== 'button') {
    console.warn('SegmentButton requires button category style')
    return null
  }

  const { segmentCount, selectedIndices, orientation } = config
  const isHorizontal = orientation === 'horizontal'

  const svgContent = useMemo(() => {
    if (!style) return ''
    return applyAllColorOverrides(style.svgContent, style.layers, config.colorOverrides)
  }, [style, config.colorOverrides])

  const layers = useMemo(() => {
    if (!style || !svgContent) return null
    return {
      base: style.layers.base ? extractElementLayer(svgContent, style.layers.base) : null,
      highlight: style.layers.highlight ? extractElementLayer(svgContent, style.layers.highlight) : null,
    }
  }, [style, svgContent])

  if (!style) {
    return (
      <div style={{
        width: '100%', height: '100%',
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        background: '#374151', borderRadius: '4px',
        color: '#9CA3AF', fontSize: '12px', textAlign: 'center', padding: '8px',
      }}>
        Style not found
      </div>
    )
  }

  // Calculate segment size for highlight positioning
  const segmentWidth = isHorizontal ? config.width / segmentCount : config.width
  const segmentHeight = isHorizontal ? config.height : config.height / segmentCount

  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      {/* Base - all segments background */}
      {layers?.base && (
        <div style={{ position: 'absolute', inset: 0 }}>
          <SafeSVG content={layers.base} style={{ width: '100%', height: '100%' }} />
        </div>
      )}

      {/* Highlight layers - one per selected segment */}
      {layers?.highlight && selectedIndices.map((selectedIndex) => {
        // Calculate clip-path to show only the selected segment's portion
        // This positions the highlight layer over just the selected segment
        const clipPath = isHorizontal
          ? `inset(0 ${100 - ((selectedIndex + 1) / segmentCount) * 100}% 0 ${(selectedIndex / segmentCount) * 100}%)`
          : `inset(${(selectedIndex / segmentCount) * 100}% 0 ${100 - ((selectedIndex + 1) / segmentCount) * 100}% 0)`

        return (
          <div
            key={selectedIndex}
            style={{
              position: 'absolute', inset: 0,
              clipPath: clipPath,
              transition: 'none', // Instant selection change
            }}
          >
            <SafeSVG content={layers.highlight} style={{ width: '100%', height: '100%' }} />
          </div>
        )
      })}

      {/* Segment labels/icons - overlay text on each segment */}
      <div style={{
        position: 'absolute', inset: 0,
        display: 'flex',
        flexDirection: isHorizontal ? 'row' : 'column',
        pointerEvents: 'none',
      }}>
        {config.segments.slice(0, segmentCount).map((segment, index) => {
          const isSelected = selectedIndices.includes(index)
          return (
            <div
              key={index}
              style={{
                flex: 1,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '4px',
                fontSize: `${config.fontSize}px`,
                fontFamily: config.fontFamily,
                fontWeight: config.fontWeight,
                color: isSelected ? config.selectedTextColor : config.textColor,
              }}
            >
              {renderSegmentContentStyled(segment, isSelected, config)}
            </div>
          )
        })}
      </div>
    </div>
  )
}

/**
 * Render segment content for styled version (text only, icons use existing pattern)
 */
function renderSegmentContentStyled(
  segment: SegmentConfig,
  isSelected: boolean,
  config: SegmentButtonElementConfig
) {
  switch (segment.displayMode) {
    case 'text':
      return (
        <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
          {segment.text || ''}
        </span>
      )
    case 'icon':
    case 'icon-text':
      // For styled version, icons are still rendered via text overlays
      // The actual SVG styling is in base/highlight layers
      return (
        <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
          {segment.text || ''}
        </span>
      )
    default:
      return null
  }
}
```

4. Create delegating SegmentButtonRenderer:
```typescript
export function SegmentButtonRenderer({ config }: SegmentButtonRendererProps) {
  if (!config.styleId) {
    return <DefaultSegmentButtonRenderer config={config} />
  }
  return <StyledSegmentButtonRenderer config={config} />
}
```

NOTE: The highlight layer approach uses clip-path to show only the portion of the highlight corresponding to the selected segment. This means the highlight SVG should be a full-width version that gets clipped. If multi-select is enabled, multiple clipped highlight instances are rendered.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Dev server runs: `npm run dev`
- Segment Button renders on canvas
  </verify>
  <done>Segment Button supports SVG styling with highlight layer for selection indication</done>
</task>

<task type="auto">
  <name>Task 2: Add Style section to SegmentButtonProperties</name>
  <files>src/components/Properties/SegmentButtonProperties.tsx</files>
  <action>
Add Style section following the established pattern:

1. Add imports:
```typescript
import { useLicense } from '../../hooks/useLicense'
import { ButtonLayers } from '../../types/elementStyle'
```

2. Add state retrieval in component:
```typescript
const { isPro } = useLicense()
const getStylesByCategory = useStore((state) => state.getStylesByCategory)
const getElementStyle = useStore((state) => state.getElementStyle)
const buttonStyles = getStylesByCategory('button')
```

3. Add Style section at top of return (before existing sections):
```typescript
{/* Style Section */}
<PropertySection title="Style">
  <div>
    <label className="block text-xs text-gray-400 mb-1">SVG Style</label>
    <select
      value={element.styleId || ''}
      onChange={(e) => onUpdate({
        styleId: e.target.value || undefined,
        colorOverrides: e.target.value ? element.colorOverrides : undefined
      })}
      className="w-full bg-gray-700 border border-gray-600 text-white rounded px-2 py-1.5 text-sm"
      disabled={!isPro && buttonStyles.length > 0}
    >
      <option value="">Default (CSS)</option>
      {buttonStyles.map(style => (
        <option key={style.id} value={style.id}>{style.name}</option>
      ))}
    </select>
    {!isPro && buttonStyles.length > 0 && (
      <p className="text-xs text-amber-500 mt-1">Pro license required for SVG styles</p>
    )}
  </div>
</PropertySection>

{/* Color Overrides - only when SVG style selected */}
{isPro && element.styleId && (() => {
  const style = getElementStyle(element.styleId)
  if (!style || style.category !== 'button') return null

  const layerNames: Array<keyof ButtonLayers> = ['base', 'highlight']
  const existingLayers = layerNames.filter((layerName) => style.layers[layerName])

  if (existingLayers.length === 0) return null

  return (
    <PropertySection title="Color Overrides">
      {existingLayers.map((layerName) => (
        <ColorInput
          key={layerName}
          label={layerName.charAt(0).toUpperCase() + layerName.slice(1)}
          value={element.colorOverrides?.[layerName] || ''}
          onChange={(color) => {
            const newOverrides = { ...element.colorOverrides }
            if (color) {
              newOverrides[layerName] = color
            } else {
              delete newOverrides[layerName]
            }
            onUpdate({ colorOverrides: newOverrides })
          }}
        />
      ))}
      <button
        onClick={() => onUpdate({ colorOverrides: undefined })}
        className="w-full text-left text-sm text-red-400 hover:text-red-300 mt-1"
      >
        Reset to Original Colors
      </button>
    </PropertySection>
  )
})()}
```

Also ensure ColorInput is imported from the property components index.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Dev server runs: `npm run dev`
- Segment Button property panel shows Style dropdown
  </verify>
  <done>Segment Button property panel has style selector and color overrides</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Dev server starts: `npm run dev`
3. Place Segment Button on canvas, verify multi-segment behavior works
4. Check property panel shows "Style" section
5. Verify segment selection changes which portion of highlight is visible
</verification>

<success_criteria>
1. Segment Button renders with base + highlight SVG layers when style applied
2. Selection highlight clips to show only selected segment(s)
3. Multi-select mode works (multiple highlight clips rendered)
4. Segment Button still works with default CSS when no styleId set
5. Property panel shows SVG Style dropdown and color overrides
6. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/56-button-switch-styling/56-05-SUMMARY.md`
</output>
