---
phase: 09-enhancements-bugfixes
plan: 07
type: execute
wave: 2
depends_on: []
files_modified:
  - src/services/import/templateParser.ts
  - src/components/Import/TemplateImporter.tsx
  - src/components/Layout/LeftPanel.tsx
autonomous: true

must_haves:
  truths:
    - "User can import HTML/JS/CSS from existing JUCE WebView2 projects"
    - "Imported elements appear on canvas with correct positions"
  artifacts:
    - path: "src/services/import/templateParser.ts"
      provides: "HTML/CSS parser for JUCE templates"
      contains: "parseJUCETemplate"
    - path: "src/components/Import/TemplateImporter.tsx"
      provides: "Template import dialog UI"
      contains: "TemplateImporter"
  key_links:
    - from: "src/components/Import/TemplateImporter.tsx"
      to: "src/services/import/templateParser.ts"
      via: "parseJUCETemplate call"
      pattern: "parseJUCETemplate"
---

<objective>
Implement template import for loading existing JUCE WebView2 HTML/CSS/JS into the designer.

Purpose: FEAT-03 enables users to reverse-engineer existing designs and iterate on them visually.
Output: Template import dialog, HTML parser, element creation from parsed template.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-enhancements-bugfixes/09-RESEARCH.md

@src/types/elements.ts
@src/store/elementsSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template parser service</name>
  <files>src/services/import/templateParser.ts</files>
  <action>
Create a template parser that extracts element configurations from HTML/CSS.

Create `src/services/import/templateParser.ts`:
```typescript
/**
 * Parse JUCE WebView2 templates back into element configurations
 * Supports HTML exported by this tool (round-trip) and similar structured HTML
 */

import {
  ElementConfig,
  createKnob,
  createSlider,
  createButton,
  createLabel,
  createMeter,
  createImage,
} from '../../types/elements'

interface ParseOptions {
  html: string
  css?: string
  js?: string
}

interface ParseResult {
  elements: ElementConfig[]
  canvasWidth: number
  canvasHeight: number
  errors: string[]
}

/**
 * Extract style value from CSS text for a selector
 */
function extractStyle(css: string, selector: string): Record<string, string> {
  const styles: Record<string, string> = {}

  // Find the rule block for this selector
  const escapedSelector = selector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  const regex = new RegExp(`${escapedSelector}\\s*\\{([^}]*)\\}`, 'i')
  const match = css.match(regex)

  if (match && match[1]) {
    const rules = match[1].split(';')
    rules.forEach((rule) => {
      const [prop, value] = rule.split(':').map((s) => s.trim())
      if (prop && value) {
        // Convert kebab-case to camelCase
        const camelProp = prop.replace(/-([a-z])/g, (_, c) => c.toUpperCase())
        styles[camelProp] = value
      }
    })
  }

  return styles
}

/**
 * Parse numeric value from CSS (removes 'px', '%', etc.)
 */
function parseNumeric(value: string | undefined, fallback: number = 0): number {
  if (!value) return fallback
  const num = parseFloat(value)
  return isNaN(num) ? fallback : num
}

/**
 * Parse JUCE template HTML into element configurations
 */
export function parseJUCETemplate(options: ParseOptions): ParseResult {
  const { html, css = '' } = options
  const elements: ElementConfig[] = []
  const errors: string[] = []

  // Parse HTML
  const parser = new DOMParser()
  const doc = parser.parseFromString(html, 'text/html')

  // Find plugin container
  const container = doc.getElementById('plugin-container') || doc.body

  // Get canvas dimensions from container
  const containerStyle = extractStyle(css, '#plugin-container')
  const canvasWidth = parseNumeric(containerStyle.width, 800)
  const canvasHeight = parseNumeric(containerStyle.height, 600)

  // Find all elements with data-element-type or class-based detection
  const elementNodes = container.querySelectorAll('[data-element-type], .knob, .slider, .button, .label, .meter, .image')

  elementNodes.forEach((node, index) => {
    const el = node as HTMLElement

    // Determine element type
    const dataType = el.getAttribute('data-element-type')
    const classList = Array.from(el.classList)

    let type: ElementConfig['type'] | null = null
    if (dataType) {
      type = dataType as ElementConfig['type']
    } else if (classList.includes('knob')) {
      type = 'knob'
    } else if (classList.includes('slider')) {
      type = 'slider'
    } else if (classList.includes('button')) {
      type = 'button'
    } else if (classList.includes('label')) {
      type = 'label'
    } else if (classList.includes('meter')) {
      type = 'meter'
    } else if (classList.includes('image')) {
      type = 'image'
    }

    if (!type) {
      errors.push(`Could not determine type for element ${el.id || index}`)
      return
    }

    // Extract position from CSS or inline styles
    const selector = el.id ? `#${el.id}` : `.${classList[0]}`
    const cssStyle = extractStyle(css, selector)
    const inlineStyle = el.style

    const x = parseNumeric(inlineStyle.left || cssStyle.left, 0)
    const y = parseNumeric(inlineStyle.top || cssStyle.top, 0)
    const width = parseNumeric(inlineStyle.width || cssStyle.width, 60)
    const height = parseNumeric(inlineStyle.height || cssStyle.height, 60)

    // Get name from id or generate one
    const name = el.id || el.getAttribute('data-name') || `${type}-${index + 1}`

    // Get parameter ID if present
    const parameterId = el.getAttribute('data-parameter-id') || undefined

    // Create element based on type
    try {
      let element: ElementConfig

      switch (type) {
        case 'knob':
          element = createKnob({
            name,
            x,
            y,
            width,
            height,
            diameter: Math.min(width, height),
            parameterId,
          })
          break

        case 'slider':
          element = createSlider({
            name,
            x,
            y,
            width,
            height,
            orientation: height > width ? 'vertical' : 'horizontal',
            parameterId,
          })
          break

        case 'button':
          element = createButton({
            name,
            x,
            y,
            width,
            height,
            label: el.textContent?.trim() || 'Button',
            parameterId,
          })
          break

        case 'label':
          element = createLabel({
            name,
            x,
            y,
            width,
            height,
            text: el.textContent?.trim() || 'Label',
            fontSize: parseNumeric(cssStyle.fontSize, 14),
          })
          break

        case 'meter':
          element = createMeter({
            name,
            x,
            y,
            width,
            height,
            orientation: height > width ? 'vertical' : 'horizontal',
            parameterId,
          })
          break

        case 'image':
          const img = el.querySelector('img') as HTMLImageElement | null
          element = createImage({
            name,
            x,
            y,
            width,
            height,
            src: img?.src || '',
          })
          break

        default:
          errors.push(`Unknown element type: ${type}`)
          return
      }

      elements.push(element)
    } catch (err) {
      errors.push(`Failed to create ${type}: ${err}`)
    }
  })

  return {
    elements,
    canvasWidth,
    canvasHeight,
    errors,
  }
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check templateParser exports parseJUCETemplate function.
  </verify>
  <done>Template parser service that extracts elements from HTML/CSS exists.</done>
</task>

<task type="auto">
  <name>Task 2: Create template importer UI</name>
  <files>src/components/Import/TemplateImporter.tsx</files>
  <action>
Create the template import dialog component.

Create `src/components/Import/TemplateImporter.tsx`:
```typescript
import { useState, useCallback } from 'react'
import { useDropzone } from 'react-dropzone'
import { parseJUCETemplate } from '../../services/import/templateParser'
import { useStore } from '../../store'
import { ElementConfig } from '../../types/elements'

interface TemplateImporterProps {
  isOpen: boolean
  onClose: () => void
}

interface ParsedFiles {
  html?: string
  css?: string
  js?: string
}

export function TemplateImporter({ isOpen, onClose }: TemplateImporterProps) {
  const [files, setFiles] = useState<ParsedFiles>({})
  const [preview, setPreview] = useState<{
    elements: ElementConfig[]
    errors: string[]
    canvasWidth: number
    canvasHeight: number
  } | null>(null)
  const [importing, setImporting] = useState(false)

  const addElements = useStore((state) => state.addElement)
  const setCanvasDimensions = useStore((state) => state.setCanvasDimensions)
  const clearSelection = useStore((state) => state.clearSelection)

  const onDrop = useCallback((acceptedFiles: File[]) => {
    acceptedFiles.forEach((file) => {
      const reader = new FileReader()
      reader.onload = () => {
        const content = reader.result as string
        const ext = file.name.split('.').pop()?.toLowerCase()

        setFiles((prev) => {
          const updated = { ...prev }
          if (ext === 'html' || ext === 'htm') {
            updated.html = content
          } else if (ext === 'css') {
            updated.css = content
          } else if (ext === 'js') {
            updated.js = content
          }
          return updated
        })
      }
      reader.readAsText(file)
    })
  }, [])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'text/html': ['.html', '.htm'],
      'text/css': ['.css'],
      'text/javascript': ['.js'],
    },
  })

  const handleParse = useCallback(() => {
    if (!files.html) return

    const result = parseJUCETemplate({
      html: files.html,
      css: files.css,
      js: files.js,
    })

    setPreview(result)
  }, [files])

  const handleImport = useCallback(() => {
    if (!preview) return

    setImporting(true)

    // Update canvas size
    setCanvasDimensions(preview.canvasWidth, preview.canvasHeight)

    // Clear existing selection
    clearSelection()

    // Add each element
    preview.elements.forEach((element) => {
      addElements(element)
    })

    setImporting(false)
    setFiles({})
    setPreview(null)
    onClose()
  }, [preview, addElements, setCanvasDimensions, clearSelection, onClose])

  const handleReset = useCallback(() => {
    setFiles({})
    setPreview(null)
  }, [])

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-900 rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-hidden">
        <div className="p-4 border-b border-gray-700 flex justify-between items-center">
          <div>
            <h2 className="text-lg font-semibold text-white">Import Template</h2>
            <p className="text-sm text-gray-400">
              Import HTML/CSS/JS from existing JUCE WebView2 projects
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white text-xl"
          >
            x
          </button>
        </div>

        <div className="p-4 space-y-4 overflow-y-auto max-h-[60vh]">
          {/* File Drop Zone */}
          <div
            {...getRootProps()}
            className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors ${
              isDragActive
                ? 'border-blue-500 bg-blue-500/10'
                : 'border-gray-600 hover:border-gray-500'
            }`}
          >
            <input {...getInputProps()} />
            <p className="text-gray-300">
              {isDragActive
                ? 'Drop files here...'
                : 'Drag & drop HTML, CSS, and JS files here'}
            </p>
            <p className="text-sm text-gray-500 mt-1">or click to select files</p>
          </div>

          {/* Loaded Files */}
          <div className="flex gap-2">
            <span
              className={`px-2 py-1 rounded text-sm ${
                files.html ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-400'
              }`}
            >
              HTML {files.html ? '✓' : ''}
            </span>
            <span
              className={`px-2 py-1 rounded text-sm ${
                files.css ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-400'
              }`}
            >
              CSS {files.css ? '✓' : ''}
            </span>
            <span
              className={`px-2 py-1 rounded text-sm ${
                files.js ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-400'
              }`}
            >
              JS {files.js ? '✓' : ''}
            </span>
          </div>

          {/* Parse Button */}
          {files.html && !preview && (
            <button
              onClick={handleParse}
              className="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-500"
            >
              Parse Template
            </button>
          )}

          {/* Preview */}
          {preview && (
            <div className="space-y-3">
              <div className="bg-gray-800 rounded p-3">
                <h3 className="font-medium text-white mb-2">Parse Result</h3>
                <p className="text-sm text-gray-300">
                  Found {preview.elements.length} elements
                </p>
                <p className="text-sm text-gray-400">
                  Canvas: {preview.canvasWidth} x {preview.canvasHeight}
                </p>

                {preview.errors.length > 0 && (
                  <div className="mt-2">
                    <p className="text-sm text-amber-400">Warnings:</p>
                    <ul className="text-xs text-gray-400 list-disc list-inside">
                      {preview.errors.map((err, i) => (
                        <li key={i}>{err}</li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>

              <div className="bg-gray-800 rounded p-3 max-h-40 overflow-y-auto">
                <h4 className="text-sm font-medium text-gray-300 mb-2">Elements</h4>
                <ul className="space-y-1">
                  {preview.elements.map((el) => (
                    <li key={el.id} className="text-xs text-gray-400 flex justify-between">
                      <span>{el.name}</span>
                      <span className="text-gray-500">{el.type}</span>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          )}
        </div>

        <div className="p-4 border-t border-gray-700 flex justify-end gap-3">
          {preview ? (
            <>
              <button
                onClick={handleReset}
                className="px-4 py-2 text-gray-300 hover:text-white text-sm"
              >
                Reset
              </button>
              <button
                onClick={handleImport}
                disabled={importing || preview.elements.length === 0}
                className="px-4 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-500 disabled:opacity-50"
              >
                {importing ? 'Importing...' : `Import ${preview.elements.length} Elements`}
              </button>
            </>
          ) : (
            <button
              onClick={onClose}
              className="px-4 py-2 text-gray-300 hover:text-white text-sm"
            >
              Cancel
            </button>
          )}
        </div>
      </div>
    </div>
  )
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check TemplateImporter component exists with file drop zone and parse functionality.
  </verify>
  <done>Template importer dialog UI component exists.</done>
</task>

<task type="auto">
  <name>Task 3: Add import button to LeftPanel</name>
  <files>src/components/Layout/LeftPanel.tsx</files>
  <action>
Add an "Import Template" button to the left panel that opens the importer dialog.

Import the TemplateImporter:
```typescript
import { useState } from 'react'
import { TemplateImporter } from '../Import/TemplateImporter'
```

Add state for dialog:
```typescript
const [importerOpen, setImporterOpen] = useState(false)
```

Add import button at the bottom of the left panel (after the palette):
```typescript
<div className="p-3 border-t border-gray-700">
  <button
    onClick={() => setImporterOpen(true)}
    className="w-full py-2 px-3 bg-gray-700 text-gray-300 rounded text-sm hover:bg-gray-600 flex items-center justify-center gap-2"
  >
    <span>Import Template</span>
  </button>
</div>

<TemplateImporter
  isOpen={importerOpen}
  onClose={() => setImporterOpen(false)}
/>
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check LeftPanel has import button and TemplateImporter integration.
  </verify>
  <done>Import Template button added to left panel.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes successfully
2. Start app with `npm run dev`
3. Click "Import Template" button in left panel
4. Drop HTML file (and optionally CSS, JS files)
5. Click "Parse Template" - should show element count and preview
6. Click "Import X Elements" - elements should appear on canvas
7. Elements should have correct positions and types
</verification>

<success_criteria>
- FEAT-03: User can import HTML/CSS/JS from JUCE WebView2 templates
- Parser extracts elements from data-element-type or class-based detection
- Imported elements appear with correct positions on canvas
- Errors/warnings displayed for unparseable content
</success_criteria>

<output>
After completion, create `.planning/phases/09-enhancements-bugfixes/09-07-SUMMARY.md`
</output>
