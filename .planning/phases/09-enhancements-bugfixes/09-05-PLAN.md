---
phase: 09-enhancements-bugfixes
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/export/documentationGenerator.ts
  - src/services/export/knownIssues.ts
  - src/services/export/codeGenerator.ts
  - src/services/export/index.ts
autonomous: true

must_haves:
  truths:
    - "Export includes README with JUCE integration workflow"
    - "Export includes known bug workarounds for JUCE WebView2"
  artifacts:
    - path: "src/services/export/documentationGenerator.ts"
      provides: "README.md generation"
      contains: "JUCE WebView2"
    - path: "src/services/export/knownIssues.ts"
      provides: "Known issues and workarounds"
      contains: "webview"
  key_links:
    - from: "src/services/export/codeGenerator.ts"
      to: "src/services/export/documentationGenerator.ts"
      via: "generateDocumentation call"
      pattern: "generateDocumentation"
---

<objective>
Add JUCE WebView2 integration documentation and known issue workarounds to export bundle.

Purpose: FEAT-04 and FEAT-05 help users successfully integrate exported code into JUCE projects.
Output: README.md in export bundle with setup instructions, known issues, and loading solutions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-enhancements-bugfixes/09-RESEARCH.md

@src/services/export/codeGenerator.ts
@src/services/export/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create known issues reference</name>
  <files>src/services/export/knownIssues.ts</files>
  <action>
Create a file documenting known JUCE WebView2 issues and workarounds.

Create `src/services/export/knownIssues.ts`:
```typescript
/**
 * Known issues and workarounds for JUCE WebView2 integration
 * Based on common problems reported by plugin developers
 */

export interface KnownIssue {
  title: string
  symptom: string
  cause: string
  solution: string
  codeExample?: string
}

export const KNOWN_ISSUES: KnownIssue[] = [
  {
    title: 'White Flash on Load',
    symptom: 'Brief white flash when plugin window opens',
    cause: 'WebView2 renders before CSS loads',
    solution: 'Set initial background color in WebView options and use body background in CSS',
    codeExample: `// In your JUCE editor constructor:
juce::WebBrowserComponent::Options options;
options = options.withBackgroundColour(juce::Colour(0x1a, 0x1a, 0x1a));
webView.reset(new juce::WebBrowserComponent(options));`,
  },
  {
    title: 'Controls Not Responding',
    symptom: 'Knobs/sliders don\'t respond to mouse input',
    cause: 'JavaScript event handlers not connected to JUCE backend',
    solution: 'Ensure WebSliderRelay bindings are registered and parameter IDs match',
    codeExample: `// Verify parameter ID in your processor:
parameters.createAndAddParameter(..., "gain", ...);
// Must match data-parameter-id in HTML:
// <div class="knob" data-parameter-id="gain">`,
  },
  {
    title: 'Slow Initial Load',
    symptom: 'Plugin takes 1-2 seconds to show UI on first open',
    cause: 'WebView2 runtime initialization',
    solution: 'Pre-warm WebView2 in background, use loading indicator',
    codeExample: `// Show loading state in JUCE while WebView initializes:
void EditorComponent::paint(juce::Graphics& g) {
    if (!webViewReady) {
        g.fillAll(juce::Colour(0x1a, 0x1a, 0x1a));
        g.setColour(juce::Colours::white);
        g.drawText("Loading...", getLocalBounds(), juce::Justification::centred);
    }
}`,
  },
  {
    title: 'Parameter Values Not Syncing',
    symptom: 'Moving knob in UI doesn\'t change DSP parameter',
    cause: 'Missing or incorrect WebSliderRelay setup',
    solution: 'Register each control with WebSliderRelay using matching parameter ID',
    codeExample: `// In bindings.cpp, ensure relay is registered:
webSliderRelay->registerSlider("gain", [this](float value) {
    processor.getParameters().getParameter("gain")->setValueNotifyingHost(value);
});`,
  },
  {
    title: 'UI Freezes During Automation',
    symptom: 'UI becomes unresponsive when DAW sends automation',
    cause: 'Too many parameter update messages flooding WebView',
    solution: 'Throttle parameter updates to 30-60fps',
    codeExample: `// Throttle updates in your relay:
void sendParameterUpdate(const String& id, float value) {
    auto now = Time::getMillisecondCounter();
    if (now - lastUpdateTime[id] > 16) { // ~60fps
        webView->runJavaScript("updateParameter('" + id + "'," + String(value) + ")");
        lastUpdateTime[id] = now;
    }
}`,
  },
]

export function formatKnownIssuesMarkdown(): string {
  let md = '## Known Issues and Workarounds\n\n'

  KNOWN_ISSUES.forEach((issue, index) => {
    md += `### ${index + 1}. ${issue.title}\n\n`
    md += `**Symptom:** ${issue.symptom}\n\n`
    md += `**Cause:** ${issue.cause}\n\n`
    md += `**Solution:** ${issue.solution}\n\n`
    if (issue.codeExample) {
      md += '```cpp\n' + issue.codeExample + '\n```\n\n'
    }
  })

  return md
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check knownIssues.ts exports KNOWN_ISSUES and formatKnownIssuesMarkdown.
  </verify>
  <done>Known issues reference file with JUCE WebView2 workarounds exists.</done>
</task>

<task type="auto">
  <name>Task 2: Create documentation generator</name>
  <files>src/services/export/documentationGenerator.ts</files>
  <action>
Create a documentation generator that produces README.md for the export bundle.

Create `src/services/export/documentationGenerator.ts`:
```typescript
/**
 * Generate README documentation for JUCE WebView2 export bundle
 */

import { ElementConfig } from '../../types/elements'
import { formatKnownIssuesMarkdown } from './knownIssues'

interface DocumentationOptions {
  projectName: string
  elements: ElementConfig[]
  includeHtmlPreview: boolean
  includeJuceBundle: boolean
}

export function generateReadme(options: DocumentationOptions): string {
  const { projectName, elements, includeHtmlPreview, includeJuceBundle } = options

  const controlCount = {
    knobs: elements.filter(e => e.type === 'knob').length,
    sliders: elements.filter(e => e.type === 'slider').length,
    buttons: elements.filter(e => e.type === 'button').length,
    meters: elements.filter(e => e.type === 'meter').length,
    labels: elements.filter(e => e.type === 'label').length,
    images: elements.filter(e => e.type === 'image').length,
  }

  let readme = `# ${projectName} - WebView UI Export

Generated by VST3 WebView UI Designer

## Contents

This export bundle contains:

${includeHtmlPreview ? '- `index.html` - Main HTML structure\n- `styles.css` - Element styles and layout\n- `components.js` - UI component rendering\n- `bindings.js` - JUCE WebSliderRelay bindings\n' : ''}
${includeJuceBundle ? '- `bindings.cpp` - C++ boilerplate for JUCE integration\n' : ''}
- `README.md` - This documentation

## UI Summary

| Element Type | Count |
|-------------|-------|
| Knobs | ${controlCount.knobs} |
| Sliders | ${controlCount.sliders} |
| Buttons | ${controlCount.buttons} |
| Meters | ${controlCount.meters} |
| Labels | ${controlCount.labels} |
| Images | ${controlCount.images} |

## Integration Steps

### 1. Copy Files to Your JUCE Project

Copy the web files to your JUCE project's resource folder:

\`\`\`
YourPlugin/
├── Source/
│   ├── PluginProcessor.cpp
│   ├── PluginEditor.cpp
│   └── WebUI/           <- Create this folder
│       ├── index.html
│       ├── styles.css
│       ├── components.js
│       └── bindings.js
\`\`\`

### 2. Add WebView to Your Editor

In your PluginEditor.h:

\`\`\`cpp
#include <juce_gui_extra/juce_gui_extra.h>

class YourPluginEditor : public juce::AudioProcessorEditor
{
public:
    YourPluginEditor(YourPluginProcessor&);
    ~YourPluginEditor() override;

    void resized() override;

private:
    std::unique_ptr<juce::WebBrowserComponent> webView;
    YourPluginProcessor& processor;
};
\`\`\`

### 3. Initialize WebView

In your PluginEditor.cpp:

\`\`\`cpp
YourPluginEditor::YourPluginEditor(YourPluginProcessor& p)
    : AudioProcessorEditor(&p), processor(p)
{
    // Set editor size to match your design canvas
    setSize(800, 600);

    // Create WebView with dark background to prevent flash
    juce::WebBrowserComponent::Options options;
    options = options.withBackgroundColour(juce::Colour(0x1a, 0x1a, 0x1a));

    webView = std::make_unique<juce::WebBrowserComponent>(options);
    addAndMakeVisible(*webView);

    // Load the UI from resources
    auto resourceDir = juce::File::getSpecialLocation(
        juce::File::currentApplicationFile
    ).getChildFile("Contents/Resources/WebUI");

    webView->goToURL(resourceDir.getChildFile("index.html").getFullPathName());
}

void YourPluginEditor::resized()
{
    webView->setBounds(getLocalBounds());
}
\`\`\`

### 4. Connect Parameter Bindings

${includeJuceBundle ? 'See `bindings.cpp` for the C++ relay setup code.' : 'You\'ll need to implement WebSliderRelay bindings manually.'}

Each control with a \`data-parameter-id\` attribute needs a corresponding relay:

\`\`\`cpp
// For each knob/slider:
webSliderRelay->registerSlider("parameterName", [this](float value) {
    processor.getParameters().getParameter("parameterName")->setValueNotifyingHost(value);
});
\`\`\`

### 5. Build and Test

1. Add the WebUI folder to your JUCE project resources
2. Build your plugin
3. Load in a DAW and verify controls respond

## Parameter Mapping

The following elements have parameter bindings:

| Element | Parameter ID | Type |
|---------|--------------|------|
${elements
  .filter(e => e.parameterId)
  .map(e => `| ${e.name} | \`${e.parameterId}\` | ${e.type} |`)
  .join('\n') || '| (none) | - | - |'}

${formatKnownIssuesMarkdown()}

## Troubleshooting

### Controls don't respond
- Verify parameter IDs match between HTML and C++
- Check browser console for JavaScript errors
- Ensure WebSliderRelay is properly initialized

### UI doesn't appear
- Check file paths are correct
- Verify WebView2 runtime is installed (Windows)
- Check JUCE WebBrowserComponent is added and visible

### Visual glitches
- Set WebView background color to match your CSS
- Use \`font-display: swap\` for custom fonts
- Avoid complex CSS animations during parameter updates

---

*Generated by [VST3 WebView UI Designer](https://github.com/your-repo)*
`

  return readme
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check documentationGenerator.ts exports generateReadme function.
  </verify>
  <done>Documentation generator that produces README.md with integration workflow exists.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate documentation into code generator</name>
  <files>src/services/export/codeGenerator.ts, src/services/export/index.ts</files>
  <action>
Modify the code generator to include README.md in the export bundle.

In codeGenerator.ts, import the documentation generator:
```typescript
import { generateReadme } from './documentationGenerator'
```

In the `generateBundle` or equivalent function, add README generation:
```typescript
// After generating other files, add README
const readme = generateReadme({
  projectName: projectName || 'Plugin UI',
  elements,
  includeHtmlPreview: exportMode === 'html' || exportMode === 'juce',
  includeJuceBundle: exportMode === 'juce',
})

// Add to the files object that gets zipped:
files['README.md'] = readme
```

Update the index.ts to export the new modules:
```typescript
export * from './documentationGenerator'
export * from './knownIssues'
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Check that codeGenerator imports and uses generateReadme.
  </verify>
  <done>README.md is included in export bundle with integration docs and known issues.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes successfully
2. Start app with `npm run dev`
3. Create a design with several elements (knobs, sliders with parameter IDs)
4. Export as JUCE bundle
5. Extract the ZIP and verify README.md exists
6. README should contain:
   - File listing
   - UI summary (element counts)
   - Integration steps with code examples
   - Parameter mapping table
   - Known issues and workarounds
   - Troubleshooting section
</verification>

<success_criteria>
- FEAT-04: Export includes README with JUCE WebView2 integration workflow
- FEAT-05: README includes known bug workarounds and loading solutions
- Documentation is specific to the exported design (element counts, parameter IDs)
- Code examples are copy-pasteable into JUCE projects
</success_criteria>

<output>
After completion, create `.planning/phases/09-enhancements-bugfixes/09-05-SUMMARY.md`
</output>
