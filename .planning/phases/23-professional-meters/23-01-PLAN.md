---
phase: 23-professional-meters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/meterUtils.ts
  - src/components/elements/renderers/displays/meters/SegmentedMeter.tsx
  - src/components/elements/renderers/displays/meters/MeterScale.tsx
  - src/components/elements/renderers/displays/meters/PeakHoldIndicator.tsx
  - src/components/elements/renderers/displays/meters/index.ts
autonomous: true

must_haves:
  truths:
    - "Segmented meter component renders LED-style segments with 1px gaps"
    - "dB-to-segment mapping correctly converts dB values to segment indices"
    - "Color zones apply correct colors based on dB value"
    - "Peak hold indicator renders at correct position"
    - "Scale marks render with major/minor tick marks"
  artifacts:
    - path: "src/utils/meterUtils.ts"
      provides: "dB mapping, color zone, segment calculation utilities"
      exports: ["dbToNormalized", "normalizedToDb", "getSegmentColor", "calculateLitSegments"]
    - path: "src/components/elements/renderers/displays/meters/SegmentedMeter.tsx"
      provides: "Segmented meter rendering with LED-style segments"
      exports: ["SegmentedMeter"]
    - path: "src/components/elements/renderers/displays/meters/MeterScale.tsx"
      provides: "SVG scale marks for meters"
      exports: ["MeterScale"]
    - path: "src/components/elements/renderers/displays/meters/PeakHoldIndicator.tsx"
      provides: "Peak hold indicator overlay"
      exports: ["PeakHoldIndicator"]
  key_links:
    - from: "SegmentedMeter.tsx"
      to: "meterUtils.ts"
      via: "import utilities"
      pattern: "import.*from.*meterUtils"
    - from: "SegmentedMeter.tsx"
      to: "PeakHoldIndicator.tsx"
      via: "conditional render"
      pattern: "showPeakHold.*PeakHoldIndicator"
---

<objective>
Create shared infrastructure for professional meters including segmented rendering, scale marks, and peak hold indicators.

Purpose: All 24 professional meter types will use these shared components for consistent LED-style appearance with 1px gaps, configurable color zones, and SVG scale marks.

Output: Reusable meter utilities and React components that subsequent plans will compose into complete meter elements.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-professional-meters/23-CONTEXT.md
@.planning/phases/23-professional-meters/23-RESEARCH.md
@src/components/elements/renderers/displays/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meter utility functions</name>
  <files>src/utils/meterUtils.ts</files>
  <action>
Create meter utility functions for dB calculations and color zones:

```typescript
// dB to normalized (0-1) conversion
export function dbToNormalized(db: number, minDb: number, maxDb: number): number {
  return Math.max(0, Math.min(1, (db - minDb) / (maxDb - minDb)))
}

// Normalized to dB conversion
export function normalizedToDb(normalized: number, minDb: number, maxDb: number): number {
  return minDb + normalized * (maxDb - minDb)
}

// Color zone type
export interface ColorZone {
  startDb: number
  endDb: number
  color: string
}

// Default color zones (green < -18, yellow -18 to -6, red >= -6)
export const defaultColorZones: ColorZone[] = [
  { startDb: -Infinity, endDb: -18, color: '#10b981' }, // green
  { startDb: -18, endDb: -6, color: '#eab308' },        // yellow
  { startDb: -6, endDb: Infinity, color: '#ef4444' },   // red
]

// Get segment color based on dB value and color zones
export function getSegmentColor(
  segmentIndex: number,
  segmentCount: number,
  minDb: number,
  maxDb: number,
  colorZones: ColorZone[]
): string {
  const segmentDb = normalizedToDb(segmentIndex / segmentCount, minDb, maxDb)
  const zone = colorZones.find(z => segmentDb >= z.startDb && segmentDb < z.endDb)
  return zone?.color || '#333333'
}

// Calculate how many segments should be lit
export function calculateLitSegments(value: number, segmentCount: number): number {
  return Math.round(value * segmentCount)
}

// Generate tick positions for scale marks
export function generateTickPositions(
  minDb: number,
  maxDb: number,
  majorInterval: number = 6,
  minorInterval: number = 3
): { major: number[]; minor: number[] } {
  const major: number[] = []
  const minor: number[] = []

  for (let db = minDb; db <= maxDb; db += minorInterval) {
    const isMajor = (db - minDb) % majorInterval === 0 || db === minDb || db === maxDb
    if (isMajor) {
      major.push(db)
    } else {
      minor.push(db)
    }
  }

  return { major, minor }
}
```

Export all functions from the file.
  </action>
  <verify>File exists at src/utils/meterUtils.ts with all 6 exports</verify>
  <done>Meter utilities provide dB mapping, color zone lookup, segment calculation, and tick position generation</done>
</task>

<task type="auto">
  <name>Task 2: Create SegmentedMeter and PeakHoldIndicator components</name>
  <files>
    src/components/elements/renderers/displays/meters/SegmentedMeter.tsx
    src/components/elements/renderers/displays/meters/PeakHoldIndicator.tsx
    src/components/elements/renderers/displays/meters/index.ts
  </files>
  <action>
Create SegmentedMeter component that renders LED-style segments:

**SegmentedMeter.tsx:**
```typescript
import React from 'react'
import { getSegmentColor, calculateLitSegments, ColorZone } from '../../../../../utils/meterUtils'
import { PeakHoldIndicator } from './PeakHoldIndicator'

interface SegmentedMeterProps {
  value: number          // 0-1 normalized
  segmentCount: number   // Number of segments
  orientation: 'vertical' | 'horizontal'
  segmentGap: number     // Gap between segments in px (default 1)
  minDb: number
  maxDb: number
  colorZones: ColorZone[]
  showPeakHold?: boolean
  peakHoldPosition?: number // 0-1 normalized
  peakHoldStyle?: 'line' | 'bar'
  width: number
  height: number
}

export function SegmentedMeter({
  value,
  segmentCount,
  orientation,
  segmentGap = 1,
  minDb,
  maxDb,
  colorZones,
  showPeakHold = false,
  peakHoldPosition,
  peakHoldStyle = 'line',
  width,
  height,
}: SegmentedMeterProps) {
  const litSegments = calculateLitSegments(value, segmentCount)
  const isVertical = orientation === 'vertical'

  return (
    <div
      style={{
        position: 'relative',
        display: 'grid',
        gridTemplateColumns: isVertical ? '1fr' : `repeat(${segmentCount}, 1fr)`,
        gridTemplateRows: isVertical ? `repeat(${segmentCount}, 1fr)` : '1fr',
        gap: `${segmentGap}px`,
        width,
        height,
        backgroundColor: '#000000',
      }}
    >
      {Array.from({ length: segmentCount }, (_, i) => {
        // Vertical: fill from bottom (index 0 = top, so reverse for display)
        // Horizontal: fill from left
        const displayIndex = isVertical ? segmentCount - 1 - i : i
        const isLit = isVertical
          ? i >= segmentCount - litSegments
          : i < litSegments

        const color = getSegmentColor(displayIndex, segmentCount, minDb, maxDb, colorZones)

        return (
          <div
            key={i}
            style={{
              backgroundColor: isLit ? color : color,
              opacity: isLit ? 1 : 0.3, // Off segments at 30% brightness per Phase 22
              borderRadius: '1px',
              transition: 'none', // Instant per Phase 21 standard
            }}
          />
        )
      })}

      {showPeakHold && peakHoldPosition !== undefined && (
        <PeakHoldIndicator
          position={peakHoldPosition}
          orientation={orientation}
          style={peakHoldStyle}
          containerWidth={width}
          containerHeight={height}
          segmentCount={segmentCount}
          segmentGap={segmentGap}
        />
      )}
    </div>
  )
}
```

**PeakHoldIndicator.tsx:**
```typescript
import React from 'react'

interface PeakHoldIndicatorProps {
  position: number // 0-1 normalized
  orientation: 'vertical' | 'horizontal'
  style: 'line' | 'bar'
  containerWidth: number
  containerHeight: number
  segmentCount: number
  segmentGap: number
}

export function PeakHoldIndicator({
  position,
  orientation,
  style,
  containerWidth,
  containerHeight,
  segmentCount,
  segmentGap,
}: PeakHoldIndicatorProps) {
  const isVertical = orientation === 'vertical'

  // Calculate segment size accounting for gaps
  const totalGaps = (segmentCount - 1) * segmentGap
  const segmentSize = isVertical
    ? (containerHeight - totalGaps) / segmentCount
    : (containerWidth - totalGaps) / segmentCount

  // Convert position to pixel offset
  const segmentIndex = Math.round(position * (segmentCount - 1))
  const offset = segmentIndex * (segmentSize + segmentGap)

  const lineStyle: React.CSSProperties = {
    position: 'absolute',
    backgroundColor: '#ffffff',
    transition: 'none',
    ...(isVertical
      ? {
          left: 0,
          right: 0,
          bottom: offset,
          height: style === 'line' ? '2px' : `${segmentSize}px`,
        }
      : {
          top: 0,
          bottom: 0,
          left: offset,
          width: style === 'line' ? '2px' : `${segmentSize}px`,
        }),
  }

  return <div style={lineStyle} />
}
```

**index.ts:**
```typescript
export { SegmentedMeter } from './SegmentedMeter'
export { MeterScale } from './MeterScale'
export { PeakHoldIndicator } from './PeakHoldIndicator'
```

Create the meters directory and files.
  </action>
  <verify>Files exist in src/components/elements/renderers/displays/meters/ with correct exports</verify>
  <done>SegmentedMeter renders LED-style segments with 1px gaps, 30% off brightness, and optional peak hold indicator</done>
</task>

<task type="auto">
  <name>Task 3: Create MeterScale SVG component</name>
  <files>src/components/elements/renderers/displays/meters/MeterScale.tsx</files>
  <action>
Create MeterScale component that renders SVG tick marks and labels:

```typescript
import React from 'react'
import { generateTickPositions, dbToNormalized } from '../../../../../utils/meterUtils'

interface MeterScaleProps {
  minDb: number
  maxDb: number
  orientation: 'vertical' | 'horizontal'
  position: 'inside' | 'outside'
  showMajorTicks: boolean
  showMinorTicks: boolean
  width: number
  height: number
  majorInterval?: number
  minorInterval?: number
}

export function MeterScale({
  minDb,
  maxDb,
  orientation,
  position,
  showMajorTicks,
  showMinorTicks,
  width,
  height,
  majorInterval = 6,
  minorInterval = 3,
}: MeterScaleProps) {
  const { major, minor } = generateTickPositions(minDb, maxDb, majorInterval, minorInterval)
  const isVertical = orientation === 'vertical'
  const isInside = position === 'inside'

  // Scale dimensions based on position
  const scaleWidth = isVertical ? (isInside ? width : 30) : width
  const scaleHeight = isVertical ? height : (isInside ? height : 20)

  const renderTick = (db: number, isMajor: boolean) => {
    const normalized = dbToNormalized(db, minDb, maxDb)
    const tickLength = isMajor ? 8 : 4
    const strokeWidth = isMajor ? 2 : 1
    const color = isMajor ? '#ffffff' : '#999999'

    if (isVertical) {
      // Vertical: ticks go from bottom (0) to top (1)
      const y = height * (1 - normalized)
      const x1 = isInside ? 0 : scaleWidth - tickLength
      const x2 = isInside ? tickLength : scaleWidth

      return (
        <g key={db}>
          <line
            x1={x1}
            y1={y}
            x2={x2}
            y2={y}
            stroke={color}
            strokeWidth={strokeWidth}
          />
          {isMajor && (
            <text
              x={isInside ? tickLength + 4 : x1 - 4}
              y={y + 4}
              fill="#ffffff"
              fontSize={10}
              textAnchor={isInside ? 'start' : 'end'}
            >
              {db > 0 ? `+${db}` : db}
            </text>
          )}
        </g>
      )
    } else {
      // Horizontal: ticks go from left (0) to right (1)
      const x = width * normalized
      const y1 = isInside ? 0 : scaleHeight - tickLength
      const y2 = isInside ? tickLength : scaleHeight

      return (
        <g key={db}>
          <line
            x1={x}
            y1={y1}
            x2={x}
            y2={y2}
            stroke={color}
            strokeWidth={strokeWidth}
          />
          {isMajor && (
            <text
              x={x}
              y={isInside ? tickLength + 12 : y1 - 4}
              fill="#ffffff"
              fontSize={10}
              textAnchor="middle"
            >
              {db > 0 ? `+${db}` : db}
            </text>
          )}
        </g>
      )
    }
  }

  return (
    <svg
      width={scaleWidth}
      height={scaleHeight}
      style={{ overflow: 'visible' }}
    >
      {showMajorTicks && major.map(db => renderTick(db, true))}
      {showMinorTicks && minor.map(db => renderTick(db, false))}
    </svg>
  )
}
```
  </action>
  <verify>File exists at src/components/elements/renderers/displays/meters/MeterScale.tsx with MeterScale export</verify>
  <done>MeterScale renders SVG tick marks with major (8px, white) and minor (4px, gray) ticks, with dB labels on major ticks</done>
</task>

</tasks>

<verification>
1. `ls src/utils/meterUtils.ts` - File exists
2. `ls src/components/elements/renderers/displays/meters/` - All 4 files exist (SegmentedMeter.tsx, MeterScale.tsx, PeakHoldIndicator.tsx, index.ts)
3. `grep -l "export function dbToNormalized" src/utils/meterUtils.ts` - Utility exports present
4. `grep -l "export function SegmentedMeter" src/components/elements/renderers/displays/meters/SegmentedMeter.tsx` - Component exported
5. TypeScript compilation: `npx tsc --noEmit` (may have pre-existing errors, but no new errors from these files)
</verification>

<success_criteria>
- meterUtils.ts exports dbToNormalized, normalizedToDb, getSegmentColor, calculateLitSegments, generateTickPositions, ColorZone type, defaultColorZones
- SegmentedMeter renders CSS Grid with 1px gaps and 30% off-segment opacity
- PeakHoldIndicator positions correctly for both orientations
- MeterScale renders SVG with major/minor tick marks and dB labels
- All components use transition: none for instant feedback
</success_criteria>

<output>
After completion, create `.planning/phases/23-professional-meters/23-01-SUMMARY.md`
</output>
