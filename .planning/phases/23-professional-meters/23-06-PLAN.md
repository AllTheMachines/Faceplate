---
phase: 23-professional-meters
plan: 06
type: execute
wave: 3
depends_on: ["23-02", "23-03", "23-04"]
files_modified:
  - src/services/export/cssGenerator.ts
  - src/services/export/htmlGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Exported CSS includes meter segment styles with 1px gaps"
    - "Exported CSS includes color zone variables"
    - "Exported HTML renders meter structure with data attributes"
    - "Scale marks export as SVG with tick positions"
    - "Analysis meters (Correlation, Stereo Width) export with horizontal bar CSS"
  artifacts:
    - path: "src/services/export/cssGenerator.ts"
      provides: "CSS generation for all 24 meter types"
      contains: "rmsmetermo|correlationmeter|generateMeterCSS"
    - path: "src/services/export/htmlGenerator.ts"
      provides: "HTML generation for all 24 meter types"
      contains: "rmsmetermo|correlationmeter|generateMeterHTML"
  key_links:
    - from: "cssGenerator.ts"
      to: "displays.ts"
      via: "type imports"
      pattern: "import.*MeterElementConfig"
    - from: "htmlGenerator.ts"
      to: "displays.ts"
      via: "type imports"
      pattern: "import.*MeterElementConfig"
---

<objective>
Add export support (CSS and HTML generation) for all 24 professional meter element types.

Purpose: Exported JUCE bundles must include CSS for meter styling (segmented layout, color zones, peak hold) and HTML structure that the JUCE plugin can update with real audio values.

Output: CSS and HTML generators handle all 24 meter types with appropriate styles for segmented meters and horizontal bar meters.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-professional-meters/23-CONTEXT.md
@.planning/phases/23-professional-meters/23-02-SUMMARY.md
@.planning/phases/23-professional-meters/23-03-SUMMARY.md
@.planning/phases/23-professional-meters/23-04-SUMMARY.md
@src/services/export/cssGenerator.ts
@src/services/export/htmlGenerator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CSS generation for level meters</name>
  <files>src/services/export/cssGenerator.ts</files>
  <action>
Add CSS generation for level meters (RMS, VU, PPM, True Peak, LUFS, K-System) to cssGenerator.ts.

Add a helper function for generating segmented meter CSS:

```typescript
function generateSegmentedMeterCSS(
  element: BaseProfessionalMeterConfig,
  selector: string
): string {
  const isVertical = element.orientation === 'vertical'
  const { segmentCount, segmentGap, colorZones, minDb, maxDb } = element

  // Generate color zone CSS variables
  const zoneColors = colorZones.map((zone, i) =>
    `--meter-zone-${i}: ${zone.color};`
  ).join('\n  ')

  // Generate segment styles
  const gridTemplate = isVertical
    ? `grid-template-rows: repeat(${segmentCount}, 1fr);`
    : `grid-template-columns: repeat(${segmentCount}, 1fr);`

  return `
${selector} {
  display: grid;
  ${gridTemplate}
  gap: ${segmentGap}px;
  background-color: #000000;
  ${zoneColors}
}

${selector} .meter-segment {
  border-radius: 1px;
  transition: none;
}

${selector} .meter-segment.off {
  opacity: 0.3;
}

${selector} .meter-segment.on {
  opacity: 1;
}

${selector} .peak-hold {
  position: absolute;
  background-color: #ffffff;
  transition: none;
}
`
}
```

Add cases in the main CSS generation switch for all level meter types:

```typescript
case 'rmsmetermo':
case 'rmsmeterstereo':
case 'vumetermono':
case 'vumeterstereo':
case 'ppmtype1mono':
case 'ppmtype1stereo':
case 'ppmtype2mono':
case 'ppmtype2stereo':
case 'truepeakmetermono':
case 'truepeakmeterstereo':
case 'lufsmomomo':
case 'lufsmomostereo':
case 'lufsshortmono':
case 'lufsshortstereo':
case 'lufsintmono':
case 'lufsintstereo':
case 'k12metermono':
case 'k12meterstereo':
case 'k14metermono':
case 'k14meterstereo':
case 'k20metermono':
case 'k20meterstereo': {
  const config = element as BaseProfessionalMeterConfig
  return generateSegmentedMeterCSS(config, `#${element.id}`)
}
```

For stereo meters, add additional CSS for the stereo wrapper:

```typescript
// For stereo types, add wrapper styles
if (element.type.includes('stereo')) {
  css += `
#${element.id} .stereo-wrapper {
  display: flex;
  gap: 8px;
}

#${element.id} .channel-label {
  font-size: 10px;
  color: #999999;
  text-align: center;
}
`
}
```
  </action>
  <verify>grep "rmsmetermo\|generateSegmentedMeterCSS" src/services/export/cssGenerator.ts</verify>
  <done>CSS generation handles all 22 segmented level meter types with grid layout and color zones</done>
</task>

<task type="auto">
  <name>Task 2: Add CSS generation for analysis meters</name>
  <files>src/services/export/cssGenerator.ts</files>
  <action>
Add CSS generation for analysis meters (Correlation, Stereo Width) to cssGenerator.ts:

```typescript
function generateHorizontalBarMeterCSS(
  element: CorrelationMeterElementConfig | StereoWidthMeterElementConfig,
  selector: string
): string {
  const { barHeight, colorZones } = element

  // Generate color zone CSS variables
  const zoneColors = colorZones.map((zone, i) =>
    `--meter-zone-${i}: ${zone.color};`
  ).join('\n  ')

  return `
${selector} {
  display: flex;
  flex-direction: column;
  ${zoneColors}
}

${selector} .meter-track {
  width: 100%;
  height: ${barHeight}px;
  background-color: #333333;
  border-radius: 2px;
  position: relative;
}

${selector} .center-marker {
  position: absolute;
  left: 50%;
  top: 0;
  bottom: 0;
  width: 2px;
  background-color: #666666;
  transform: translateX(-50%);
}

${selector} .meter-indicator {
  position: absolute;
  top: 0;
  bottom: 0;
  border-radius: 2px;
  transition: none;
}

${selector} .meter-scale {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: #999999;
}

${selector} .meter-readout {
  text-align: center;
  font-size: 12px;
}
`
}

// Add to switch statement:
case 'correlationmeter': {
  const config = element as CorrelationMeterElementConfig
  return generateHorizontalBarMeterCSS(config, `#${element.id}`)
}

case 'stereowidthmeter': {
  const config = element as StereoWidthMeterElementConfig
  return generateHorizontalBarMeterCSS(config, `#${element.id}`)
}
```
  </action>
  <verify>grep "correlationmeter\|stereowidthmeter" src/services/export/cssGenerator.ts</verify>
  <done>CSS generation handles Correlation and Stereo Width meters with horizontal bar layout</done>
</task>

<task type="auto">
  <name>Task 3: Add HTML generation for all meter types</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Add HTML generation for all 24 meter types to htmlGenerator.ts.

Add helper function for level meters:

```typescript
function generateSegmentedMeterHTML(
  element: BaseProfessionalMeterConfig,
  isStereo: boolean
): string {
  const { segmentCount, orientation, showPeakHold, scalePosition, minDb, maxDb } = element
  const isVertical = orientation === 'vertical'

  // Generate segment HTML
  const segments = Array.from({ length: segmentCount }, (_, i) =>
    `<div class="meter-segment" data-segment="${i}"></div>`
  ).join('\n    ')

  const peakHold = showPeakHold
    ? `<div class="peak-hold" data-peak-hold></div>`
    : ''

  // Generate scale marks (simplified for export)
  const scale = scalePosition !== 'none' ? `
  <div class="meter-scale" data-min="${minDb}" data-max="${maxDb}">
    <span>${minDb}</span>
    <span>${maxDb > 0 ? '+' + maxDb : maxDb}</span>
  </div>` : ''

  if (isStereo) {
    const channelL = `
  <div class="meter-channel" data-channel="L">
    ${segments}
    ${peakHold}
  </div>`
    const channelR = `
  <div class="meter-channel" data-channel="R">
    ${segments}
    ${peakHold}
  </div>`

    return `
<div class="stereo-wrapper">
  ${scale}
  ${channelL}
  ${channelR}
  <div class="channel-labels">
    <span>L</span>
    <span>R</span>
  </div>
</div>`
  }

  return `
${scale}
<div class="meter-segments" data-orientation="${orientation}">
  ${segments}
  ${peakHold}
</div>`
}
```

Add helper for analysis meters:

```typescript
function generateHorizontalBarMeterHTML(
  element: CorrelationMeterElementConfig | StereoWidthMeterElementConfig
): string {
  const { showScale, scalePosition, showNumericReadout } = element
  const isCorrelation = element.type === 'correlationmeter'

  const scaleLabels = isCorrelation
    ? ['<span>-1</span>', '<span>0</span>', '<span>+1</span>']
    : ['<span>0%</span>', '<span>100%</span>', '<span>200%</span>']

  const scale = showScale
    ? `<div class="meter-scale" data-position="${scalePosition}">${scaleLabels.join('')}</div>`
    : ''

  const readout = showNumericReadout
    ? `<div class="meter-readout" data-readout></div>`
    : ''

  return `
${scalePosition === 'above' ? scale : ''}
<div class="meter-track">
  <div class="center-marker"></div>
  <div class="meter-indicator" data-indicator></div>
</div>
${scalePosition === 'below' ? scale : ''}
${readout}`
}
```

Add cases in the HTML generation switch:

```typescript
// Level meters (mono)
case 'rmsmetermo':
case 'vumetermono':
case 'ppmtype1mono':
case 'ppmtype2mono':
case 'truepeakmetermono':
case 'lufsmomomo':
case 'lufsshortmono':
case 'lufsintmono':
case 'k12metermono':
case 'k14metermono':
case 'k20metermono': {
  const config = element as BaseProfessionalMeterConfig
  return generateSegmentedMeterHTML(config, false)
}

// Level meters (stereo)
case 'rmsmeterstereo':
case 'vumeterstereo':
case 'ppmtype1stereo':
case 'ppmtype2stereo':
case 'truepeakmeterstereo':
case 'lufsmomostereo':
case 'lufsshortstereo':
case 'lufsintstereo':
case 'k12meterstereo':
case 'k14meterstereo':
case 'k20meterstereo': {
  const config = element as BaseProfessionalMeterConfig
  return generateSegmentedMeterHTML(config, true)
}

// Analysis meters
case 'correlationmeter':
case 'stereowidthmeter': {
  return generateHorizontalBarMeterHTML(element as CorrelationMeterElementConfig | StereoWidthMeterElementConfig)
}
```

Make sure to add data attributes that JUCE can use to update values:
- `data-segment` for individual segments
- `data-peak-hold` for peak indicator
- `data-channel="L|R"` for stereo channels
- `data-indicator` for bar meters
- `data-readout` for numeric displays
  </action>
  <verify>grep "rmsmetermo\|correlationmeter\|generateSegmentedMeterHTML" src/services/export/htmlGenerator.ts</verify>
  <done>HTML generation handles all 24 meter types with data attributes for JUCE integration</done>
</task>

</tasks>

<verification>
1. `grep -c "case 'rmsmetermo'" src/services/export/cssGenerator.ts` - CSS switch case exists
2. `grep -c "case 'correlationmeter'" src/services/export/cssGenerator.ts` - Analysis meter CSS case
3. `grep "generateSegmentedMeterHTML" src/services/export/htmlGenerator.ts` - Helper function exists
4. `grep "data-segment\|data-peak-hold" src/services/export/htmlGenerator.ts` - Data attributes present
5. TypeScript compilation: `npx tsc --noEmit`
</verification>

<success_criteria>
- CSS generator handles all 24 meter types
- Segmented meters export with CSS Grid layout, 1px gaps, and color zone variables
- Analysis meters export with horizontal bar CSS
- HTML generator produces structure with data attributes for JUCE binding
- Stereo meters include L/R channel wrappers
- Scale marks included when scalePosition is not 'none'
- Peak hold indicator HTML included when showPeakHold is true
</success_criteria>

<output>
After completion, create `.planning/phases/23-professional-meters/23-06-SUMMARY.md`
</output>
