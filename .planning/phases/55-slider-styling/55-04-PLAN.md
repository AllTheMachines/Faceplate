---
phase: 55-slider-styling
plan: 04
type: execute
wave: 2
depends_on: ["55-01"]
files_modified:
  - src/components/elements/renderers/controls/CrossfadeSliderRenderer.tsx
  - src/components/elements/renderers/controls/NotchedSliderRenderer.tsx
  - src/components/Properties/CrossfadeSliderProperties.tsx
  - src/components/Properties/NotchedSliderProperties.tsx
autonomous: true

must_haves:
  truths:
    - "Crossfade Slider renders with SVG layers when styleId is set"
    - "Notched Slider renders with SVG layers and programmatic tick marks"
    - "Tick marks are CSS-rendered overlays, NOT extracted from SVG"
    - "Both sliders render with CSS when styleId is not set"
    - "Style dropdowns appear in both properties panels"
  artifacts:
    - path: "src/components/elements/renderers/controls/CrossfadeSliderRenderer.tsx"
      provides: "StyledCrossfadeSliderRenderer"
      contains: "StyledCrossfadeSliderRenderer"
    - path: "src/components/elements/renderers/controls/NotchedSliderRenderer.tsx"
      provides: "StyledNotchedSliderRenderer with programmatic ticks"
      contains: "StyledNotchedSliderRenderer"
    - path: "src/components/Properties/CrossfadeSliderProperties.tsx"
      provides: "Style dropdown"
      contains: "getStylesByCategory"
    - path: "src/components/Properties/NotchedSliderProperties.tsx"
      provides: "Style dropdown"
      contains: "getStylesByCategory"
  key_links:
    - from: "src/components/elements/renderers/controls/NotchedSliderRenderer.tsx"
      to: "config.notchCount"
      via: "Programmatic tick generation"
      pattern: "notchCount"
---

<objective>
Add SVG styling support to Crossfade Slider and Notched Slider.

Purpose: These two sliders have similar complexity and can be handled together. Crossfade Slider is a horizontal-only slider with A/B labels. Notched Slider has programmatic tick marks generated from notchCount property (per CONTEXT.md decision - ticks are NOT SVG layers).

Output: Both sliders render with user-provided SVG layers when styleId is set. Notched Slider overlays CSS tick marks on top of SVG layers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/55-slider-styling/55-CONTEXT.md
@.planning/phases/55-slider-styling/55-RESEARCH.md
@.planning/phases/55-slider-styling/55-01-SUMMARY.md

# Key source files
@src/types/elements/controls.ts
@src/components/elements/renderers/controls/CrossfadeSliderRenderer.tsx
@src/components/elements/renderers/controls/NotchedSliderRenderer.tsx
@src/components/elements/renderers/controls/SliderRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add StyledCrossfadeSliderRenderer</name>
  <files>src/components/elements/renderers/controls/CrossfadeSliderRenderer.tsx</files>
  <action>
Follow the pattern from Plan 01's StyledSliderRenderer. Crossfade is horizontal-only with A/B labels.

1. Add imports at top:
```typescript
import { useMemo } from 'react'
import { useStore } from '../../../../store'
import { SafeSVG } from '../../../SafeSVG'
import { extractElementLayer } from '../../../../services/elementLayers'
import { applyAllColorOverrides } from '../../../../services/knobLayers'
```

2. Rename existing CrossfadeSliderRenderer to DefaultCrossfadeSliderRenderer (keep all existing code unchanged)

3. Create StyledCrossfadeSliderRenderer function:

```typescript
function StyledCrossfadeSliderRenderer({ config }: CrossfadeSliderRendererProps) {
  const getElementStyle = useStore((state) => state.getElementStyle)
  const style = config.styleId ? getElementStyle(config.styleId) : undefined

  // Category validation
  if (style && style.category !== 'linear') {
    console.warn('CrossfadeSlider requires linear category style')
    return null
  }

  // Calculate normalized value
  const range = config.max - config.min
  const normalizedValue = (config.value - config.min) / range

  // Memoize SVG content with color overrides
  const svgContent = useMemo(() => {
    if (!style) return ''
    return applyAllColorOverrides(style.svgContent, style.layers, config.colorOverrides)
  }, [style, config.colorOverrides])

  // Extract layers
  const layers = useMemo(() => {
    if (!style || !svgContent) return null
    return {
      track: style.layers.track ? extractElementLayer(svgContent, style.layers.track) : null,
      fill: style.layers.fill ? extractElementLayer(svgContent, style.layers.fill) : null,
      thumb: style.layers.thumb ? extractElementLayer(svgContent, style.layers.thumb) : null,
    }
  }, [style, svgContent])

  // Crossfade is horizontal only - thumb position
  const thumbPos = normalizedValue * (config.width - config.thumbWidth)

  // Fill from left to value
  const fillClipPath = `inset(0 ${(1 - normalizedValue) * 100}% 0 0)`

  if (!style) {
    return (
      <div style={{
        width: '100%', height: '100%',
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        background: '#374151', borderRadius: '4px',
        color: '#9CA3AF', fontSize: '12px', textAlign: 'center', padding: '8px',
      }}>
        Style not found
      </div>
    )
  }

  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      {/* A/B Labels - positioned outside the slider */}
      <span style={{
        position: 'absolute',
        left: 0,
        top: '50%',
        transform: 'translate(-100%, -50%)',
        paddingRight: '8px',
        fontSize: `${config.labelFontSize}px`,
        fontFamily: config.labelFontFamily,
        fontWeight: config.labelFontWeight,
        color: config.labelColor,
        userSelect: 'none',
      }}>
        {config.labelA}
      </span>
      <span style={{
        position: 'absolute',
        right: 0,
        top: '50%',
        transform: 'translate(100%, -50%)',
        paddingLeft: '8px',
        fontSize: `${config.labelFontSize}px`,
        fontFamily: config.labelFontFamily,
        fontWeight: config.labelFontWeight,
        color: config.labelColor,
        userSelect: 'none',
      }}>
        {config.labelB}
      </span>

      {/* Track - static background */}
      {layers?.track && (
        <div style={{ position: 'absolute', inset: 0 }}>
          <SafeSVG content={layers.track} style={{ width: '100%', height: '100%' }} />
        </div>
      )}

      {/* Fill - clipped from left to value */}
      {layers?.fill && (
        <div style={{
          position: 'absolute',
          inset: 0,
          clipPath: fillClipPath,
          transition: 'clip-path 0.05s ease-out',
        }}>
          <SafeSVG content={layers.fill} style={{ width: '100%', height: '100%' }} />
        </div>
      )}

      {/* Thumb */}
      {layers?.thumb && (
        <div style={{
          position: 'absolute',
          inset: 0,
          transform: `translateX(${thumbPos}px)`,
          transition: 'transform 0.05s ease-out',
        }}>
          <SafeSVG content={layers.thumb} style={{ width: '100%', height: '100%' }} />
        </div>
      )}
    </div>
  )
}
```

4. Create main export that delegates:
```typescript
export function CrossfadeSliderRenderer({ config }: CrossfadeSliderRendererProps) {
  if (!config.styleId) {
    return <DefaultCrossfadeSliderRenderer config={config} />
  }
  return <StyledCrossfadeSliderRenderer config={config} />
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>CrossfadeSliderRenderer renders with SVG layers when styleId is set</done>
</task>

<task type="auto">
  <name>Task 2: Add StyledNotchedSliderRenderer with programmatic ticks</name>
  <files>src/components/elements/renderers/controls/NotchedSliderRenderer.tsx</files>
  <action>
Follow the pattern from Plan 01's StyledSliderRenderer. Key difference: tick marks are CSS overlays, NOT SVG layers (per CONTEXT.md decision).

1. Add imports at top:
```typescript
import { useMemo } from 'react'
import { useStore } from '../../../../store'
import { SafeSVG } from '../../../SafeSVG'
import { extractElementLayer } from '../../../../services/elementLayers'
import { applyAllColorOverrides } from '../../../../services/knobLayers'
```

2. Rename existing NotchedSliderRenderer to DefaultNotchedSliderRenderer (keep all existing code unchanged)

3. Create StyledNotchedSliderRenderer function:

```typescript
function StyledNotchedSliderRenderer({ config }: NotchedSliderRendererProps) {
  const getElementStyle = useStore((state) => state.getElementStyle)
  const style = config.styleId ? getElementStyle(config.styleId) : undefined

  // Category validation
  if (style && style.category !== 'linear') {
    console.warn('NotchedSlider requires linear category style')
    return null
  }

  // Calculate normalized value
  const range = config.max - config.min
  const normalizedValue = (config.value - config.min) / range

  // Memoize SVG content with color overrides
  const svgContent = useMemo(() => {
    if (!style) return ''
    return applyAllColorOverrides(style.svgContent, style.layers, config.colorOverrides)
  }, [style, config.colorOverrides])

  // Extract layers
  const layers = useMemo(() => {
    if (!style || !svgContent) return null
    return {
      track: style.layers.track ? extractElementLayer(svgContent, style.layers.track) : null,
      fill: style.layers.fill ? extractElementLayer(svgContent, style.layers.fill) : null,
      thumb: style.layers.thumb ? extractElementLayer(svgContent, style.layers.thumb) : null,
    }
  }, [style, svgContent])

  const isVertical = config.orientation === 'vertical'

  // Thumb position
  const thumbPos = isVertical
    ? (1 - normalizedValue) * (config.height - config.thumbHeight)
    : normalizedValue * (config.width - config.thumbWidth)

  // Fill clip-path
  const fillClipPath = isVertical
    ? `inset(${(1 - normalizedValue) * 100}% 0 0 0)`
    : `inset(0 ${(1 - normalizedValue) * 100}% 0 0)`

  // Generate tick mark positions programmatically (NOT from SVG)
  const tickMarks = useMemo(() => {
    // Use notchPositions if provided, otherwise generate from notchCount
    if (config.notchPositions && config.notchPositions.length > 0) {
      return config.notchPositions
    }
    const marks: number[] = []
    for (let i = 0; i < config.notchCount; i++) {
      marks.push(i / (config.notchCount - 1))
    }
    return marks
  }, [config.notchCount, config.notchPositions])

  // Format value display
  const formattedValue = formatValue(
    normalizedValue,
    config.min,
    config.max,
    config.valueFormat,
    config.valueSuffix,
    config.valueDecimalPlaces
  )

  if (!style) {
    return (
      <div style={{
        width: '100%', height: '100%',
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        background: '#374151', borderRadius: '4px',
        color: '#9CA3AF', fontSize: '12px', textAlign: 'center', padding: '8px',
      }}>
        Style not found
      </div>
    )
  }

  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      {/* Label */}
      {config.showLabel && (
        <span style={getLabelStyle(config)}>
          {config.labelText}
        </span>
      )}

      {/* Value Display */}
      {config.showValue && (
        <span style={getValueStyle(config)}>
          {formattedValue}
        </span>
      )}

      {/* Track - static background */}
      {layers?.track && (
        <div style={{ position: 'absolute', inset: 0 }}>
          <SafeSVG content={layers.track} style={{ width: '100%', height: '100%' }} />
        </div>
      )}

      {/* Fill - clipped to value */}
      {layers?.fill && (
        <div style={{
          position: 'absolute',
          inset: 0,
          clipPath: fillClipPath,
          transition: 'clip-path 0.05s ease-out',
        }}>
          <SafeSVG content={layers.fill} style={{ width: '100%', height: '100%' }} />
        </div>
      )}

      {/* Thumb */}
      {layers?.thumb && (
        <div style={{
          position: 'absolute',
          inset: 0,
          transform: isVertical
            ? `translateY(${thumbPos}px)`
            : `translateX(${thumbPos}px)`,
          transition: 'transform 0.05s ease-out',
        }}>
          <SafeSVG content={layers.thumb} style={{ width: '100%', height: '100%' }} />
        </div>
      )}

      {/* Tick marks - CSS overlays, NOT from SVG */}
      {tickMarks.map((position, index) => {
        const tickStyle: React.CSSProperties = isVertical
          ? {
              position: 'absolute',
              bottom: `${position * 100}%`,
              left: '50%',
              transform: 'translate(-50%, 50%)',
              width: config.notchLength,
              height: 2,
              backgroundColor: config.notchColor,
              pointerEvents: 'none',
            }
          : {
              position: 'absolute',
              left: `${position * 100}%`,
              top: '50%',
              transform: 'translate(-50%, -50%)',
              width: 2,
              height: config.notchLength,
              backgroundColor: config.notchColor,
              pointerEvents: 'none',
            }

        return <div key={index} style={tickStyle} />
      })}

      {/* Notch labels (if enabled) */}
      {config.showNotchLabels && tickMarks.map((position, index) => {
        const labelValue = config.min + position * range
        const labelStyle: React.CSSProperties = isVertical
          ? {
              position: 'absolute',
              bottom: `${position * 100}%`,
              right: '100%',
              transform: 'translateY(50%)',
              marginRight: `${config.notchLength + 4}px`,
              fontSize: `${config.notchLabelFontSize}px`,
              color: config.notchColor,
              whiteSpace: 'nowrap',
              pointerEvents: 'none',
            }
          : {
              position: 'absolute',
              left: `${position * 100}%`,
              bottom: '100%',
              transform: 'translateX(-50%)',
              marginBottom: `${config.notchLength + 4}px`,
              fontSize: `${config.notchLabelFontSize}px`,
              color: config.notchColor,
              whiteSpace: 'nowrap',
              pointerEvents: 'none',
            }

        return (
          <span key={`label-${index}`} style={labelStyle}>
            {labelValue.toFixed(config.valueDecimalPlaces)}
          </span>
        )
      })}
    </div>
  )
}
```

Note: formatValue, getLabelStyle, getValueStyle should already exist in the file (copy from DefaultNotchedSliderRenderer if needed).

4. Create main export that delegates:
```typescript
export function NotchedSliderRenderer({ config }: NotchedSliderRendererProps) {
  if (!config.styleId) {
    return <DefaultNotchedSliderRenderer config={config} />
  }
  return <StyledNotchedSliderRenderer config={config} />
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>NotchedSliderRenderer renders with SVG layers and CSS tick marks when styleId is set</done>
</task>

<task type="auto">
  <name>Task 3: Add style controls to both properties panels</name>
  <files>
    src/components/Properties/CrossfadeSliderProperties.tsx
    src/components/Properties/NotchedSliderProperties.tsx
  </files>
  <action>
Add style dropdown and color overrides to both CrossfadeSliderProperties and NotchedSliderProperties.

For BOTH files, follow the exact pattern from SliderProperties (Plan 01 Task 3):

1. Add imports:
```typescript
import { useStore } from '../../store'
import { useLicense } from '../../hooks/useLicense'
import { ColorPicker } from './shared/ColorPicker'
```

2. Inside the properties function, add at the beginning:
```typescript
const { isPro } = useLicense()
const getStylesByCategory = useStore((state) => state.getStylesByCategory)
const linearStyles = getStylesByCategory('linear')
const currentStyle = config.styleId
  ? linearStyles.find(s => s.id === config.styleId)
  : undefined
```

3. Add style section at TOP of the properties panel:
```tsx
{/* Style Section */}
<div className="space-y-3">
  <h4 className="text-xs font-medium text-gray-400 uppercase tracking-wider">Style</h4>

  {/* Style Dropdown */}
  <div>
    <label className="block text-xs text-gray-400 mb-1">SVG Style</label>
    <select
      value={config.styleId || ''}
      onChange={(e) => updateElement(config.id, {
        styleId: e.target.value || undefined,
        colorOverrides: e.target.value ? config.colorOverrides : undefined
      })}
      className="w-full bg-gray-700 text-white text-sm rounded px-2 py-1.5 border border-gray-600"
      disabled={!isPro && linearStyles.length > 0}
    >
      <option value="">Default (CSS)</option>
      {linearStyles.map(style => (
        <option key={style.id} value={style.id}>{style.name}</option>
      ))}
    </select>
    {!isPro && linearStyles.length > 0 && (
      <p className="text-xs text-amber-500 mt-1">Pro license required for SVG styles</p>
    )}
  </div>

  {/* Color Overrides (only when style is selected) */}
  {currentStyle && isPro && (
    <div className="space-y-2">
      <label className="block text-xs text-gray-400">Color Overrides</label>
      {currentStyle.layers.thumb && (
        <ColorPicker
          label="Thumb"
          value={config.colorOverrides?.thumb || ''}
          onChange={(color) => updateElement(config.id, {
            colorOverrides: { ...config.colorOverrides, thumb: color || undefined }
          })}
        />
      )}
      {currentStyle.layers.track && (
        <ColorPicker
          label="Track"
          value={config.colorOverrides?.track || ''}
          onChange={(color) => updateElement(config.id, {
            colorOverrides: { ...config.colorOverrides, track: color || undefined }
          })}
        />
      )}
      {currentStyle.layers.fill && (
        <ColorPicker
          label="Fill"
          value={config.colorOverrides?.fill || ''}
          onChange={(color) => updateElement(config.id, {
            colorOverrides: { ...config.colorOverrides, fill: color || undefined }
          })}
        />
      )}
    </div>
  )}
</div>
```
  </action>
  <verify>Dev server runs without errors, style dropdowns visible in both properties panels</verify>
  <done>Both Crossfade and Notched Slider properties panels show style dropdown and color overrides</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Dev server starts: `npm run dev`
3. Add Crossfade Slider - renders with CSS by default, SVG when styleId set
4. Add Notched Slider - renders with CSS by default, SVG + CSS tick marks when styleId set
5. Style dropdowns work in both properties panels
</verification>

<success_criteria>
- Crossfade Slider renders with SVG layers when styleId is set
- Notched Slider renders with SVG layers and CSS tick marks when styleId is set
- Tick marks are programmatic (from notchCount), NOT from SVG layers
- CSS rendering unchanged for both when no styleId
- Style dropdowns and color overrides work in both properties panels
</success_criteria>

<output>
After completion, create `.planning/phases/55-slider-styling/55-04-SUMMARY.md`
</output>
