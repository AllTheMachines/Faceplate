---
phase: 17-interactive-svg-knobs
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/knobLayers.ts
autonomous: true

must_haves:
  truths:
    - "SVG layer detection finds elements by id/class naming conventions"
    - "Detected layers include indicator, track, arc, glow, shadow categories"
    - "Unmapped elements are tracked for user review"
    - "Layer extraction preserves viewBox for correct positioning"
    - "Color overrides can be applied to SVG content via attribute replacement"
  artifacts:
    - path: "src/services/knobLayers.ts"
      provides: "Utilities for SVG layer detection, extraction, and color override"
      exports: ["detectKnobLayers", "extractLayer", "applyColorOverride", "applyAllColorOverrides", "DetectedLayers"]
      min_lines: 100
  key_links:
    - from: "src/services/knobLayers.ts"
      to: "DOMParser (built-in)"
      via: "SVG parsing"
      pattern: "new DOMParser"
    - from: "src/services/knobLayers.ts"
      to: "XMLSerializer (built-in)"
      via: "SVG serialization"
      pattern: "new XMLSerializer"
---

<objective>
Create utilities for detecting, extracting, and modifying SVG layers in knob designs.

Purpose: Enable the layer mapping workflow and styled knob rendering by parsing SVG structure.
Output: Functions for layer detection (auto-detect by naming conventions), layer extraction (for independent transforms), and color override application.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-interactive-svg-knobs/17-RESEARCH.md
@src/services/svg.ts (existing SVG utilities pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knobLayers.ts with layer detection</name>
  <files>src/services/knobLayers.ts</files>
  <action>
Create new file `src/services/knobLayers.ts` with layer detection logic:

```typescript
/**
 * Knob SVG Layer Detection and Manipulation Utilities
 *
 * Parses SVG files to detect layers by naming conventions,
 * extracts individual layers for independent rendering,
 * and applies per-instance color overrides.
 */

import { KnobStyleLayers, ColorOverrides } from '../types/knobStyle'

// Result of auto-detection - lists all potential matches
export interface DetectedLayers {
  indicator: string[]  // Elements matching indicator/pointer/needle naming
  track: string[]      // Elements matching track/background/base naming
  arc: string[]        // Elements matching arc/progress/fill/value naming
  glow: string[]       // Elements matching glow/shine/highlight naming
  shadow: string[]     // Elements matching shadow/depth naming
  unmapped: string[]   // Elements with id/class that don't match conventions
}

/**
 * Detect layers in an SVG by naming conventions.
 * Returns arrays of potential matches for each layer role.
 * User confirms/adjusts mappings in the layer mapping dialog.
 */
export function detectKnobLayers(svgContent: string): DetectedLayers {
  const parser = new DOMParser()
  const doc = parser.parseFromString(svgContent, 'image/svg+xml')

  // Check for parsing errors
  const parserError = doc.querySelector('parsererror')
  if (parserError) {
    throw new Error('Invalid SVG file')
  }

  const detected: DetectedLayers = {
    indicator: [],
    track: [],
    arc: [],
    glow: [],
    shadow: [],
    unmapped: [],
  }

  // Query all elements (not just those with id/class - we want to find identifiable layers)
  const allElements = doc.querySelectorAll('*')

  allElements.forEach((el) => {
    // Skip SVG root, defs, and other non-visual elements
    const tagName = el.tagName.toLowerCase()
    if (['svg', 'defs', 'clippath', 'mask', 'lineargradient', 'radialgradient', 'pattern', 'filter'].includes(tagName)) {
      return
    }

    const id = el.getAttribute('id') || ''
    const classList = el.getAttribute('class')?.split(/\s+/) || []
    const identifier = id || classList[0]

    // Skip elements without id or class
    if (!identifier) return

    const searchText = [id, ...classList].join(' ').toLowerCase()

    // Match naming conventions with synonyms (case-insensitive)
    if (/indicator|pointer|needle|hand|knob-indicator/.test(searchText)) {
      detected.indicator.push(identifier)
    } else if (/track|background|bg|base|knob-track/.test(searchText)) {
      detected.track.push(identifier)
    } else if (/arc|progress|fill|value|knob-arc/.test(searchText)) {
      detected.arc.push(identifier)
    } else if (/glow|shine|highlight|knob-glow/.test(searchText)) {
      detected.glow.push(identifier)
    } else if (/shadow|depth|knob-shadow/.test(searchText)) {
      detected.shadow.push(identifier)
    } else {
      // Has identifier but doesn't match conventions
      detected.unmapped.push(identifier)
    }
  })

  return detected
}

/**
 * Extract a single layer from SVG, wrapped in new SVG with same viewBox.
 * Used for rendering layers independently (e.g., indicator rotates separately).
 */
export function extractLayer(svgContent: string, layerIdentifier: string): string {
  const parser = new DOMParser()
  const doc = parser.parseFromString(svgContent, 'image/svg+xml')

  // Find layer by id or class
  let layer = doc.querySelector(`#${CSS.escape(layerIdentifier)}`)
  if (!layer) {
    layer = doc.querySelector(`.${CSS.escape(layerIdentifier)}`)
  }

  if (!layer) {
    console.warn(`Layer not found: ${layerIdentifier}`)
    return ''
  }

  // Get original SVG's viewBox for correct coordinate system
  const originalSvg = doc.querySelector('svg')
  const viewBox = originalSvg?.getAttribute('viewBox') || '0 0 100 100'
  const width = originalSvg?.getAttribute('width')
  const height = originalSvg?.getAttribute('height')

  // Create new SVG wrapper with same viewBox
  const newSvg = doc.createElementNS('http://www.w3.org/2000/svg', 'svg')
  newSvg.setAttribute('viewBox', viewBox)
  newSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
  newSvg.setAttribute('width', '100%')
  newSvg.setAttribute('height', '100%')

  // Copy width/height if present (preserves aspect ratio info)
  if (width) newSvg.setAttribute('data-original-width', width)
  if (height) newSvg.setAttribute('data-original-height', height)

  // Clone layer (not move - preserve original structure)
  const clonedLayer = layer.cloneNode(true) as Element
  newSvg.appendChild(clonedLayer)

  // Serialize to string
  const serializer = new XMLSerializer()
  return serializer.serializeToString(newSvg)
}

/**
 * Apply color override to a specific layer in SVG content.
 * Replaces fill and stroke attributes (preserves 'none' values).
 */
export function applyColorOverride(
  svgContent: string,
  layerIdentifier: string,
  color: string
): string {
  const parser = new DOMParser()
  const doc = parser.parseFromString(svgContent, 'image/svg+xml')

  // Find layer by id or class
  let layer = doc.querySelector(`#${CSS.escape(layerIdentifier)}`)
  if (!layer) {
    layer = doc.querySelector(`.${CSS.escape(layerIdentifier)}`)
  }

  if (!layer) {
    console.warn(`Layer not found for color override: ${layerIdentifier}`)
    return svgContent
  }

  // Helper to apply color to an element
  const applyToElement = (el: Element) => {
    // Replace fill if present and not 'none'
    if (el.hasAttribute('fill') && el.getAttribute('fill') !== 'none') {
      el.setAttribute('fill', color)
    }
    // Replace stroke if present and not 'none'
    if (el.hasAttribute('stroke') && el.getAttribute('stroke') !== 'none') {
      el.setAttribute('stroke', color)
    }

    // Also check style attribute for inline styles
    const style = el.getAttribute('style')
    if (style) {
      const newStyle = style
        .replace(/fill:\s*(?!none)[^;]+/g, `fill: ${color}`)
        .replace(/stroke:\s*(?!none)[^;]+/g, `stroke: ${color}`)
      el.setAttribute('style', newStyle)
    }
  }

  // Apply to layer itself
  applyToElement(layer)

  // Apply to all children
  const children = layer.querySelectorAll('*')
  children.forEach((child) => applyToElement(child))

  // Serialize back to string
  const serializer = new XMLSerializer()
  return serializer.serializeToString(doc)
}

/**
 * Apply all color overrides to SVG content.
 * Convenience wrapper that applies multiple overrides sequentially.
 */
export function applyAllColorOverrides(
  svgContent: string,
  layers: KnobStyleLayers,
  overrides: ColorOverrides | undefined
): string {
  if (!overrides) return svgContent

  let result = svgContent

  if (overrides.indicator && layers.indicator) {
    result = applyColorOverride(result, layers.indicator, overrides.indicator)
  }
  if (overrides.track && layers.track) {
    result = applyColorOverride(result, layers.track, overrides.track)
  }
  if (overrides.arc && layers.arc) {
    result = applyColorOverride(result, layers.arc, overrides.arc)
  }
  if (overrides.glow && layers.glow) {
    result = applyColorOverride(result, layers.glow, overrides.glow)
  }
  if (overrides.shadow && layers.shadow) {
    result = applyColorOverride(result, layers.shadow, overrides.shadow)
  }

  return result
}

/**
 * Check if SVG has any detectable layers.
 * Used to determine if SVG is suitable for knob style import.
 */
export function hasDetectableLayers(svgContent: string): boolean {
  const detected = detectKnobLayers(svgContent)
  return (
    detected.indicator.length > 0 ||
    detected.track.length > 0 ||
    detected.arc.length > 0 ||
    detected.glow.length > 0 ||
    detected.shadow.length > 0
  )
}

/**
 * Get the first auto-detected layer for each role.
 * Returns suggested KnobStyleLayers for the confirmation dialog.
 */
export function getSuggestedLayers(detected: DetectedLayers): KnobStyleLayers {
  return {
    indicator: detected.indicator[0],  // May be undefined if no indicator detected
    track: detected.track[0],
    arc: detected.arc[0],
    glow: detected.glow[0],
    shadow: detected.shadow[0],
  }
}
```

This provides all the utilities needed for layer-based rendering and style creation.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors.</verify>
  <done>Layer detection, extraction, and color override utilities are implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for layer detection</name>
  <files>src/services/knobLayers.test.ts</files>
  <action>
Create unit tests for the knobLayers utilities:

```typescript
import { describe, it, expect } from 'vitest'
import {
  detectKnobLayers,
  extractLayer,
  applyColorOverride,
  applyAllColorOverrides,
  hasDetectableLayers,
  getSuggestedLayers,
} from './knobLayers'

// Sample SVG for testing
const sampleKnobSVG = `
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  <circle id="track" cx="50" cy="50" r="45" fill="#333" />
  <path id="arc" d="M 50 10 A 40 40 0 1 1 50 90" fill="none" stroke="#666" />
  <line id="indicator" x1="50" y1="50" x2="50" y2="15" stroke="#fff" />
  <circle class="glow" cx="50" cy="50" r="48" fill="none" stroke="rgba(255,255,255,0.3)" />
  <circle id="unmapped-element" cx="50" cy="50" r="5" fill="#ff0000" />
</svg>
`

const flatSVG = `
<svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
  <circle cx="25" cy="25" r="20" fill="blue" />
</svg>
`

describe('detectKnobLayers', () => {
  it('should detect layers by naming convention', () => {
    const detected = detectKnobLayers(sampleKnobSVG)

    expect(detected.indicator).toContain('indicator')
    expect(detected.track).toContain('track')
    expect(detected.arc).toContain('arc')
    expect(detected.glow).toContain('glow')
    expect(detected.unmapped).toContain('unmapped-element')
  })

  it('should return empty arrays for SVG without named layers', () => {
    const detected = detectKnobLayers(flatSVG)

    expect(detected.indicator).toHaveLength(0)
    expect(detected.track).toHaveLength(0)
    expect(detected.arc).toHaveLength(0)
    expect(detected.glow).toHaveLength(0)
    expect(detected.shadow).toHaveLength(0)
  })

  it('should throw on invalid SVG', () => {
    expect(() => detectKnobLayers('not valid xml')).toThrow('Invalid SVG file')
  })
})

describe('extractLayer', () => {
  it('should extract layer by id', () => {
    const extracted = extractLayer(sampleKnobSVG, 'indicator')

    expect(extracted).toContain('viewBox="0 0 100 100"')
    expect(extracted).toContain('id="indicator"')
    expect(extracted).not.toContain('id="track"')
  })

  it('should extract layer by class', () => {
    const extracted = extractLayer(sampleKnobSVG, 'glow')

    expect(extracted).toContain('class="glow"')
  })

  it('should return empty string for non-existent layer', () => {
    const extracted = extractLayer(sampleKnobSVG, 'nonexistent')
    expect(extracted).toBe('')
  })
})

describe('applyColorOverride', () => {
  it('should replace fill attribute', () => {
    const result = applyColorOverride(sampleKnobSVG, 'track', '#ff0000')
    expect(result).toContain('fill="#ff0000"')
  })

  it('should replace stroke attribute', () => {
    const result = applyColorOverride(sampleKnobSVG, 'indicator', '#00ff00')
    expect(result).toContain('stroke="#00ff00"')
  })

  it('should preserve fill="none"', () => {
    const result = applyColorOverride(sampleKnobSVG, 'arc', '#ff0000')
    expect(result).toContain('fill="none"')
    expect(result).toContain('stroke="#ff0000"')
  })

  it('should return original SVG if layer not found', () => {
    const result = applyColorOverride(sampleKnobSVG, 'nonexistent', '#ff0000')
    expect(result).toBe(sampleKnobSVG)
  })
})

describe('applyAllColorOverrides', () => {
  it('should apply multiple color overrides', () => {
    const layers = { indicator: 'indicator', track: 'track' }
    const overrides = { indicator: '#ff0000', track: '#00ff00' }

    const result = applyAllColorOverrides(sampleKnobSVG, layers, overrides)

    expect(result).toContain('stroke="#ff0000"') // indicator
    expect(result).toContain('fill="#00ff00"')   // track
  })

  it('should return original if no overrides', () => {
    const result = applyAllColorOverrides(sampleKnobSVG, {}, undefined)
    expect(result).toBe(sampleKnobSVG)
  })
})

describe('hasDetectableLayers', () => {
  it('should return true for SVG with named layers', () => {
    expect(hasDetectableLayers(sampleKnobSVG)).toBe(true)
  })

  it('should return false for flat SVG', () => {
    expect(hasDetectableLayers(flatSVG)).toBe(false)
  })
})

describe('getSuggestedLayers', () => {
  it('should return first detected element for each role', () => {
    const detected = detectKnobLayers(sampleKnobSVG)
    const suggested = getSuggestedLayers(detected)

    expect(suggested.indicator).toBe('indicator')
    expect(suggested.track).toBe('track')
    expect(suggested.arc).toBe('arc')
    expect(suggested.glow).toBe('glow')
    expect(suggested.shadow).toBeUndefined() // No shadow in sample
  })
})
```
  </action>
  <verify>Run `npm test -- src/services/knobLayers.test.ts` - all tests pass.</verify>
  <done>Unit tests cover layer detection, extraction, and color override functions</done>
</task>

</tasks>

<verification>
Run the following to verify all changes:
```bash
npx tsc --noEmit
npm test -- src/services/knobLayers.test.ts
```
</verification>

<success_criteria>
- [ ] detectKnobLayers correctly identifies layers by naming conventions
- [ ] extractLayer wraps layer in SVG with correct viewBox
- [ ] applyColorOverride replaces fill/stroke attributes
- [ ] applyAllColorOverrides handles undefined overrides gracefully
- [ ] All unit tests pass
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-interactive-svg-knobs/17-02-SUMMARY.md`
</output>
