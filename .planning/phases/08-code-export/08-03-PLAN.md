---
phase: 08-code-export
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/services/export/jsGenerator.ts
  - src/services/export/cppGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Generated JS uses window.__JUCE__.backend API correctly"
    - "Generated C++ includes WebSliderRelay/WebToggleButtonRelay declarations"
    - "Missing parameterId generates TODO comment instead of broken code"
    - "HTML preview mode includes mock JUCE backend"
  artifacts:
    - path: "src/services/export/jsGenerator.ts"
      provides: "JavaScript bindings and component logic"
      exports: ["generateBindingsJS", "generateComponentsJS", "generateMockJUCE"]
    - path: "src/services/export/cppGenerator.ts"
      provides: "C++ relay declarations and initialization"
      exports: ["generateCPP"]
  key_links:
    - from: "src/services/export/jsGenerator.ts"
      to: "src/services/export/utils.ts"
      via: "Uses toKebabCase and toCamelCase"
      pattern: "import.*toKebabCase.*toCamelCase.*from.*utils"
    - from: "src/services/export/cppGenerator.ts"
      to: "src/types/elements.ts"
      via: "Element type determines relay class"
      pattern: "WebSliderRelay|WebToggleButtonRelay"
---

<objective>
Create JavaScript and C++ code generators for JUCE WebView2 bindings.

Purpose: Generate the binding layer that connects UI elements to JUCE audio parameters - JavaScript for frontend binding events, C++ snippets for backend relay setup.
Output: jsGenerator.ts producing bindings.js and components.js content, cppGenerator.ts producing bindings.cpp snippets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-code-export/08-CONTEXT.md
@.planning/phases/08-code-export/08-RESEARCH.md
@src/types/elements.ts
@src/services/export/utils.ts (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JavaScript generators (bindings.js + components.js)</name>
  <files>src/services/export/jsGenerator.ts</files>
  <action>
Create `src/services/export/jsGenerator.ts` with JavaScript code generation:

1. **Types**
```typescript
import type { ElementConfig, KnobElementConfig, SliderElementConfig, ButtonElementConfig } from '../../types/elements'

export interface JSGeneratorOptions {
  isPreviewMode: boolean  // true = include mock, false = expect real JUCE
}
```

2. **generateBindingsJS(elements: ElementConfig[], options: JSGeneratorOptions): string**
   - Generate bindings.js content
   - Only include interactive elements (knob, slider, button)
   - For each interactive element, generate JUCE backend listener:

```javascript
// Knob/Slider pattern:
const ${varName}State = window.__JUCE__.backend.getSliderState('${id}');
${varName}State.valueChangedEvent.addListener(() => {
  const value = ${varName}State.getNormalisedValue();
  updateElementValue('${id}', value);
});

// Button pattern:
const ${varName}State = window.__JUCE__.backend.getToggleState('${id}');
${varName}State.addListener(() => {
  const pressed = ${varName}State.getToggleState();
  updateElementPressed('${id}', pressed);
});
```

   - Use toCamelCase(element.name) for variable names
   - Use toKebabCase(element.name) for element IDs

3. **generateComponentsJS(elements: ElementConfig[]): string**
   - Generate components.js with UI update functions
   - Functions needed:
     - `updateElementValue(id, value)` - update knob/slider/meter display
     - `updateElementPressed(id, pressed)` - update button pressed state
   - Include basic component initialization that sets up element references

4. **generateMockJUCE(): string**
   - Generate mock window.__JUCE__.backend for HTML preview mode
   - Mock implementation with local state:

```javascript
// Mock JUCE backend for standalone preview
window.__JUCE__ = window.__JUCE__ || {};
window.__JUCE__.backend = {
  getSliderState: (id) => {
    let value = 0.5;
    const listeners = [];
    return {
      getNormalisedValue: () => value,
      setNormalisedValue: (v) => { value = v; listeners.forEach(l => l()); },
      valueChangedEvent: { addListener: (fn) => listeners.push(fn) }
    };
  },
  getToggleState: (id) => {
    let toggled = false;
    const listeners = [];
    return {
      getToggleState: () => toggled,
      setToggleState: (v) => { toggled = v; listeners.forEach(l => l()); },
      addListener: (fn) => listeners.push(fn)
    };
  }
};
```

5. **Helper: isInteractiveElement(element: ElementConfig): boolean**
   - Return true for 'knob', 'slider', 'button'
   - Reuse or import from validators.ts

Import toKebabCase and toCamelCase from './utils'.
  </action>
  <verify>
Test generation with interactive elements:
- Knob generates getSliderState binding
- Button generates getToggleState binding
- Non-interactive elements (label, meter, image) don't generate bindings
- TypeScript compilation passes: `npx tsc --noEmit`
  </verify>
  <done>JavaScript generators produce bindings.js and components.js content</done>
</task>

<task type="auto">
  <name>Task 2: Create C++ generator</name>
  <files>src/services/export/cppGenerator.ts</files>
  <action>
Create `src/services/export/cppGenerator.ts` with C++ code snippet generation:

1. **Types**
```typescript
import type { ElementConfig } from '../../types/elements'
```

2. **generateCPP(elements: ElementConfig[]): string**
   - Generate bindings.cpp with copy-paste ready C++ snippets
   - Organized by destination (header declarations vs constructor initialization)
   - Only include interactive elements (knob, slider, button)

3. **Output structure:**
```cpp
// ============================================================================
// JUCE WebView2 Bindings
// Generated by VST3 WebView UI Designer
// ============================================================================

// ============================================================================
// Header Declarations (add to PluginEditor.h private section)
// ============================================================================

std::unique_ptr<juce::WebSliderRelay> ${varName}Relay;
std::unique_ptr<juce::WebSliderParameterAttachment> ${varName}Attachment;
// ... for each interactive element

// ============================================================================
// Constructor Initialization (add to PluginEditor constructor after webView setup)
// ============================================================================

// ${elementName} (${elementType})
${varName}Relay = std::make_unique<juce::WebSliderRelay>(*webView, "${id}");
${varName}Attachment = std::make_unique<juce::WebSliderParameterAttachment>(
    *processorRef.parameters.getParameter("${parameterId}"),
    *${varName}Relay,
    nullptr  // undoManager
);
```

4. **Relay types by element:**
   - knob, slider -> WebSliderRelay + WebSliderParameterAttachment
   - button -> WebToggleButtonRelay + WebToggleButtonParameterAttachment

5. **Handle missing parameterId:**
   - If element.parameterId is undefined or empty:
```cpp
// ${elementName} (${elementType})
${varName}Relay = std::make_unique<juce::WebSliderRelay>(*webView, "${id}");
// TODO: Set parameterId in designer for this element
// ${varName}Attachment = std::make_unique<juce::WebSliderParameterAttachment>(
//     *processorRef.parameters.getParameter("YOUR_PARAMETER_ID"),
//     *${varName}Relay,
//     nullptr
// );
```

6. **Use naming conventions:**
   - Variable name: toCamelCase(element.name) + "Relay"
   - Element ID: toKebabCase(element.name)

Import toKebabCase and toCamelCase from './utils'.
  </action>
  <verify>
Test generation with various elements:
- Knob with parameterId generates full attachment code
- Slider without parameterId generates TODO comment
- Button uses WebToggleButtonRelay instead of WebSliderRelay
- TypeScript compilation passes: `npx tsc --noEmit`
  </verify>
  <done>C++ generator produces organized snippets for header and constructor</done>
</task>

</tasks>

<verification>
1. `src/services/export/jsGenerator.ts` exports generateBindingsJS, generateComponentsJS, generateMockJUCE
2. `src/services/export/cppGenerator.ts` exports generateCPP
3. JS bindings use correct JUCE API (getSliderState for knobs/sliders, getToggleState for buttons)
4. C++ uses correct relay classes (WebSliderRelay vs WebToggleButtonRelay)
5. Missing parameterId generates TODO comment, not broken code
6. `npm run build` completes without errors
</verification>

<success_criteria>
- JavaScript bindings use window.__JUCE__.backend API correctly
- C++ snippets are organized by destination (header vs constructor)
- Knobs and sliders use WebSliderRelay, buttons use WebToggleButtonRelay
- Missing parameterId generates helpful TODO comment
- Mock JUCE backend allows HTML preview without real JUCE runtime
- Variable naming follows camelCase convention
- Element IDs follow kebab-case convention
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-export/08-03-SUMMARY.md`
</output>
