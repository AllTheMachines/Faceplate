---
phase: 08-code-export
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/services/export/htmlGenerator.ts
  - src/services/export/cssGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Generated HTML contains all elements with correct IDs and positioning"
    - "Generated CSS styles elements correctly with absolute positioning"
    - "Canvas dimensions are preserved in container"
    - "Elements are sorted by z-order (DOM order matches visual stacking)"
  artifacts:
    - path: "src/services/export/htmlGenerator.ts"
      provides: "HTML document generation from elements"
      exports: ["generateHTML", "generateElementHTML"]
    - path: "src/services/export/cssGenerator.ts"
      provides: "CSS stylesheet generation"
      exports: ["generateCSS", "generateElementCSS"]
  key_links:
    - from: "src/services/export/htmlGenerator.ts"
      to: "src/services/export/utils.ts"
      via: "Uses toKebabCase for ID generation"
      pattern: "import.*toKebabCase.*from.*utils"
    - from: "src/services/export/cssGenerator.ts"
      to: "src/types/elements.ts"
      via: "Type-specific CSS generation"
      pattern: "switch.*element\\.type"
---

<objective>
Create HTML and CSS code generators for export bundle.

Purpose: Generate the visual layer of the export - the HTML markup with correct element positioning and CSS styling that reproduces the canvas design.
Output: htmlGenerator.ts producing index.html content, cssGenerator.ts producing styles.css content.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-code-export/08-CONTEXT.md
@.planning/phases/08-code-export/08-RESEARCH.md
@src/types/elements.ts
@src/store/canvasSlice.ts
@src/services/export/utils.ts (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTML generator</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Create `src/services/export/htmlGenerator.ts` with HTML document generation:

1. **Types**
```typescript
import type { ElementConfig } from '../../types/elements'

export interface HTMLGeneratorOptions {
  canvasWidth: number
  canvasHeight: number
  backgroundColor: string
  isPreviewMode: boolean  // true = mock JUCE, false = real JUCE
}
```

2. **generateHTML(elements: ElementConfig[], options: HTMLGeneratorOptions): string**
   - Generate complete HTML document
   - Template structure:
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JUCE WebView UI</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="plugin-container">
    <!-- Elements here, sorted by z-order -->
  </div>
  <script src="components.js"></script>
  <script src="bindings.js"></script>
</body>
</html>
```
   - IMPORTANT: Sort elements by array index (earlier = lower z-order) before generating
   - Use toKebabCase(element.name) for all IDs

3. **generateElementHTML(element: ElementConfig): string**
   - Type-specific HTML generation using switch on element.type
   - All elements get: id, class, data-type attribute
   - **Knob**: `<div id="${id}" class="element knob-element" data-type="knob"></div>`
   - **Slider**: `<div id="${id}" class="element slider-element" data-type="slider" data-orientation="${orientation}"></div>`
   - **Button**: `<button id="${id}" class="element button-element" data-type="button" data-mode="${mode}">${escapeHTML(label)}</button>`
   - **Label**: `<span id="${id}" class="element label-element" data-type="label">${escapeHTML(text)}</span>`
   - **Meter**: `<div id="${id}" class="element meter-element" data-type="meter" data-orientation="${orientation}"></div>`
   - **Image**: `<img id="${id}" class="element image-element" data-type="image" src="${src}" alt="${escapeHTML(name)}" />`

4. **Inline styles vs CSS classes:**
   - Position (x, y, width, height, rotation) go in inline style
   - Type-specific visuals go in CSS file (cssGenerator)
   - Pattern: `style="position: absolute; left: ${x}px; top: ${y}px; width: ${width}px; height: ${height}px; transform: rotate(${rotation}deg);"`

Import toKebabCase and escapeHTML from './utils'.
  </action>
  <verify>
Test generation with a simple element array:
- generateHTML([knobElement], options) should produce valid HTML
- Element IDs should be kebab-case versions of names
- TypeScript compilation passes: `npx tsc --noEmit`
  </verify>
  <done>HTML generator produces complete document with all element types</done>
</task>

<task type="auto">
  <name>Task 2: Create CSS generator</name>
  <files>src/services/export/cssGenerator.ts</files>
  <action>
Create `src/services/export/cssGenerator.ts` with CSS stylesheet generation:

1. **Types**
```typescript
import type { ElementConfig } from '../../types/elements'

export interface CSSGeneratorOptions {
  canvasWidth: number
  canvasHeight: number
  backgroundColor: string
}
```

2. **generateCSS(elements: ElementConfig[], options: CSSGeneratorOptions): string**
   - Generate complete CSS file
   - Include:
     a. CSS reset (minimal: box-sizing, margin)
     b. Container styles (canvas dimensions, background)
     c. Base element styles (position: absolute)
     d. Type-specific styles for each element

3. **CSS Structure:**
```css
/* Reset */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Container */
#plugin-container {
  position: relative;
  width: ${canvasWidth}px;
  height: ${canvasHeight}px;
  background-color: ${backgroundColor};
  overflow: hidden;
}

/* Base element */
.element {
  position: absolute;
}

/* Element-specific styles */
#gain-knob {
  /* knob styles */
}
```

4. **generateElementCSS(element: ElementConfig): string**
   - Generate CSS rule for specific element
   - Selector: `#${toKebabCase(element.name)}`
   - **Knob**: SVG arc styles (track color, fill color, track width)
   - **Slider**: Track and thumb colors, orientation-specific layout
   - **Button**: Background, text color, border, border-radius
   - **Label**: Font family, size, weight, color, text-align
   - **Meter**: Background color, gradient colors (use CSS custom properties for stops)
   - **Image**: object-fit property

5. **Handle element-specific colors:**
   - Knob: trackColor, fillColor, indicatorColor
   - Slider: trackColor, trackFillColor, thumbColor
   - Button: backgroundColor, textColor, borderColor
   - Label: color
   - Meter: backgroundColor, colorStops (as CSS gradient)
   - Image: none (just fit)

Import toKebabCase from './utils'.
  </action>
  <verify>
Test generation produces valid CSS:
- Container has correct dimensions
- Each element has its own rule with ID selector
- Colors are properly applied
- TypeScript compilation passes: `npx tsc --noEmit`
  </verify>
  <done>CSS generator produces complete stylesheet with type-specific styling</done>
</task>

</tasks>

<verification>
1. `src/services/export/htmlGenerator.ts` exports generateHTML and generateElementHTML
2. `src/services/export/cssGenerator.ts` exports generateCSS and generateElementCSS
3. HTML output includes proper DOCTYPE, charset, script/link tags
4. CSS output includes reset, container, and element-specific rules
5. Element IDs use kebab-case conversion
6. `npm run build` completes without errors
</verification>

<success_criteria>
- HTML generator produces valid HTML5 document structure
- All 6 element types have HTML generation support
- CSS generator produces valid stylesheet with proper selectors
- Element positioning (x, y, width, height, rotation) is preserved
- Canvas dimensions and background color are preserved in container
- Z-order is respected (DOM order matches visual stacking)
</success_criteria>

<output>
After completion, create `.planning/phases/08-code-export/08-02-SUMMARY.md`
</output>
