---
phase: 27-containers-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements/containers.ts
  - src/components/elements/renderers/containers/HorizontalSpacerRenderer.tsx
  - src/components/elements/renderers/containers/VerticalSpacerRenderer.tsx
  - src/components/elements/renderers/containers/index.ts
  - src/components/elements/renderers/index.ts
  - src/components/Properties/SpacerProperties.tsx
  - src/components/Properties/index.ts
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Horizontal Spacer appears in palette under Containers category"
    - "Vertical Spacer appears in palette under Containers category"
    - "Spacers can be set to fixed or flexible mode"
    - "Spacers show dashed outline in designer for visibility"
    - "Spacers display their sizing mode as label in designer"
  artifacts:
    - path: "src/types/elements/containers.ts"
      provides: "HorizontalSpacerElementConfig, VerticalSpacerElementConfig interfaces"
      contains: "interface HorizontalSpacerElementConfig"
    - path: "src/components/elements/renderers/containers/HorizontalSpacerRenderer.tsx"
      provides: "Horizontal spacer with visual indicator"
      min_lines: 30
    - path: "src/components/elements/renderers/containers/VerticalSpacerRenderer.tsx"
      provides: "Vertical spacer with visual indicator"
      min_lines: 30
    - path: "src/components/Properties/SpacerProperties.tsx"
      provides: "Shared property panel for both spacer types"
      min_lines: 80
  key_links:
    - from: "src/components/elements/renderers/index.ts"
      to: "HorizontalSpacerRenderer"
      via: "rendererRegistry entry"
      pattern: "horizontalspacer.*HorizontalSpacerRenderer"
    - from: "src/components/Properties/index.ts"
      to: "SpacerProperties"
      via: "propertyRegistry entry"
      pattern: "horizontalspacer.*SpacerProperties"
---

<objective>
Create Horizontal and Vertical Spacer elements with fixed/flexible sizing modes

Purpose: Enable users to add invisible layout spacers for precise UI spacing (CONT-02)
Output: Two spacer element types with shared property panel, renderers showing visual indicators in designer
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/27-containers-polish/27-CONTEXT.md
@.planning/phases/27-containers-polish/27-RESEARCH.md
@src/types/elements/containers.ts
@src/components/elements/renderers/index.ts
@src/components/Properties/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Spacer types and factory functions</name>
  <files>src/types/elements/containers.ts</files>
  <action>
Add HorizontalSpacerElementConfig and VerticalSpacerElementConfig interfaces to src/types/elements/containers.ts:

```typescript
export interface HorizontalSpacerElementConfig extends BaseElementConfig {
  type: 'horizontalspacer'
  mode: 'fixed' | 'flexible'

  // Fixed mode - uses width directly
  // Flexible mode - uses flex-grow in export
  flexGrow: number    // Used when mode === 'flexible' (default: 1)
  minWidth: number    // Minimum width constraint
  maxWidth: number    // Maximum width constraint
}

export interface VerticalSpacerElementConfig extends BaseElementConfig {
  type: 'verticalspacer'
  mode: 'fixed' | 'flexible'

  // Fixed mode - uses height directly
  // Flexible mode - uses flex-grow in export
  flexGrow: number    // Used when mode === 'flexible' (default: 1)
  minHeight: number   // Minimum height constraint
  maxHeight: number   // Maximum height constraint
}

export function isHorizontalSpacer(element: { type: string }): element is HorizontalSpacerElementConfig {
  return element.type === 'horizontalspacer'
}

export function isVerticalSpacer(element: { type: string }): element is VerticalSpacerElementConfig {
  return element.type === 'verticalspacer'
}

export function createHorizontalSpacer(overrides?: Partial<HorizontalSpacerElementConfig>): HorizontalSpacerElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'horizontalspacer',
    name: 'Horizontal Spacer',
    x: 0,
    y: 0,
    width: 40,
    height: 20,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    mode: 'flexible',
    flexGrow: 1,
    minWidth: 0,
    maxWidth: 9999,
    ...overrides,
  }
}

export function createVerticalSpacer(overrides?: Partial<VerticalSpacerElementConfig>): VerticalSpacerElementConfig {
  return {
    id: crypto.randomUUID(),
    type: 'verticalspacer',
    name: 'Vertical Spacer',
    x: 0,
    y: 0,
    width: 20,
    height: 40,
    rotation: 0,
    zIndex: 0,
    locked: false,
    visible: true,
    mode: 'flexible',
    flexGrow: 1,
    minHeight: 0,
    maxHeight: 9999,
    ...overrides,
  }
}
```

Update ContainerElement union to include both spacer types:
```typescript
export type ContainerElement =
  | PanelElementConfig
  | FrameElementConfig
  | GroupBoxElementConfig
  | CollapsibleContainerElementConfig
  | TooltipElementConfig
  | HorizontalSpacerElementConfig
  | VerticalSpacerElementConfig
```
  </action>
  <verify>npx tsc --noEmit passes and grep "interface HorizontalSpacerElementConfig" src/types/elements/containers.ts</verify>
  <done>HorizontalSpacerElementConfig and VerticalSpacerElementConfig interfaces with factory functions exist</done>
</task>

<task type="auto">
  <name>Task 2: Create Spacer renderers</name>
  <files>src/components/elements/renderers/containers/HorizontalSpacerRenderer.tsx, src/components/elements/renderers/containers/VerticalSpacerRenderer.tsx, src/components/elements/renderers/containers/index.ts, src/components/elements/renderers/index.ts</files>
  <action>
Create src/components/elements/renderers/containers/HorizontalSpacerRenderer.tsx:

```typescript
/**
 * Horizontal Spacer Renderer
 *
 * Shows dashed outline with shaded background in designer.
 * Displays sizing mode label for clarity.
 * Will be invisible in exported UI.
 */
import { Rect, Text, Group } from 'react-konva'
import type { HorizontalSpacerElementConfig } from '../../../../types/elements/containers'

interface HorizontalSpacerRendererProps {
  config: HorizontalSpacerElementConfig
}

export function HorizontalSpacerRenderer({ config }: HorizontalSpacerRendererProps) {
  // Generate label based on mode
  const label = config.mode === 'flexible'
    ? `flex: ${config.flexGrow}`
    : `${config.width}px`

  return (
    <Group>
      {/* Shaded background */}
      <Rect
        width={config.width}
        height={config.height}
        fill="rgba(148, 163, 184, 0.15)"
        stroke="rgba(100, 116, 139, 0.5)"
        strokeWidth={1}
        dash={[4, 4]}
      />

      {/* Sizing label */}
      <Text
        text={label}
        fontSize={9}
        fill="rgba(100, 116, 139, 0.8)"
        x={config.width / 2}
        y={config.height / 2}
        offsetX={label.length * 2.5}
        offsetY={5}
      />

      {/* Direction indicator (horizontal arrows) */}
      <Text
        text="\u2194"
        fontSize={12}
        fill="rgba(100, 116, 139, 0.6)"
        x={4}
        y={config.height / 2 - 6}
      />
    </Group>
  )
}
```

Create src/components/elements/renderers/containers/VerticalSpacerRenderer.tsx:

```typescript
/**
 * Vertical Spacer Renderer
 *
 * Shows dashed outline with shaded background in designer.
 * Displays sizing mode label for clarity.
 * Will be invisible in exported UI.
 */
import { Rect, Text, Group } from 'react-konva'
import type { VerticalSpacerElementConfig } from '../../../../types/elements/containers'

interface VerticalSpacerRendererProps {
  config: VerticalSpacerElementConfig
}

export function VerticalSpacerRenderer({ config }: VerticalSpacerRendererProps) {
  // Generate label based on mode
  const label = config.mode === 'flexible'
    ? `flex: ${config.flexGrow}`
    : `${config.height}px`

  return (
    <Group>
      {/* Shaded background */}
      <Rect
        width={config.width}
        height={config.height}
        fill="rgba(148, 163, 184, 0.15)"
        stroke="rgba(100, 116, 139, 0.5)"
        strokeWidth={1}
        dash={[4, 4]}
      />

      {/* Sizing label */}
      <Text
        text={label}
        fontSize={9}
        fill="rgba(100, 116, 139, 0.8)"
        x={config.width / 2}
        y={config.height / 2}
        offsetX={label.length * 2.5}
        offsetY={5}
        rotation={config.width < 30 ? 90 : 0}
      />

      {/* Direction indicator (vertical arrows) */}
      <Text
        text="\u2195"
        fontSize={12}
        fill="rgba(100, 116, 139, 0.6)"
        x={config.width / 2 - 5}
        y={4}
      />
    </Group>
  )
}
```

Update src/components/elements/renderers/containers/index.ts to export both renderers:
```typescript
export { HorizontalSpacerRenderer } from './HorizontalSpacerRenderer'
export { VerticalSpacerRenderer } from './VerticalSpacerRenderer'
```

Update src/components/elements/renderers/index.ts:
- Import both renderers from './containers'
- Add to rendererRegistry:
  ```typescript
  ['horizontalspacer', HorizontalSpacerRenderer as RendererComponent],
  ['verticalspacer', VerticalSpacerRenderer as RendererComponent],
  ```
- Add to export list
  </action>
  <verify>npx tsc --noEmit passes and grep "horizontalspacer.*HorizontalSpacerRenderer" src/components/elements/renderers/index.ts</verify>
  <done>Both spacer renderers show dashed outlines with sizing labels in designer</done>
</task>

<task type="auto">
  <name>Task 3: Create shared property panel and palette entries</name>
  <files>src/components/Properties/SpacerProperties.tsx, src/components/Properties/index.ts, src/App.tsx</files>
  <action>
Create src/components/Properties/SpacerProperties.tsx (shared by both spacer types):

```typescript
import type { HorizontalSpacerElementConfig, VerticalSpacerElementConfig } from '../../types/elements/containers'
import { PropertySection } from './PropertySection'
import { NumberInput } from './NumberInput'

type SpacerConfig = HorizontalSpacerElementConfig | VerticalSpacerElementConfig

interface SpacerPropertiesProps {
  element: SpacerConfig
  onUpdate: (updates: Partial<SpacerConfig>) => void
}

export function SpacerProperties({ element, onUpdate }: SpacerPropertiesProps) {
  const isHorizontal = element.type === 'horizontalspacer'
  const dimensionLabel = isHorizontal ? 'Width' : 'Height'
  const dimension = isHorizontal ? element.width : element.height
  const minDimension = isHorizontal
    ? (element as HorizontalSpacerElementConfig).minWidth
    : (element as VerticalSpacerElementConfig).minHeight
  const maxDimension = isHorizontal
    ? (element as HorizontalSpacerElementConfig).maxWidth
    : (element as VerticalSpacerElementConfig).maxHeight

  return (
    <>
      <PropertySection title="Sizing Mode">
        <div className="space-y-2">
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="radio"
              name="mode"
              checked={element.mode === 'fixed'}
              onChange={() => onUpdate({ mode: 'fixed' })}
              className="text-blue-500"
            />
            <span className="text-sm text-gray-300">Fixed {dimensionLabel}</span>
          </label>

          {element.mode === 'fixed' && (
            <div className="ml-6">
              <NumberInput
                label={`${dimensionLabel} (px)`}
                value={dimension}
                onChange={(value) => onUpdate(isHorizontal ? { width: value } : { height: value })}
                min={1}
                max={1000}
              />
            </div>
          )}

          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="radio"
              name="mode"
              checked={element.mode === 'flexible'}
              onChange={() => onUpdate({ mode: 'flexible' })}
              className="text-blue-500"
            />
            <span className="text-sm text-gray-300">Flexible (flex-grow)</span>
          </label>

          {element.mode === 'flexible' && (
            <div className="ml-6 space-y-2">
              <NumberInput
                label="Flex Grow"
                value={element.flexGrow}
                onChange={(flexGrow) => onUpdate({ flexGrow })}
                min={0}
                max={10}
                step={0.5}
              />
              <NumberInput
                label={`Min ${dimensionLabel}`}
                value={minDimension}
                onChange={(value) => onUpdate(
                  isHorizontal ? { minWidth: value } : { minHeight: value }
                )}
                min={0}
                max={500}
              />
              <NumberInput
                label={`Max ${dimensionLabel}`}
                value={maxDimension}
                onChange={(value) => onUpdate(
                  isHorizontal ? { maxWidth: value } : { maxHeight: value }
                )}
                min={0}
                max={9999}
              />
            </div>
          )}
        </div>
      </PropertySection>

      <PropertySection title="Designer Preview">
        <NumberInput
          label={isHorizontal ? 'Preview Height' : 'Preview Width'}
          value={isHorizontal ? element.height : element.width}
          onChange={(value) => onUpdate(isHorizontal ? { height: value } : { width: value })}
          min={10}
          max={200}
        />
        <p className="text-xs text-gray-500 mt-2">
          Spacers are shown with dashed outline in designer. They will be invisible in exported UI.
        </p>
      </PropertySection>
    </>
  )
}
```

Update src/components/Properties/index.ts:
- Import SpacerProperties
- Add both to propertyRegistry (same component for both types):
  ```typescript
  ['horizontalspacer', SpacerProperties],
  ['verticalspacer', SpacerProperties],
  ```
- Export SpacerProperties

Update src/App.tsx:
- Import createHorizontalSpacer, createVerticalSpacer from types/elements
- Add cases in handleDragEnd switch statement:
  ```typescript
  case 'horizontalspacer':
    newElement = createHorizontalSpacer({ x: canvasX, y: canvasY, ...variant })
    break
  case 'verticalspacer':
    newElement = createVerticalSpacer({ x: canvasX, y: canvasY, ...variant })
    break
  ```
  </action>
  <verify>
1. npx tsc --noEmit passes
2. grep "horizontalspacer.*SpacerProperties" src/components/Properties/index.ts
3. grep "case 'horizontalspacer'" src/App.tsx
4. grep "case 'verticalspacer'" src/App.tsx
  </verify>
  <done>Spacer property panel and palette entries enable fixed/flexible sizing configuration</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. HorizontalSpacerElementConfig and VerticalSpacerElementConfig interfaces exist
3. Both spacer renderers exist and export from containers/index.ts
4. rendererRegistry includes both spacer entries
5. propertyRegistry includes both spacer entries (using shared SpacerProperties)
6. App.tsx handles both spacers in drag-drop switch
7. `npm run dev` shows both spacers in palette (visual check)
8. Spacers display dashed outline with sizing mode label in designer
</verification>

<success_criteria>
- Horizontal Spacer element type is fully defined with fixed/flexible modes
- Vertical Spacer element type is fully defined with fixed/flexible modes
- Both renderers show dashed outline with shaded background in designer
- Sizing mode label displays (e.g., "flex: 1" or "40px")
- Property panel allows switching between fixed and flexible modes
- Flexible mode shows flex-grow, min, max constraints
- Both spacers can be dragged from palette to canvas
</success_criteria>

<output>
After completion, create `.planning/phases/27-containers-polish/27-02-SUMMARY.md`
</output>
