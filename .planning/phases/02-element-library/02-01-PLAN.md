---
phase: 02-element-library
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/elements.ts
  - src/store/canvasSlice.ts
  - src/store/elementsSlice.ts
  - src/store/index.ts
  - src/components/Canvas/CanvasStage.tsx
  - src/components/Canvas/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "Element type system supports 6 element types (knob, slider, button, label, meter, image)"
    - "Elements can be added, updated, and removed from the store"
    - "Canvas renders elements using HTML/CSS (visible in DevTools as div elements)"
    - "Pan and zoom continue to work on the HTML canvas container"
  artifacts:
    - path: "src/types/elements.ts"
      provides: "Element config interfaces with discriminated union"
      contains: "type ElementConfig ="
    - path: "src/store/elementsSlice.ts"
      provides: "Elements array state and CRUD actions"
      exports: ["createElementsSlice", "ElementsSlice"]
    - path: "src/components/Canvas/Canvas.tsx"
      provides: "HTML container with CSS transform for zoom/pan"
      contains: "transform:"
  key_links:
    - from: "src/store/elementsSlice.ts"
      to: "src/types/elements.ts"
      via: "imports ElementConfig type"
      pattern: "import.*ElementConfig.*from.*types/elements"
    - from: "src/components/Canvas/Canvas.tsx"
      to: "src/store/index.ts"
      via: "useStore hook for viewport state"
      pattern: "useStore.*scale|offset"
---

<objective>
Create element type system and refactor canvas from react-konva to HTML/CSS transforms.

Purpose: Establish foundation for element rendering with true WYSIWYG approach - elements render as HTML/SVG in designer exactly as they will export.

Output: Element type definitions, elements store slice, HTML-based canvas with CSS transform zoom/pan.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-element-library/02-CONTEXT.md
@.planning/phases/02-element-library/02-RESEARCH.md
@docs/SPECIFICATION.md

# Existing code to understand
@src/store/index.ts
@src/store/canvasSlice.ts
@src/store/viewportSlice.ts
@src/components/Canvas/CanvasStage.tsx
@src/components/Canvas/hooks/usePan.ts
@src/components/Canvas/hooks/useZoom.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create element type system with discriminated unions</name>
  <files>src/types/elements.ts</files>
  <action>
Create comprehensive element type definitions using TypeScript discriminated unions.

Define `BaseElementConfig` interface with common properties:
- id: string (UUID)
- name: string (user-friendly name, becomes ID in export)
- x, y: number (canvas coordinates)
- width, height: number
- rotation: number (degrees)
- zIndex: number
- locked: boolean
- visible: boolean
- parameterId?: string (for JUCE binding)

Define element-specific interfaces extending BaseElementConfig:
- `KnobElementConfig`: type='knob', diameter, value, min, max, startAngle (default -135), endAngle (default 135), trackColor, fillColor, indicatorColor, trackWidth, style ('arc'|'filled'|'dot'|'line')
- `SliderElementConfig`: type='slider', orientation ('vertical'|'horizontal'), value, min, max, trackColor, trackFillColor, thumbColor, thumbWidth, thumbHeight
- `ButtonElementConfig`: type='button', mode ('momentary'|'toggle'), label, pressed, backgroundColor, textColor, borderColor, borderRadius
- `LabelElementConfig`: type='label', text, fontSize, fontFamily, fontWeight, color, textAlign ('left'|'center'|'right')
- `MeterElementConfig`: type='meter', orientation, value, min, max, colorStops (array of {position, color}), backgroundColor, showPeakHold
- `ImageElementConfig`: type='image', src (base64 data URL or external URL), fit ('contain'|'cover'|'fill'|'none')

Create discriminated union type: `type ElementConfig = KnobElementConfig | SliderElementConfig | ButtonElementConfig | LabelElementConfig | MeterElementConfig | ImageElementConfig`

Add type guard functions:
- `isKnob(element: ElementConfig): element is KnobElementConfig`
- Similar for other types

Add factory functions for creating elements with defaults:
- `createKnob(overrides?: Partial<KnobElementConfig>): KnobElementConfig`
- Similar for other types

Use docs/SPECIFICATION.md as reference for property completeness, but prioritize essential v1 properties over exhaustive list.
  </action>
  <verify>
TypeScript compiles without errors: `npx tsc --noEmit`
Types are exported and can be imported in other files.
  </verify>
  <done>
Element type system exists with discriminated unions, type guards, and factory functions for all 6 element types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create elements store slice with CRUD operations</name>
  <files>src/store/elementsSlice.ts, src/store/index.ts</files>
  <action>
Create new elementsSlice.ts following existing slice pattern (canvasSlice, viewportSlice).

Define `ElementsSlice` interface:
- elements: ElementConfig[] (array of all elements)
- selectedIds: string[] (for future Phase 3 selection)
- addElement: (element: ElementConfig) => void
- removeElement: (id: string) => void
- updateElement: (id: string, updates: Partial<ElementConfig>) => void
- setElements: (elements: ElementConfig[]) => void
- getElement: (id: string) => ElementConfig | undefined (selector helper)

Implementation notes:
- Use Immer via produce() for immutable updates (already available via zundo)
- Generate UUIDs using crypto.randomUUID() for new elements
- Ensure type safety with discriminated union when updating elements
- Elements array should be included in undo history (do NOT exclude like viewport)

Update src/store/index.ts:
- Import and add createElementsSlice to combined store
- Update Store type to include ElementsSlice
- Elements state is already handled by temporal middleware for undo support
  </action>
  <verify>
TypeScript compiles without errors.
Store exports elements array and CRUD actions.
Test in browser console: useStore.getState().addElement(createKnob()) adds element to store.
  </verify>
  <done>
Elements slice exists with CRUD operations, integrated into main store, included in undo history.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor canvas from react-konva to HTML/CSS transforms</name>
  <files>src/components/Canvas/Canvas.tsx, src/components/Canvas/CanvasStage.tsx, src/components/Canvas/hooks/usePan.ts, src/components/Canvas/hooks/useZoom.ts</files>
  <action>
Create new Canvas.tsx that replaces Konva Stage with HTML container + CSS transforms.

Canvas.tsx structure:
```
<div className="canvas-viewport"> <!-- outer container, handles events -->
  <div className="canvas-container" style={{ transform }}> <!-- zoom/pan transform -->
    <div className="canvas-background"> <!-- canvas area with background -->
      {elements.map(el => <Element key={el.id} element={el} />)}
    </div>
  </div>
</div>
```

CSS transform must use correct order: `translate(${offsetX}px, ${offsetY}px) scale(${scale})`
- translate BEFORE scale is critical (per research)
- transformOrigin: '0 0'
- willChange: 'transform' for GPU acceleration

Adapt usePan.ts hook for HTML events:
- Listen on canvas-viewport div, not Konva Stage
- Use onMouseDown, onMouseMove, onMouseUp (or pointer events)
- Calculate delta in screen coordinates, apply to offset
- Maintain spacebar + drag pattern from Phase 1

Adapt useZoom.ts hook for HTML events:
- Use wheel event on canvas-viewport
- Calculate zoom centered on cursor position
- Use same two-step calculation from Phase 1 to keep cursor stationary

Preserve existing functionality:
- Zoom range: 0.1 to 10
- Pan with spacebar + drag
- Grab/grabbing cursor during pan
- Zoom indicator in bottom right

Update CanvasStage.tsx to use new Canvas.tsx OR replace it entirely.

Keep CanvasBackground logic for canvas background color/gradient - render as background-color or CSS gradient on canvas-background div.

DO NOT remove react-konva from package.json yet - it may be needed for fallback. Just don't use it in the new Canvas component.
  </action>
  <verify>
Run `npm run dev` and verify:
1. Canvas displays with gray background
2. Spacebar + drag pans the canvas
3. Scroll wheel zooms centered on cursor
4. Zoom indicator shows percentage
5. No Konva-related errors in console
  </verify>
  <done>
Canvas renders using HTML/CSS transforms instead of react-konva Stage. Pan and zoom work identically to Phase 1.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm run dev` - App runs without errors
3. Open browser devtools, verify no Konva Stage rendered (no canvas element from Konva)
4. Pan with spacebar + drag works
5. Zoom with scroll wheel works, cursor stays stationary
6. Console: `useStore.getState().elements` returns empty array
7. Console: `useStore.getState().addElement(...)` adds element (though not visible yet)
</verification>

<success_criteria>
- Element type system complete with 6 types, discriminated unions, type guards, factory functions
- Elements slice in store with CRUD operations
- Canvas renders via HTML/CSS instead of react-konva
- Pan and zoom maintain Phase 1 behavior
- No TypeScript errors
- App runs without console errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-element-library/02-01-SUMMARY.md`
</output>
