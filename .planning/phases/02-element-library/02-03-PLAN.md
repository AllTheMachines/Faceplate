---
phase: 02-element-library
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/components/elements/renderers/ButtonRenderer.tsx
  - src/components/elements/renderers/LabelRenderer.tsx
  - src/components/elements/renderers/MeterRenderer.tsx
  - src/components/elements/renderers/index.ts
  - src/components/elements/Element.tsx
autonomous: true

must_haves:
  truths:
    - "Button displays with label and correct pressed/unpressed state"
    - "Label displays text with configurable font properties"
    - "Meter displays gradient fill based on value"
  artifacts:
    - path: "src/components/elements/renderers/ButtonRenderer.tsx"
      provides: "Button with label and visual state"
      contains: "pressed"
    - path: "src/components/elements/renderers/LabelRenderer.tsx"
      provides: "Text label with styling"
      contains: "fontSize"
    - path: "src/components/elements/renderers/MeterRenderer.tsx"
      provides: "Level meter with gradient and value display"
      contains: "linearGradient"
  key_links:
    - from: "src/components/elements/Element.tsx"
      to: "src/components/elements/renderers/ButtonRenderer.tsx"
      via: "conditional render for button type"
      pattern: "case 'button'"
    - from: "src/components/elements/Element.tsx"
      to: "src/components/elements/renderers/MeterRenderer.tsx"
      via: "conditional render for meter type"
      pattern: "case 'meter'"
---

<objective>
Create interactive renderers for Button, Label, and Level Meter elements.

Purpose: Complete the simpler element types that don't require complex SVG path math - these use basic shapes, text, and gradients.

Output: ButtonRenderer with press states, LabelRenderer with text styling, MeterRenderer with gradient fills.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-element-library/02-CONTEXT.md
@.planning/phases/02-element-library/02-RESEARCH.md
@.planning/phases/02-element-library/02-02-SUMMARY.md

# Existing components
@src/types/elements.ts
@src/components/elements/BaseElement.tsx
@src/components/elements/Element.tsx
@src/components/elements/renderers/KnobRenderer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ButtonRenderer with press states</name>
  <files>src/components/elements/renderers/ButtonRenderer.tsx, src/components/elements/renderers/index.ts</files>
  <action>
Create ButtonRenderer.tsx for momentary and toggle buttons.

ButtonRenderer receives:
- config: ButtonElementConfig

Render as HTML div (not SVG) for better text handling:
```jsx
<div
  className="button-element"
  style={{
    width: '100%',
    height: '100%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: config.pressed ? darken(config.backgroundColor) : config.backgroundColor,
    color: config.textColor,
    borderRadius: config.borderRadius,
    border: `2px solid ${config.borderColor}`,
    fontSize: '14px',
    fontWeight: 500,
    userSelect: 'none',
    cursor: 'pointer',
    transition: 'background-color 0.1s',
    // Pressed state visual
    boxShadow: config.pressed
      ? 'inset 0 2px 4px rgba(0,0,0,0.3)'
      : '0 1px 2px rgba(0,0,0,0.2)',
    transform: config.pressed ? 'translateY(1px)' : 'none',
  }}
>
  {config.label}
</div>
```

Create helper function to darken color for pressed state:
```typescript
function darkenColor(hex: string, amount: number = 0.15): string {
  // Convert hex to RGB, multiply each by (1 - amount), convert back
  // Handle both #RGB and #RRGGBB formats
}
```

OR use CSS filter for simpler approach:
```css
filter: brightness(0.85); /* when pressed */
```

Default styling:
- backgroundColor: '#3b82f6' (blue-500)
- textColor: '#ffffff'
- borderColor: '#2563eb' (blue-600)
- borderRadius: 6
- label: 'Button'

For toggle mode, config.pressed represents current toggle state.
For momentary mode, config.pressed would be controlled by interaction (Phase 5).

Note: Click handling comes in Phase 5. For now, just render based on pressed boolean.

Update Element.tsx to add case for 'button'.
Update renderers/index.ts to export ButtonRenderer.
  </action>
  <verify>
Add test buttons via console:
```javascript
const store = useStore.getState();
const { createButton } = await import('./src/types/elements');
store.addElement(createButton({ x: 100, y: 300, label: 'Play', pressed: false }));
store.addElement(createButton({ x: 200, y: 300, label: 'Stop', pressed: true }));
```
Verify buttons display with correct labels, pressed button has visual difference.
  </verify>
  <done>
ButtonRenderer displays with label, respects pressed state with visual feedback (darker color, shadow inset).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LabelRenderer with text styling</name>
  <files>src/components/elements/renderers/LabelRenderer.tsx</files>
  <action>
Create LabelRenderer.tsx for text display elements.

LabelRenderer receives:
- config: LabelElementConfig

Render as HTML div with text styling:
```jsx
<div
  style={{
    width: '100%',
    height: '100%',
    display: 'flex',
    alignItems: config.textAlign === 'left' ? 'flex-start'
      : config.textAlign === 'right' ? 'flex-end'
      : 'center',
    justifyContent: 'center',
    flexDirection: 'column',
    fontSize: config.fontSize,
    fontFamily: config.fontFamily,
    fontWeight: config.fontWeight,
    color: config.color,
    textAlign: config.textAlign,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: config.text.includes('\n') ? 'pre-wrap' : 'nowrap',
    lineHeight: 1.2,
  }}
>
  {config.text}
</div>
```

Note: Use alignItems for horizontal alignment within flex container, but textAlign for actual text alignment.

Actually simpler approach - just use textAlign on a full-width div:
```jsx
<div
  style={{
    width: '100%',
    height: '100%',
    fontSize: config.fontSize,
    fontFamily: config.fontFamily,
    fontWeight: config.fontWeight,
    color: config.color,
    textAlign: config.textAlign,
    display: 'flex',
    alignItems: 'center',
    // Only justifyContent affects horizontal when text doesn't wrap
  }}
>
  <span style={{ width: '100%', textAlign: config.textAlign }}>
    {config.text}
  </span>
</div>
```

Default styling:
- fontSize: 14
- fontFamily: 'system-ui, -apple-system, sans-serif'
- fontWeight: 400 (normal)
- color: '#ffffff'
- textAlign: 'center'
- text: 'Label'

Handle multiline text: if text contains '\n', render with white-space: pre-wrap.

Update Element.tsx to add case for 'label'.
Update renderers/index.ts to export LabelRenderer.
  </action>
  <verify>
Add test labels via console:
```javascript
const store = useStore.getState();
const { createLabel } = await import('./src/types/elements');
store.addElement(createLabel({ x: 100, y: 400, text: 'Gain', fontSize: 16, fontWeight: 700 }));
store.addElement(createLabel({ x: 200, y: 400, text: 'Left aligned', textAlign: 'left', width: 150 }));
```
Verify labels display with correct styling and alignment.
  </verify>
  <done>
LabelRenderer displays text with configurable font, size, weight, color, and alignment.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create MeterRenderer with gradient fills</name>
  <files>src/components/elements/renderers/MeterRenderer.tsx</files>
  <action>
Create MeterRenderer.tsx following the pattern from 02-RESEARCH.md.

MeterRenderer receives:
- config: MeterElementConfig

Calculate fill based on value:
```typescript
const range = config.max - config.min;
const normalizedValue = (config.value - config.min) / range;
const clampedValue = Math.max(0, Math.min(1, normalizedValue));
```

Use SVG with linearGradient and stroke-dasharray technique:

For vertical meter:
```jsx
<svg width="100%" height="100%" viewBox={`0 0 ${config.width} ${config.height}`}>
  <defs>
    <linearGradient id={`meter-gradient-${config.id}`} x1="0" y1="1" x2="0" y2="0">
      {config.colorStops.map((stop, i) => (
        <stop key={i} offset={`${stop.position * 100}%`} stopColor={stop.color} />
      ))}
    </linearGradient>
  </defs>

  {/* Background */}
  <rect
    x={0}
    y={0}
    width={config.width}
    height={config.height}
    fill={config.backgroundColor}
    rx={2}
  />

  {/* Fill using clip or dash technique */}
  <rect
    x={1}
    y={config.height * (1 - clampedValue)}
    width={config.width - 2}
    height={config.height * clampedValue}
    fill={`url(#meter-gradient-${config.id})`}
    rx={1}
  />

  {/* Peak hold indicator if enabled */}
  {config.showPeakHold && (
    <rect
      x={1}
      y={/* peakHoldPosition */}
      width={config.width - 2}
      height={2}
      fill={config.colorStops[config.colorStops.length - 1]?.color || 'red'}
    />
  )}
</svg>
```

For horizontal meter, swap x/y dimensions and gradient direction.

Default colorStops (typical meter gradient):
```typescript
[
  { position: 0, color: '#22c55e' },    // green at 0%
  { position: 0.6, color: '#eab308' },  // yellow at 60%
  { position: 0.85, color: '#f97316' }, // orange at 85%
  { position: 1, color: '#ef4444' },    // red at 100%
]
```

Default styling:
- backgroundColor: '#1f2937' (gray-800)
- min: 0
- max: 1
- value: 0
- orientation: 'vertical'
- showPeakHold: false

Important: Each meter needs unique gradient ID to prevent conflicts when multiple meters exist. Use config.id.

Update Element.tsx to add case for 'meter'.
Update renderers/index.ts to export MeterRenderer.
  </action>
  <verify>
Add test meters via console:
```javascript
const store = useStore.getState();
const { createMeter } = await import('./src/types/elements');
store.addElement(createMeter({ x: 350, y: 100, value: 0.7, height: 150, width: 20 }));
store.addElement(createMeter({ x: 400, y: 200, value: 0.3, orientation: 'horizontal', width: 150, height: 20 }));
```
Verify meters display with gradient fill at correct level for both orientations.
  </verify>
  <done>
MeterRenderer displays gradient fill with configurable color stops, supports vertical and horizontal orientations.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm run dev` - App runs without errors
3. Add button elements, verify labels and pressed state visuals
4. Add label elements, verify font styling and text alignment
5. Add meter elements, verify gradient fills at various values
6. Test horizontal meter orientation
7. Verify all elements position correctly on canvas
8. Verify zoom/pan still works with elements rendered
</verification>

<success_criteria>
- ButtonRenderer displays with label and pressed state visual
- LabelRenderer displays text with all styling options
- MeterRenderer displays gradient fill correctly for both orientations
- All renderers are properly connected via Element dispatcher
- No TypeScript errors
- Elements render correctly in canvas container
</success_criteria>

<output>
After completion, create `.planning/phases/02-element-library/02-03-SUMMARY.md`
</output>
