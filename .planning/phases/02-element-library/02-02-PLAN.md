---
phase: 02-element-library
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/elements/BaseElement.tsx
  - src/components/elements/Element.tsx
  - src/components/elements/renderers/KnobRenderer.tsx
  - src/components/elements/renderers/SliderRenderer.tsx
  - src/components/elements/renderers/index.ts
  - src/components/elements/index.ts
  - src/components/Canvas/Canvas.tsx
autonomous: true

must_haves:
  truths:
    - "BaseElement wrapper positions and sizes elements correctly"
    - "Element dispatcher renders correct renderer based on element type"
    - "Knob displays SVG arc with track and value fill"
    - "Slider displays SVG track and thumb in correct orientation"
  artifacts:
    - path: "src/components/elements/BaseElement.tsx"
      provides: "Wrapper component with position, size, rotation"
      contains: "position: 'absolute'"
    - path: "src/components/elements/Element.tsx"
      provides: "Discriminated union dispatcher"
      contains: "element.type"
    - path: "src/components/elements/renderers/KnobRenderer.tsx"
      provides: "SVG knob with arc track and fill"
      contains: "describeArc"
    - path: "src/components/elements/renderers/SliderRenderer.tsx"
      provides: "SVG slider with track and thumb"
      contains: "orientation"
  key_links:
    - from: "src/components/elements/Element.tsx"
      to: "src/components/elements/BaseElement.tsx"
      via: "wraps renderers"
      pattern: "<BaseElement"
    - from: "src/components/elements/Element.tsx"
      to: "src/components/elements/renderers/KnobRenderer.tsx"
      via: "conditional render for knob type"
      pattern: "element.type.*knob"
    - from: "src/components/Canvas/Canvas.tsx"
      to: "src/components/elements/Element.tsx"
      via: "maps elements to Element components"
      pattern: "elements.map.*<Element"
---

<objective>
Create BaseElement wrapper and core element renderers (Knob, Slider).

Purpose: Establish the compound component pattern for all elements - BaseElement handles position/size, specialized renderers handle type-specific visuals.

Output: BaseElement wrapper, Element dispatcher, KnobRenderer with SVG arcs, SliderRenderer with track and thumb.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-element-library/02-CONTEXT.md
@.planning/phases/02-element-library/02-RESEARCH.md
@.planning/phases/02-element-library/02-01-SUMMARY.md

# Types from Plan 01
@src/types/elements.ts
@src/store/elementsSlice.ts
@src/components/Canvas/Canvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseElement wrapper and Element dispatcher</name>
  <files>src/components/elements/BaseElement.tsx, src/components/elements/Element.tsx, src/components/elements/index.ts, src/components/Canvas/Canvas.tsx</files>
  <action>
Create BaseElement.tsx - the common wrapper for all element types.

BaseElement receives:
- element: ElementConfig (from types/elements.ts)
- children: React.ReactNode

BaseElement renders a div with:
- position: 'absolute'
- left: element.x
- top: element.y
- width: element.width
- height: element.height
- transform: `rotate(${element.rotation}deg)`
- zIndex: element.zIndex
- visibility: element.visible ? 'visible' : 'hidden'
- pointerEvents: element.locked ? 'none' : 'auto'

Use React.useMemo for the style object to prevent unnecessary re-renders:
```typescript
const style = React.useMemo(() => ({
  position: 'absolute' as const,
  left: element.x,
  top: element.y,
  // ... etc
}), [element.x, element.y, element.width, element.height, element.rotation, element.zIndex, element.visible, element.locked]);
```

Add data-element-id attribute for future selection/debugging: `data-element-id={element.id}`

Create Element.tsx - the discriminated union dispatcher.

Element receives:
- element: ElementConfig

Element uses switch/case on element.type to render correct renderer inside BaseElement:
```typescript
function Element({ element }: { element: ElementConfig }) {
  const renderContent = () => {
    switch (element.type) {
      case 'knob':
        return <KnobRenderer config={element} />;
      case 'slider':
        return <SliderRenderer config={element} />;
      // ... other cases
      default:
        // TypeScript exhaustive check
        const _exhaustive: never = element;
        return null;
    }
  };

  return (
    <BaseElement element={element}>
      {renderContent()}
    </BaseElement>
  );
}
```

Wrap Element in React.memo to prevent re-renders when other elements change:
```typescript
export const Element = React.memo(ElementComponent);
```

Create index.ts barrel export.

IMPORTANT: Update Canvas.tsx to import and render Element components for each element in the store:
```typescript
import { Element } from '../elements';
// ... inside the canvas-background div:
{elements.map((el) => (
  <Element key={el.id} element={el} />
))}
```

This wiring is critical - without it, elements will exist in the store but not render on canvas.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Create test element in console and verify div renders with correct position styles.
  </verify>
  <done>
BaseElement wrapper positions elements, Element dispatcher switches on type, Canvas renders Element components.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create KnobRenderer with SVG arc rendering</name>
  <files>src/components/elements/renderers/KnobRenderer.tsx, src/components/elements/renderers/index.ts</files>
  <action>
Create KnobRenderer.tsx following the pattern from 02-RESEARCH.md.

Create helper functions (can be in same file or separate utils):

```typescript
function polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {
  const angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians),
  };
}

function describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): string {
  const start = polarToCartesian(x, y, radius, endAngle);
  const end = polarToCartesian(x, y, radius, startAngle);
  const largeArcFlag = Math.abs(endAngle - startAngle) > 180 ? '1' : '0';

  return [
    'M', start.x, start.y,
    'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y
  ].join(' ');
}
```

KnobRenderer receives:
- config: KnobElementConfig

KnobRenderer renders SVG with:
1. Background track arc (from startAngle to endAngle)
2. Value fill arc (from startAngle to calculated valueAngle)
3. Indicator line/dot based on style

Calculate value angle:
```typescript
const range = config.max - config.min;
const normalizedValue = (config.value - config.min) / range;
const valueAngle = config.startAngle + normalizedValue * (config.endAngle - config.startAngle);
```

SVG structure:
```jsx
<svg width="100%" height="100%" viewBox={`0 0 ${config.diameter} ${config.diameter}`}>
  {/* Background track */}
  <path
    d={trackPath}
    fill="none"
    stroke={config.trackColor}
    strokeWidth={config.trackWidth}
    strokeLinecap="round"
  />
  {/* Value fill */}
  <path
    d={valuePath}
    fill="none"
    stroke={config.fillColor}
    strokeWidth={config.trackWidth}
    strokeLinecap="round"
  />
  {/* Indicator based on style */}
  {config.style === 'line' && (
    <line ... />
  )}
  {config.style === 'dot' && (
    <circle ... />
  )}
</svg>
```

Handle edge cases:
- If value equals min, don't render value arc (or render tiny arc)
- If arc spans full 360 degrees, need two arcs (SVG limitation)
- Use config.diameter for size, center is diameter/2

Default styling:
- trackColor: '#374151' (gray-700)
- fillColor: '#3b82f6' (blue-500)
- indicatorColor: '#ffffff'
- trackWidth: 4

SVG should use focusable="false" for accessibility (interactive handling later in Phase 3+).
  </action>
  <verify>
Add test knob to store via console:
```javascript
const store = useStore.getState();
const { createKnob } = await import('./src/types/elements');
store.addElement(createKnob({ x: 100, y: 100, value: 0.5 }));
```
Verify knob displays with arc track and value fill.
  </verify>
  <done>
KnobRenderer displays SVG arc with track, value fill, and indicator. Arc math handles all angle ranges correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SliderRenderer with track and thumb</name>
  <files>src/components/elements/renderers/SliderRenderer.tsx</files>
  <action>
Create SliderRenderer.tsx for both vertical and horizontal sliders.

SliderRenderer receives:
- config: SliderElementConfig

Calculate thumb position based on value:
```typescript
const range = config.max - config.min;
const normalizedValue = (config.value - config.min) / range;

// For vertical: 0 = bottom, 1 = top
// For horizontal: 0 = left, 1 = right
const trackLength = config.orientation === 'vertical' ? config.height : config.width;
const thumbOffset = normalizedValue * (trackLength - config.thumbHeight);
```

SVG structure for vertical slider:
```jsx
<svg width="100%" height="100%" viewBox={`0 0 ${config.width} ${config.height}`}>
  {/* Track background */}
  <rect
    x={(config.width - trackWidth) / 2}
    y={0}
    width={trackWidth}
    height={config.height}
    fill={config.trackColor}
    rx={trackWidth / 2}
  />
  {/* Track fill (from bottom to thumb) */}
  <rect
    x={(config.width - trackWidth) / 2}
    y={config.height - fillHeight}
    width={trackWidth}
    height={fillHeight}
    fill={config.trackFillColor}
    rx={trackWidth / 2}
  />
  {/* Thumb */}
  <rect
    x={(config.width - config.thumbWidth) / 2}
    y={thumbY}
    width={config.thumbWidth}
    height={config.thumbHeight}
    fill={config.thumbColor}
    rx={4}
  />
</svg>
```

For horizontal orientation, swap x/y and width/height logic.

Track width should be a fraction of the smaller dimension (e.g., 6px or config.width * 0.2 for horizontal).

Default styling:
- trackColor: '#374151' (gray-700)
- trackFillColor: '#3b82f6' (blue-500)
- thumbColor: '#ffffff'
- thumbWidth: 20
- thumbHeight: 12

Handle edge cases:
- Thumb should not exceed track boundaries
- Value at min/max should position thumb at track ends
  </action>
  <verify>
Add test sliders to store:
```javascript
const store = useStore.getState();
const { createSlider } = await import('./src/types/elements');
store.addElement(createSlider({ x: 200, y: 100, orientation: 'vertical', value: 0.3 }));
store.addElement(createSlider({ x: 300, y: 100, orientation: 'horizontal', value: 0.7 }));
```
Verify both orientations display correctly with proper thumb positions.
  </verify>
  <done>
SliderRenderer displays track and thumb correctly for both vertical and horizontal orientations.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm run dev` - App runs without errors
3. Add knob via console, verify arc rendering with value fill
4. Add vertical slider via console, verify track and thumb
5. Add horizontal slider via console, verify orientation is correct
6. Verify elements respect x, y position (move elements to different positions)
7. Verify rotation works (set rotation: 45 on an element)
8. React DevTools: Element components should be memoized (no unnecessary re-renders)
</verification>

<success_criteria>
- BaseElement positions elements absolutely with correct styles
- Element dispatcher correctly switches on type
- KnobRenderer displays SVG arc with track and value fill
- SliderRenderer displays track and thumb for both orientations
- All components are memoized for performance
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-element-library/02-02-SUMMARY.md`
</output>
