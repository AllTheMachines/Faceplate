---
phase: 02-element-library
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - src/components/elements/renderers/ImageRenderer.tsx
  - src/components/elements/renderers/index.ts
  - src/components/elements/Element.tsx
  - src/App.tsx
  - package.json
autonomous: false

must_haves:
  truths:
    - "Image element displays image from src (base64 or URL)"
    - "Image respects fit mode (contain, cover, fill, none)"
    - "All 6 element types render correctly on canvas"
    - "Sample elements demonstrate all element types"
  artifacts:
    - path: "src/components/elements/renderers/ImageRenderer.tsx"
      provides: "Image display with fit modes"
      contains: "objectFit"
    - path: "src/App.tsx"
      provides: "Demo elements for visual verification"
      contains: "addElement"
  key_links:
    - from: "src/components/elements/Element.tsx"
      to: "src/components/elements/renderers/ImageRenderer.tsx"
      via: "conditional render for image type"
      pattern: "case 'image'"
---

<objective>
Create ImageRenderer and integrate all elements with visual demonstration.

Purpose: Complete the element library with Image support and provide visual verification that all 6 element types work correctly together.

Output: ImageRenderer with fit modes, demo elements showing all types on canvas.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-element-library/02-CONTEXT.md
@.planning/phases/02-element-library/02-RESEARCH.md
@.planning/phases/02-element-library/02-03-SUMMARY.md

# Existing components
@src/types/elements.ts
@src/components/elements/Element.tsx
@src/components/elements/renderers/index.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImageRenderer with fit modes</name>
  <files>src/components/elements/renderers/ImageRenderer.tsx, src/components/elements/renderers/index.ts, src/components/elements/Element.tsx</files>
  <action>
Create ImageRenderer.tsx for image display elements.

ImageRenderer receives:
- config: ImageElementConfig

Render as HTML img element:
```jsx
<img
  src={config.src}
  alt=""
  draggable={false}
  style={{
    width: '100%',
    height: '100%',
    objectFit: config.fit,
    display: 'block',
  }}
  onError={(e) => {
    // Show placeholder on error
    e.currentTarget.style.display = 'none';
    e.currentTarget.nextElementSibling?.classList.remove('hidden');
  }}
/>
// Placeholder for broken images
<div
  className="hidden"
  style={{
    width: '100%',
    height: '100%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#374151',
    color: '#9ca3af',
    fontSize: '12px',
  }}
>
  Image not found
</div>
```

Actually, simpler approach without onError (just show image or nothing):
```jsx
function ImageRenderer({ config }: { config: ImageElementConfig }) {
  const [hasError, setHasError] = React.useState(false);

  if (!config.src || hasError) {
    return (
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#374151',
          color: '#9ca3af',
          fontSize: '12px',
          border: '2px dashed #4b5563',
        }}
      >
        No image
      </div>
    );
  }

  return (
    <img
      src={config.src}
      alt=""
      draggable={false}
      onError={() => setHasError(true)}
      style={{
        width: '100%',
        height: '100%',
        objectFit: config.fit,
        display: 'block',
      }}
    />
  );
}
```

Object-fit modes:
- 'contain': Scale to fit, maintain aspect ratio, may have letterboxing
- 'cover': Scale to fill, maintain aspect ratio, may crop
- 'fill': Stretch to fill, distorts aspect ratio
- 'none': No scaling, image at natural size

Default styling:
- src: '' (empty, shows placeholder)
- fit: 'contain'

Handle base64 data URLs (for uploaded images) and external URLs.

Note: Actual image upload UI comes in Phase 4-5 with property panel. For now, src can be set via store directly.

Update Element.tsx to add case for 'image'.
Update renderers/index.ts to export ImageRenderer.
  </action>
  <verify>
Add test image via console:
```javascript
const store = useStore.getState();
const { createImage } = await import('./src/types/elements');
// Test with external URL (small placeholder image)
store.addElement(createImage({
  x: 450, y: 100,
  width: 100, height: 100,
  src: 'https://via.placeholder.com/100',
  fit: 'cover'
}));
// Test empty image (should show placeholder)
store.addElement(createImage({ x: 450, y: 220, width: 100, height: 100 }));
```
Verify image displays, placeholder shows for empty/broken images.
  </verify>
  <done>
ImageRenderer displays images with fit modes, shows placeholder for missing/broken images.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add demo elements on app startup</name>
  <files>src/App.tsx</files>
  <action>
Update App.tsx to add demo elements when the app first loads.

This serves two purposes:
1. Visual verification that all elements render correctly
2. Gives users something to see immediately on startup

Add useEffect to populate demo elements on mount:
```typescript
import { useEffect } from 'react';
import { useStore } from './store';
import { createKnob, createSlider, createButton, createLabel, createMeter, createImage } from './types/elements';

function App() {
  useEffect(() => {
    const store = useStore.getState();

    // Only add demo elements if canvas is empty
    if (store.elements.length === 0) {
      // Row 1: Knobs
      store.addElement(createKnob({
        x: 50, y: 50,
        name: 'Gain',
        value: 0.75,
      }));
      store.addElement(createKnob({
        x: 150, y: 50,
        name: 'Pan',
        value: 0.5,
        fillColor: '#10b981', // emerald
      }));

      // Row 2: Sliders
      store.addElement(createSlider({
        x: 280, y: 30,
        name: 'Volume',
        orientation: 'vertical',
        value: 0.6,
        height: 120,
        width: 40,
      }));
      store.addElement(createSlider({
        x: 340, y: 80,
        name: 'Cutoff',
        orientation: 'horizontal',
        value: 0.3,
        width: 120,
        height: 30,
      }));

      // Row 3: Buttons
      store.addElement(createButton({
        x: 50, y: 180,
        name: 'Play',
        label: 'Play',
        width: 80,
        height: 36,
      }));
      store.addElement(createButton({
        x: 140, y: 180,
        name: 'Bypass',
        label: 'Bypass',
        mode: 'toggle',
        pressed: true,
        width: 80,
        height: 36,
        backgroundColor: '#ef4444', // red when active
      }));

      // Row 4: Labels
      store.addElement(createLabel({
        x: 50, y: 240,
        name: 'Title',
        text: 'My Plugin',
        fontSize: 24,
        fontWeight: 700,
        width: 200,
        height: 36,
      }));
      store.addElement(createLabel({
        x: 50, y: 280,
        name: 'Subtitle',
        text: 'v1.0.0',
        fontSize: 12,
        color: '#9ca3af',
        width: 100,
        height: 20,
      }));

      // Meters
      store.addElement(createMeter({
        x: 500, y: 30,
        name: 'Level L',
        value: 0.7,
        width: 20,
        height: 140,
      }));
      store.addElement(createMeter({
        x: 530, y: 30,
        name: 'Level R',
        value: 0.55,
        width: 20,
        height: 140,
      }));

      // Image placeholder
      store.addElement(createImage({
        x: 600, y: 30,
        name: 'Logo',
        width: 100,
        height: 100,
        // No src - will show placeholder
      }));
    }
  }, []);

  return (
    // ... existing layout
  );
}
```

Position elements to create a reasonable visual layout that demonstrates all types.

Make sure demo only adds elements if canvas is empty (to avoid duplicating on hot reload).

Consider adding a comment in code noting this is for demo/testing and can be removed.
  </action>
  <verify>
1. Run `npm run dev`
2. Verify all 6 element types appear on canvas at startup
3. Verify pan and zoom work with elements present
4. Refresh page - elements should reappear (since we check for empty)
5. Hot reload should not duplicate elements
  </verify>
  <done>
App shows demo elements demonstrating all 6 element types. Elements display correctly with pan/zoom.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete element library with all 6 element types (Knob, Slider, Button, Label, Meter, Image) rendered on HTML/CSS canvas with CSS transforms for zoom/pan.</what-built>
  <how-to-verify>
1. Run `npm run dev` and open http://localhost:5173
2. Verify you see demo elements on the canvas:
   - Two knobs with arc displays (different colors)
   - Vertical and horizontal sliders with tracks and thumbs
   - Two buttons with different states (normal and pressed/toggle)
   - Labels with different sizes
   - Two level meters with gradient fills
   - Image placeholder
3. Test pan: Hold spacebar and drag - canvas should pan smoothly
4. Test zoom: Scroll wheel to zoom in/out - cursor should stay stationary
5. Verify zoom indicator in bottom right shows percentage
6. Check browser console for any errors
7. Optional: Add/modify elements via console to test store
  </how-to-verify>
  <resume-signal>Type "approved" if all elements display correctly and pan/zoom works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm run dev` - App runs without errors
3. All 6 element types visible on canvas
4. Pan with spacebar + drag works
5. Zoom with scroll wheel works
6. No console errors
7. Elements position, size, and style correctly based on config
</verification>

<success_criteria>
- ImageRenderer displays images with fit modes
- Demo elements show all 6 element types
- All elements render correctly on canvas
- Pan and zoom work with elements present
- User visually verifies complete implementation
</success_criteria>

<output>
After completion, create `.planning/phases/02-element-library/02-04-SUMMARY.md`
</output>
