---
phase: 58-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/export/htmlGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Styled sliders export with correct inline SVG layer structure"
    - "Styled buttons export with all state layers present in DOM"
    - "Styled meters export with zone fill layers and peak indicator"
  artifacts:
    - path: "src/services/export/htmlGenerator.ts"
      provides: "generateStyledSliderHTML, generateStyledButtonHTML, generateStyledMeterHTML functions"
      contains: "generateStyledSliderHTML|generateStyledButtonHTML|generateStyledMeterHTML"
  key_links:
    - from: "htmlGenerator.ts"
      to: "elementStylesSlice"
      via: "useStore.getState().elementStyles"
      pattern: "getElementStyle|elementStyles"
    - from: "htmlGenerator.ts"
      to: "elementLayers.ts"
      via: "extractElementLayer import"
      pattern: "extractElementLayer"
---

<objective>
Add HTML generators for styled sliders, buttons, and meters to the export system.

Purpose: Extend the proven generateStyledKnobHTML pattern to support all SVG-styled element categories (linear, arc, button, meter) so exported JUCE bundles render styled elements correctly.

Output: Three new generator functions (generateStyledSliderHTML, generateStyledButtonHTML, generateStyledMeterHTML) following the existing knob pattern with category-specific layer extraction and initial state handling.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-export/58-CONTEXT.md
@.planning/phases/58-export/58-RESEARCH.md

# Key source files
@src/services/export/htmlGenerator.ts (generateStyledKnobHTML at line 660)
@src/services/elementLayers.ts (extractElementLayer, already generalized)
@src/types/elementStyle.ts (LinearLayers, ButtonLayers, MeterLayers types)
@src/store/elementStylesSlice.ts (getElementStyle, elementStyles)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add styled slider HTML generator</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Add generateStyledSliderHTML function following the generateStyledKnobHTML pattern (line 660):

1. Import ElementStyle, LinearLayers, ArcLayers from elementStyle.ts
2. Import extractElementLayer from elementLayers.ts (alongside existing extractLayer from knobLayers)
3. Add function signature:
   ```typescript
   function generateStyledSliderHTML(
     id: string,
     baseClass: string,
     positionStyle: string,
     config: SliderElementConfig,
     style: ElementStyle
   ): string
   ```

4. Validate category at start:
   - If style.category !== 'linear' AND style.category !== 'arc', log warning and return default slider HTML
   - This handles the discriminated union narrowing

5. Apply color overrides (same pattern as knob):
   ```typescript
   let svgWithOverrides = style.svgContent
   if (config.colorOverrides) {
     svgWithOverrides = applyAllColorOverrides(style.svgContent, style.layers as LinearLayers, config.colorOverrides)
   }
   const sanitizedSvg = sanitizeSVG(svgWithOverrides)
   ```

6. Extract layers based on LinearLayers:
   - trackSvg = extractElementLayer(sanitizedSvg, style.layers.track) or ''
   - fillSvg = extractElementLayer(sanitizedSvg, style.layers.fill) or ''
   - thumbSvg = extractElementLayer(sanitizedSvg, style.layers.thumb) or ''

7. Calculate normalized value: (config.value - config.min) / (config.max - config.min)

8. Add data attributes for JS animation:
   - data-parameter-id (from config.parameterId or toKebabCase(config.name))
   - data-orientation (from config.orientation)
   - data-value (normalized 0-1)

9. Calculate initial positions:
   - For vertical: clipFromTop = (1 - normalizedValue) * 100, thumbTranslate = `translate(0, ${(1 - normalizedValue) * 100}%)`
   - For horizontal: clipFromRight = (1 - normalizedValue) * 100, thumbTranslate = `translate(${normalizedValue * 100}%, 0)`

10. Return HTML structure:
    ```html
    <div id="${id}" class="${baseClass} slider styled-slider" data-type="slider" ${dataAttrs} style="${positionStyle}">
      <div class="styled-slider-container">
        ${trackSvg ? `<div class="slider-layer slider-track">${trackSvg}</div>` : ''}
        ${fillSvg ? `<div class="slider-layer slider-fill" style="clip-path: ${fillClipPath};">${fillSvg}</div>` : ''}
        ${thumbSvg ? `<div class="slider-layer slider-thumb" style="transform: ${thumbTransform};">${thumbSvg}</div>` : ''}
      </div>
    </div>
    ```

11. Update generateSliderHTML to check for styleId (like generateKnobHTML does):
    - If config.styleId exists, get style from useStore.getState().elementStyles
    - Call generateStyledSliderHTML if found
    - Fallback to default slider HTML if style not found

12. Apply same pattern to generateBipolarSliderHTML, generateNotchedSliderHTML, generateCrossfadeSliderHTML, generateArcSliderHTML:
    - Add styleId check at the start of each function
    - Call generateStyledSliderHTML for styled variants
  </action>
  <verify>
    - grep for "generateStyledSliderHTML" in htmlGenerator.ts shows function defined
    - grep for "styled-slider" in htmlGenerator.ts shows class usage
    - TypeScript compiles without errors: npm run build
  </verify>
  <done>
    - generateStyledSliderHTML function exists and handles linear/arc categories
    - Slider HTML generators check styleId before generating HTML
    - Styled sliders export with inline SVG layers, data attributes, and initial positions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add styled button HTML generator</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Add generateStyledButtonHTML function for buttons and switches:

1. Add function signature:
   ```typescript
   function generateStyledButtonHTML(
     id: string,
     baseClass: string,
     positionStyle: string,
     config: ButtonElementConfig | IconButtonElementConfig | ToggleSwitchElementConfig | PowerButtonElementConfig,
     style: ElementStyle
   ): string
   ```

2. Validate category: if style.category !== 'button', warn and return default

3. Apply color overrides and sanitize (same pattern)

4. Cast layers to ButtonLayers type after category validation:
   ```typescript
   const buttonLayers = style.layers as ButtonLayers
   ```

5. Extract layers based on element type:
   - For Button/IconButton: normal, pressed, icon, label
   - For ToggleSwitch: body, on, off, indicator
   - For PowerButton: normal, pressed, icon, led

6. Determine initial state:
   - For toggle mode: check config.pressed (if true, show pressed layer)
   - For momentary: always start with normal layer visible

7. Add data attributes:
   - data-parameter-id
   - data-mode (momentary, toggle, radio)
   - data-state (0 or 1 for toggle state)

8. Return HTML with opacity toggle pattern (CRITICAL - from CONTEXT.md decision):
   - All state layers present in DOM
   - Opacity: 1 for active state, 0 for inactive
   - NO CSS transitions (instant toggle)

   ```html
   <div id="${id}" class="${baseClass} button styled-button" data-type="button" ${dataAttrs} style="${positionStyle}">
     <div class="styled-button-container">
       ${normalSvg ? `<div class="button-layer button-normal" style="opacity: ${!pressed ? '1' : '0'};">${normalSvg}</div>` : ''}
       ${pressedSvg ? `<div class="button-layer button-pressed" style="opacity: ${pressed ? '1' : '0'};">${pressedSvg}</div>` : ''}
       ${iconSvg ? `<div class="button-layer button-icon">${iconSvg}</div>` : ''}
       ${labelSvg ? `<div class="button-layer button-label">${labelSvg}</div>` : ''}
     </div>
   </div>
   ```

9. Update existing button generators to check styleId:
   - generateIconButtonHTML
   - generateToggleSwitchHTML
   - generatePowerButtonHTML
   - generateRockerSwitchHTML (uses position-0, position-1, position-2 layers)
   - generateRotarySwitchHTML (uses base, selector layers)
   - generateSegmentButtonHTML (uses body, highlight layers with clip-path)

10. For multi-position elements (RockerSwitch, RotarySwitch):
    - Export all position layers with appropriate opacity
    - Add data-position attribute for current position

11. For SegmentButton:
    - Calculate clip-path for highlight layer based on selectedIndex
    - Add data-selected-index attribute
  </action>
  <verify>
    - grep for "generateStyledButtonHTML" in htmlGenerator.ts shows function defined
    - grep for "styled-button" in htmlGenerator.ts shows class usage
    - grep for "button-layer" shows layer classes
    - TypeScript compiles without errors: npm run build
  </verify>
  <done>
    - generateStyledButtonHTML function exists and handles button category
    - All button/switch variants check styleId before generating HTML
    - Styled buttons export with opacity toggle pattern (no transitions)
    - Multi-position elements (rocker, rotary) export all states
  </done>
</task>

<task type="auto">
  <name>Task 3: Add styled meter HTML generator</name>
  <files>src/services/export/htmlGenerator.ts</files>
  <action>
Add generateStyledMeterHTML function for meters:

1. Add function signature:
   ```typescript
   function generateStyledMeterHTML(
     id: string,
     baseClass: string,
     positionStyle: string,
     config: MeterElementConfig,
     style: ElementStyle
   ): string
   ```

2. Validate category: if style.category !== 'meter', warn and return default

3. Apply color overrides and sanitize

4. Cast layers to MeterLayers:
   ```typescript
   const meterLayers = style.layers as MeterLayers
   ```

5. Extract layers (matching Phase 57-02 StyledMeterRenderer):
   - bodySvg = extractElementLayer(sanitizedSvg, meterLayers.body) or ''
   - fillGreenSvg = extractElementLayer(sanitizedSvg, meterLayers['fill-green']) or ''
   - fillYellowSvg = extractElementLayer(sanitizedSvg, meterLayers['fill-yellow']) or ''
   - fillRedSvg = extractElementLayer(sanitizedSvg, meterLayers['fill-red']) or ''
   - scaleSvg = extractElementLayer(sanitizedSvg, meterLayers.scale) or ''
   - peakSvg = extractElementLayer(sanitizedSvg, meterLayers.peak) or ''

6. Calculate normalized value (0-1)

7. Define zone thresholds (from Phase 57-02 decisions):
   - yellowThreshold = 0.6 (corresponds to -18dB)
   - redThreshold = 0.85 (corresponds to -6dB)

8. Calculate clip-paths for zone fills (bottom-up reveal):
   - clipFromTop = (1 - normalizedValue) * 100
   - greenClipPath = `inset(${clipFromTop}% 0 0 0)`
   - yellowClipPath = normalizedValue > yellowThreshold ? greenClipPath : 'inset(100% 0 0 0)'
   - redClipPath = normalizedValue > redThreshold ? greenClipPath : 'inset(100% 0 0 0)'

9. Add data attributes:
   - data-parameter-id
   - data-orientation (vertical or horizontal)
   - data-value (normalized)
   - data-peak-hold="true" if config.showPeakHold
   - data-peak-duration (from config.peakHoldDuration or 2000)

10. Handle horizontal orientation (from Phase 57-02):
    - Container rotated -90deg with transform-origin: center center

11. Return HTML structure:
    ```html
    <div id="${id}" class="${baseClass} meter styled-meter" data-type="meter" ${dataAttrs} style="${positionStyle}">
      <div class="styled-meter-container"${horizontalRotateStyle}>
        ${bodySvg ? `<div class="meter-layer meter-body">${bodySvg}</div>` : ''}
        ${fillGreenSvg ? `<div class="meter-layer meter-fill-green" style="clip-path: ${greenClipPath};">${fillGreenSvg}</div>` : ''}
        ${fillYellowSvg ? `<div class="meter-layer meter-fill-yellow" style="clip-path: ${yellowClipPath};">${fillYellowSvg}</div>` : ''}
        ${fillRedSvg ? `<div class="meter-layer meter-fill-red" style="clip-path: ${redClipPath};">${fillRedSvg}</div>` : ''}
        ${scaleSvg ? `<div class="meter-layer meter-scale">${scaleSvg}</div>` : ''}
        ${peakSvg && config.showPeakHold ? `<div class="meter-layer meter-peak" style="bottom: ${normalizedValue * 100}%; transform: translateY(50%);">${peakSvg}</div>` : ''}
      </div>
    </div>
    ```

12. Update generateMeterHTML to check for styleId:
    - If config.styleId exists, get style from elementStyles
    - Call generateStyledMeterHTML if found
    - Fallback to default meter HTML if not

13. Apply styleId check to professional meter generators:
    - generateProfessionalMeterHTML (mono and stereo variants)
    - They should delegate to generateStyledMeterHTML if styleId present
  </action>
  <verify>
    - grep for "generateStyledMeterHTML" in htmlGenerator.ts shows function defined
    - grep for "styled-meter" in htmlGenerator.ts shows class usage
    - grep for "meter-fill-green|meter-fill-yellow|meter-fill-red" shows zone classes
    - TypeScript compiles without errors: npm run build
  </verify>
  <done>
    - generateStyledMeterHTML function exists and handles meter category
    - Meter HTML generators check styleId before generating HTML
    - Styled meters export with zone fill layers and clip-path animation
    - Peak indicator exported with position data
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles: `npm run build` exits 0
2. All styled generators exist:
   - `grep -n "generateStyledSliderHTML" src/services/export/htmlGenerator.ts`
   - `grep -n "generateStyledButtonHTML" src/services/export/htmlGenerator.ts`
   - `grep -n "generateStyledMeterHTML" src/services/export/htmlGenerator.ts`
3. All styled classes exported:
   - `grep -c "styled-slider\|styled-button\|styled-meter" src/services/export/htmlGenerator.ts` shows multiple matches
4. Layer extraction patterns:
   - `grep -c "extractElementLayer" src/services/export/htmlGenerator.ts` shows imports and usage
</verification>

<success_criteria>
- [ ] generateStyledSliderHTML generates HTML with track/fill/thumb layers
- [ ] generateStyledButtonHTML generates HTML with opacity toggle layers
- [ ] generateStyledMeterHTML generates HTML with zone fill clip-path layers
- [ ] All slider variants (bipolar, notched, crossfade, arc) check styleId
- [ ] All button variants (icon, toggle, power, rocker, rotary, segment) check styleId
- [ ] All meter variants check styleId
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/58-export/58-01-SUMMARY.md`
</output>
