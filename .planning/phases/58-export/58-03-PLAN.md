---
phase: 58-export
plan: 03
type: execute
wave: 2
depends_on: ["58-01"]
files_modified:
  - src/services/export/jsGenerator.ts
autonomous: true

must_haves:
  truths:
    - "updateSlider function animates styled slider thumb and fill"
    - "updateMeter function animates styled meter zone fills with clip-path"
    - "updateButton function toggles styled button state layers instantly"
    - "Peak hold decay timer works correctly"
  artifacts:
    - path: "src/services/export/jsGenerator.ts"
      provides: "updateSlider, updateMeter, updateButton shared helper functions"
      contains: "updateSlider|updateMeter|updateButton"
  key_links:
    - from: "jsGenerator.ts"
      to: "htmlGenerator.ts"
      via: "CSS class selectors"
      pattern: "styled-slider|styled-button|styled-meter"
---

<objective>
Add shared animation helper functions for styled elements to the JavaScript export.

Purpose: Provide reusable JS functions (updateSlider, updateMeter, updateButton) that animate styled elements based on parameter values. These helpers reduce exported bundle size and ensure consistent behavior.

Output: Three animation helper functions added to jsGenerator.ts that are called by parameter bindings to update styled element visual state.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-export/58-CONTEXT.md
@.planning/phases/58-export/58-RESEARCH.md
@.planning/phases/58-export/58-01-SUMMARY.md (if available - for HTML structure)

# Key source files
@src/services/export/jsGenerator.ts (generateBindingsJS pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updateSlider animation helper</name>
  <files>src/services/export/jsGenerator.ts</files>
  <action>
Add generateStyledAnimationHelpers function that returns JS code for styled element animations.

1. Create new function generateStyledAnimationHelpers():
```typescript
export function generateStyledAnimationHelpers(): string {
  return `
// ============================================================================
// Styled Element Animation Helpers
// ============================================================================

/**
 * Update styled slider position (thumb translate, fill clip-path)
 * @param {string} elementId - Slider element ID
 * @param {number} normalizedValue - Value 0-1
 */
function updateSlider(elementId, normalizedValue) {
  const element = document.getElementById(elementId);
  if (!element || !element.classList.contains('styled-slider')) return;

  const orientation = element.dataset.orientation || 'horizontal';
  const thumbLayer = element.querySelector('.slider-thumb');
  const fillLayer = element.querySelector('.slider-fill');

  if (thumbLayer) {
    // GPU-accelerated transform translate
    if (orientation === 'vertical') {
      // Inverted: 0 at bottom, 1 at top
      const thumbY = (1 - normalizedValue) * 100;
      thumbLayer.style.transform = 'translate(0, ' + thumbY + '%)';
    } else {
      const thumbX = normalizedValue * 100;
      thumbLayer.style.transform = 'translate(' + thumbX + '%, 0)';
    }
  }

  if (fillLayer) {
    // Clip-path inset for fill reveal
    if (orientation === 'vertical') {
      // Bottom-up fill: inset from top
      const clipFromTop = (1 - normalizedValue) * 100;
      fillLayer.style.clipPath = 'inset(' + clipFromTop + '% 0 0 0)';
    } else {
      // Left-to-right fill: inset from right
      const clipFromRight = (1 - normalizedValue) * 100;
      fillLayer.style.clipPath = 'inset(0 ' + clipFromRight + '% 0 0)';
    }
  }

  // Update data attribute for state tracking
  element.dataset.value = normalizedValue;
}
`;
}
```

2. Ensure this function is called in the main JS output generation (alongside bindings)

Key implementation notes:
- Use string concatenation (not template literals) in the output JS for browser compatibility
- Orientation check reads from data-orientation attribute set in HTML
- Thumb uses transform translate (GPU-accelerated)
- Fill uses clip-path inset (matches CSS animation)
- Value stored in data-value for state inspection
  </action>
  <verify>
    - grep for "function updateSlider" in jsGenerator.ts shows function defined
    - grep for "styled-slider" in jsGenerator.ts shows class check
    - TypeScript compiles: npm run build
  </verify>
  <done>
    - updateSlider function in exported JS code
    - Handles both vertical and horizontal orientation
    - Uses transform for thumb, clip-path for fill
  </done>
</task>

<task type="auto">
  <name>Task 2: Add updateMeter animation helper with peak hold</name>
  <files>src/services/export/jsGenerator.ts</files>
  <action>
Add updateMeter function to generateStyledAnimationHelpers:

```typescript
// Add to generateStyledAnimationHelpers() return string:

/**
 * State tracking for peak hold per meter
 */
var peakValues = {};
var peakTimers = {};

/**
 * Update styled meter level (zone fills with clip-path, peak indicator)
 * @param {string} elementId - Meter element ID
 * @param {number} normalizedValue - Value 0-1
 */
function updateMeter(elementId, normalizedValue) {
  var element = document.getElementById(elementId);
  if (!element || !element.classList.contains('styled-meter')) return;

  // Zone thresholds (matches Phase 57-02 decisions)
  var yellowThreshold = 0.6;  // -18dB normalized
  var redThreshold = 0.85;    // -6dB normalized

  // Calculate clip-path for bottom-up reveal
  var clipFromTop = (1 - normalizedValue) * 100;
  var clipPath = 'inset(' + clipFromTop + '% 0 0 0)';

  // Get zone fill elements
  var fillGreen = element.querySelector('.meter-fill-green');
  var fillYellow = element.querySelector('.meter-fill-yellow');
  var fillRed = element.querySelector('.meter-fill-red');
  var fillSingle = element.querySelector('.meter-fill'); // Fallback for single fill

  // Green zone: always visible up to value
  if (fillGreen) {
    fillGreen.style.clipPath = clipPath;
  }

  // Yellow zone: reveals above yellowThreshold
  if (fillYellow) {
    fillYellow.style.clipPath = normalizedValue > yellowThreshold
      ? clipPath
      : 'inset(100% 0 0 0)';
  }

  // Red zone: reveals above redThreshold
  if (fillRed) {
    fillRed.style.clipPath = normalizedValue > redThreshold
      ? clipPath
      : 'inset(100% 0 0 0)';
  }

  // Single fill fallback (if no zone layers)
  if (fillSingle && !fillGreen && !fillYellow && !fillRed) {
    fillSingle.style.clipPath = clipPath;
  }

  // Peak hold indicator (if enabled)
  if (element.dataset.peakHold === 'true') {
    updateMeterPeak(elementId, normalizedValue);
  }

  // Update data attribute
  element.dataset.value = normalizedValue;
}

/**
 * Update meter peak hold indicator with decay
 * @param {string} elementId - Meter element ID
 * @param {number} normalizedValue - Current value 0-1
 */
function updateMeterPeak(elementId, normalizedValue) {
  var element = document.getElementById(elementId);
  if (!element) return;

  var peakLayer = element.querySelector('.meter-peak');
  if (!peakLayer) return;

  var currentPeak = peakValues[elementId] || 0;

  // Update peak if value exceeds current peak
  if (normalizedValue > currentPeak) {
    peakValues[elementId] = normalizedValue;
    peakLayer.style.bottom = (normalizedValue * 100) + '%';

    // Clear existing decay timer
    if (peakTimers[elementId]) {
      clearTimeout(peakTimers[elementId]);
    }

    // Start decay timer (holdDuration from data attribute)
    var holdDuration = parseInt(element.dataset.peakDuration) || 2000;
    peakTimers[elementId] = setTimeout(function() {
      // After hold duration, let peak track current value again
      peakValues[elementId] = 0;
    }, holdDuration);
  }
}
```

Key implementation notes:
- Use 'var' instead of 'let' for browser compatibility in exported JS
- Zone thresholds hardcoded at 0.6 (-18dB) and 0.85 (-6dB) per Phase 57-02
- Peak values tracked per meter ID in object
- Timer-based decay clears peak after holdDuration (default 2000ms)
- Bottom positioning for peak indicator (CSS handles z-index)
  </action>
  <verify>
    - grep for "function updateMeter" in jsGenerator.ts shows function defined
    - grep for "function updateMeterPeak" in jsGenerator.ts shows peak function
    - grep for "peakValues\|peakTimers" shows state tracking variables
  </verify>
  <done>
    - updateMeter function in exported JS code
    - Zone fills animated with clip-path (green always, yellow > 0.6, red > 0.85)
    - Peak hold with timer-based decay
    - State tracked per meter ID
  </done>
</task>

<task type="auto">
  <name>Task 3: Add updateButton animation helper and integrate</name>
  <files>src/services/export/jsGenerator.ts</files>
  <action>
Add updateButton function and integrate all helpers into export:

```typescript
// Add to generateStyledAnimationHelpers() return string:

/**
 * Update styled button state (opacity toggle - instant, no transition)
 * @param {string} elementId - Button element ID
 * @param {boolean} pressed - Button pressed state
 */
function updateButton(elementId, pressed) {
  var element = document.getElementById(elementId);
  if (!element || !element.classList.contains('styled-button')) return;

  var normalLayer = element.querySelector('.button-normal');
  var pressedLayer = element.querySelector('.button-pressed');

  // INSTANT opacity toggle (no transition - per CONTEXT.md decision)
  if (normalLayer) {
    normalLayer.style.opacity = pressed ? '0' : '1';
  }
  if (pressedLayer) {
    pressedLayer.style.opacity = pressed ? '1' : '0';
  }

  // Toggle switch specific: on/off layers
  var onLayer = element.querySelector('.button-on');
  var offLayer = element.querySelector('.button-off');
  if (onLayer) onLayer.style.opacity = pressed ? '1' : '0';
  if (offLayer) offLayer.style.opacity = pressed ? '0' : '1';

  // LED/indicator (Power Button, Toggle Switch)
  var ledLayer = element.querySelector('.button-led');
  var indicatorLayer = element.querySelector('.button-indicator');
  if (ledLayer) ledLayer.style.opacity = pressed ? '1' : '0.3';
  if (indicatorLayer) indicatorLayer.style.opacity = pressed ? '1' : '0';

  // Update state data attribute
  element.dataset.state = pressed ? '1' : '0';
}

/**
 * Update rotary switch selector position
 * @param {string} elementId - Switch element ID
 * @param {number} position - Selected position (0-indexed)
 * @param {number} positionCount - Total number of positions
 */
function updateRotarySwitch(elementId, position, positionCount) {
  var element = document.getElementById(elementId);
  if (!element || !element.classList.contains('styled-button')) return;

  var selectorLayer = element.querySelector('.button-selector');
  if (!selectorLayer) return;

  // Calculate rotation angle
  // Assuming 270 degree range (like knob) with positions evenly distributed
  var minAngle = -135;
  var maxAngle = 135;
  var angleRange = maxAngle - minAngle;
  var anglePerPosition = positionCount > 1 ? angleRange / (positionCount - 1) : 0;
  var angle = minAngle + (position * anglePerPosition);

  selectorLayer.style.transform = 'rotate(' + angle + 'deg)';
  element.dataset.position = position;
}

/**
 * Update segment button selection (clip-path on highlight)
 * @param {string} elementId - Button element ID
 * @param {number} selectedIndex - Selected segment index
 * @param {number} segmentCount - Total segment count
 */
function updateSegmentButton(elementId, selectedIndex, segmentCount) {
  var element = document.getElementById(elementId);
  if (!element || !element.classList.contains('styled-button')) return;

  var highlightLayer = element.querySelector('.button-highlight');
  if (!highlightLayer) return;

  // Calculate clip-path for selected segment
  var segmentWidth = 100 / segmentCount;
  var clipLeft = selectedIndex * segmentWidth;
  var clipRight = 100 - ((selectedIndex + 1) * segmentWidth);
  var clipPath = 'inset(0 ' + clipRight + '% 0 ' + clipLeft + '%)';

  highlightLayer.style.clipPath = clipPath;
  element.dataset.selectedIndex = selectedIndex;
}
```

Now integrate generateStyledAnimationHelpers into the main JS output:

1. Find generateBindingsJS function
2. Find where the final JS string is assembled
3. Add call to generateStyledAnimationHelpers() in the output

```typescript
// In generateBindingsJS, add to the final return:
return `
${generateStyledAnimationHelpers()}

// Existing bindings code...
${existingBindingsCode}
`;
```

4. Update existing binding functions to call the animation helpers:
   - setupKnobInteraction already exists - no change needed (knobs use transform rotation)
   - setupSliderInteraction should call updateSlider() after value update
   - setupButtonInteraction should call updateButton() after state change

For example, modify how slider bindings update the visual:
```typescript
// In the slider interaction handler, after updating internal value:
updateSlider(elementId, normalizedValue);
```

Note: If existing setup functions don't call these helpers directly, add a comment explaining that the helpers are available for custom integration. The key is that the functions are exported in the JS bundle.
  </action>
  <verify>
    - grep for "function updateButton" in jsGenerator.ts shows function defined
    - grep for "function updateRotarySwitch" shows rotary switch function
    - grep for "function updateSegmentButton" shows segment button function
    - grep for "generateStyledAnimationHelpers" shows function export
    - TypeScript compiles: npm run build
  </verify>
  <done>
    - updateButton function uses instant opacity toggle (no transition)
    - updateRotarySwitch rotates selector to position
    - updateSegmentButton clips highlight to selected segment
    - All helpers included in exported JS bundle
    - Existing binding setup functions can call these helpers
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles: `npm run build` exits 0
2. All animation helpers defined:
   - `grep -n "function updateSlider" src/services/export/jsGenerator.ts`
   - `grep -n "function updateMeter" src/services/export/jsGenerator.ts`
   - `grep -n "function updateButton" src/services/export/jsGenerator.ts`
3. Helper functions use correct patterns:
   - Slider: transform translate for thumb, clip-path for fill
   - Meter: clip-path with zone thresholds, peak hold timer
   - Button: instant opacity toggle (no transitions)
4. generateStyledAnimationHelpers function exists and is called
</verification>

<success_criteria>
- [ ] updateSlider function animates thumb position and fill clip-path
- [ ] updateMeter function animates zone fills with correct thresholds (0.6, 0.85)
- [ ] updateMeterPeak function tracks peak with timer-based decay
- [ ] updateButton function toggles opacity instantly (no CSS transition)
- [ ] updateRotarySwitch function rotates selector to position angle
- [ ] updateSegmentButton function clips highlight to selected segment
- [ ] All helpers included in exported JS output
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/58-export/58-03-SUMMARY.md`
</output>
